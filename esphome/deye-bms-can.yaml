# ESPHome configuration for Waveshare ESP32-S3-RS485-CAN
# Replaces pylon_can2mqtt.py - CAN->MQTT bridge for Deye/Shoto BMS
#
# Hardware: Waveshare ESP32-S3-RS485-CAN
# CAN pins: TX=GPIO15, RX=GPIO16
# Pylontech CAN protocol at 500kbps

substitutions:
  device_name: deye-bms-can
  friendly_name: "Deye BMS (CAN)"
  # Must match existing MQTT topics for seamless migration
  mqtt_prefix: deye_bms

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  on_boot:
    priority: -100
    then:
      - logger.log: "CAN bus bridge starting..."

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO

# WiFi configuration - UPDATE THESE
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Optional: static IP for reliability
  # manual_ip:
  #   static_ip: 192.168.200.xxx
  #   gateway: 192.168.200.1
  #   subnet: 255.255.255.0

  ap:
    ssid: "${device_name}-fallback"
    password: "fallback123"

captive_portal:

# MQTT configuration - UPDATE THESE
mqtt:
  broker: !secret mqtt_host
  port: 1883
  username: !secret mqtt_user
  password: !secret mqtt_password

  # Birth/will messages for availability
  birth_message:
    topic: ${mqtt_prefix}/status
    payload: "online"
    retain: true
  will_message:
    topic: ${mqtt_prefix}/status
    payload: "offline"
    retain: true

  # Disable HA discovery via MQTT component (we do it manually for compatibility)
  discovery: false

# OTA updates
ota:
  - platform: esphome
    password: !secret ota_password

# Web server for debugging
web_server:
  port: 80

# CAN bus configuration for Waveshare ESP32-S3-RS485-CAN
canbus:
  - platform: esp32_can
    id: can_bus
    tx_pin: GPIO15
    rx_pin: GPIO16
    can_id: 0
    bit_rate: 500kbps

    # 0x351: Voltage/current limits
    on_frame:
      - can_id: 0x351
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; ESP_LOGI("can", "CAN data resumed"); }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              float v_charge_max = le_u16(x[0], x[1]) / 10.0f;
              float i_charge_lim = le_u16(x[2], x[3]) / 10.0f;
              float i_dis_lim = le_u16(x[4], x[5]) / 10.0f;
              float v_low_lim = le_u16(x[6], x[7]) / 10.0f;

              if (v_charge_max >= 30.0f && v_charge_max <= 65.0f &&
                  v_low_lim >= 30.0f && v_low_lim <= 65.0f &&
                  i_charge_lim >= 0.0f && i_charge_lim <= 500.0f &&
                  i_dis_lim >= 0.0f && i_dis_lim <= 500.0f) {
                id(sensor_v_charge_max).publish_state(v_charge_max);
                id(sensor_v_low).publish_state(v_low_lim);
                id(sensor_i_charge).publish_state(i_charge_lim);
                id(sensor_i_discharge).publish_state(i_dis_lim);
              }

      # 0x355: SOC/SOH
      - can_id: 0x355
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              uint16_t soc = le_u16(x[0], x[1]);
              uint16_t soh = le_u16(x[2], x[3]);

              if (soc <= 100 && soh <= 100) {
                id(sensor_soc).publish_state(soc);
                id(sensor_soh).publish_state(soh);
              }

      # 0x359: Flags
      - can_id: 0x359
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              uint64_t flags = 0;
              for (int i = 7; i >= 0; i--) {
                flags = (flags << 8) | x[i];
              }
              char buf[32];
              snprintf(buf, sizeof(buf), "0x%016llX", flags);
              id(sensor_flags).publish_state(buf);

      # 0x370: Temperature and cell voltage extremes
      - can_id: 0x370
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              float t1 = le_u16(x[0], x[1]) / 10.0f;
              float t2 = le_u16(x[2], x[3]) / 10.0f;
              float tmin = (t1 <= t2) ? t1 : t2;
              float tmax = (t1 > t2) ? t1 : t2;

              float v1 = le_u16(x[4], x[5]) / 1000.0f;
              float v2 = le_u16(x[6], x[7]) / 1000.0f;

              if (tmin >= -10.0f && tmax <= 50.0f) {
                id(sensor_temp_min).publish_state(tmin);
                id(sensor_temp_max).publish_state(tmax);
              }

              float vmin = 0, vmax = 0;
              bool v1_valid = (v1 >= 2.0f && v1 <= 4.5f);
              bool v2_valid = (v2 >= 2.0f && v2 <= 4.5f);

              if (v1_valid && v2_valid) {
                vmin = (v1 < v2) ? v1 : v2;
                vmax = (v1 > v2) ? v1 : v2;
              } else if (v1_valid) {
                vmin = vmax = v1;
              } else if (v2_valid) {
                vmin = vmax = v2;
              }

              if (vmin > 0) {
                id(sensor_cell_v_min).publish_state(vmin);
                id(sensor_cell_v_max).publish_state(vmax);
                id(sensor_cell_v_delta).publish_state(vmax - vmin);
              }

# Global variables for stale detection
globals:
  - id: last_can_rx
    type: uint32_t
    initial_value: '0'
  - id: can_stale
    type: bool
    initial_value: 'false'

# Stale data detection interval
interval:
  - interval: 5s
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t elapsed = now - id(last_can_rx);
          // 30 second timeout
          if (elapsed > 30000 && !id(can_stale) && id(last_can_rx) > 0) {
            id(can_stale) = true;
            ESP_LOGW("can", "No CAN data for 30s, marking stale");
          }

# Sensors - these publish to MQTT topics matching the Python script
sensor:
  # SOC/SOH
  - platform: template
    id: sensor_soc
    name: "BMS SOC"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery"
    state_topic: ${mqtt_prefix}/soc

  - platform: template
    id: sensor_soh
    name: "BMS SOH"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery-heart"
    state_topic: ${mqtt_prefix}/soh
    retain: true

  # Voltage/current limits
  - platform: template
    id: sensor_v_charge_max
    name: "BMS Charge Voltage Max"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/limit/v_charge_max
    retain: true

  - platform: template
    id: sensor_v_low
    name: "BMS Low Voltage Limit"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/limit/v_low
    retain: true

  - platform: template
    id: sensor_i_charge
    name: "BMS Charge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/limit/i_charge

  - platform: template
    id: sensor_i_discharge
    name: "BMS Discharge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/limit/i_discharge

  # Cell voltage extremes
  - platform: template
    id: sensor_cell_v_min
    name: "Cell Min Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    state_topic: ${mqtt_prefix}/ext/cell_v_min

  - platform: template
    id: sensor_cell_v_max
    name: "Cell Max Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    state_topic: ${mqtt_prefix}/ext/cell_v_max

  - platform: template
    id: sensor_cell_v_delta
    name: "Cell Delta Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    icon: "mdi:chart-bell-curve-cumulative"
    state_topic: ${mqtt_prefix}/ext/cell_v_delta

  # Temperature extremes
  - platform: template
    id: sensor_temp_min
    name: "Min Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/ext/temp_min

  - platform: template
    id: sensor_temp_max
    name: "Max Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/ext/temp_max

  # WiFi signal strength for diagnostics
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  # Uptime for diagnostics
  - platform: uptime
    name: "Uptime"

text_sensor:
  # BMS Flags
  - platform: template
    id: sensor_flags
    name: "BMS Flags"
    icon: "mdi:flag"
    state_topic: ${mqtt_prefix}/flags

  # ESPHome version
  - platform: version
    name: "ESPHome Version"

# Binary sensor for CAN stale status
binary_sensor:
  - platform: template
    name: "CAN Data Stale"
    lambda: 'return id(can_stale);'
    device_class: problem

# Restart button
button:
  - platform: restart
    name: "Restart"
