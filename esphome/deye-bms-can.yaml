# ESPHome configuration for Waveshare ESP32-S3-RS485-CAN
# Drop-in replacement for pylon_can2mqtt.py and pylon_rs485_monitor.py
#
# Hardware: Waveshare ESP32-S3-RS485-CAN
# CAN pins: TX=GPIO15, RX=GPIO16 (500kbps Pylontech protocol)
# RS485 pins: TX=GPIO17, RX=GPIO18, EN=GPIO21 (9600 baud Pylontech protocol)
#
# MQTT topics match Python scripts exactly for seamless migration.
# Run Python scripts once to publish HA discovery configs, then switch to ESP32.

substitutions:
  device_name: deye-bms-can
  friendly_name: "Deye BMS"
  # MQTT prefixes - must match Python scripts
  can_prefix: deye_bms
  rs485_prefix: deye_bms/rs485
  # Number of batteries in stack
  num_batteries: "3"
  # Pylontech RS485 address
  pylontech_addr: "2"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  includes:
    - includes/set_include.h
  on_boot:
    priority: -100
    then:
      - logger.log: "BMS bridge starting..."
      - lambda: |-
          // Initialize arrays based on num_batteries
          const int num_batt = ${num_batteries};
          id(cell_voltages).resize(16 * num_batt, 0.0f);  // 16 cells per battery
          id(cell_temps).resize(6 * num_batt, 0.0f);      // 6 temps per battery
          id(batt_current).resize(num_batt, 0.0f);
          id(batt_voltage).resize(num_batt, 0.0f);
          id(batt_soc).resize(num_batt, 0.0f);
          id(batt_remain_ah).resize(num_batt, 0.0f);
          id(batt_total_ah).resize(num_batt, 0.0f);
          id(batt_cycles).resize(num_batt, 0);
          id(batt_balancing_count).resize(num_batt, 0);
          id(batt_balancing_cells).resize(num_batt, std::string(""));
          id(batt_overvolt_count).resize(num_batt, 0);
          id(batt_overvolt_cells).resize(num_batt, std::string(""));
          id(batt_alarms).resize(num_batt, std::string(""));
          id(batt_warnings).resize(num_batt, std::string(""));
          id(batt_state).resize(num_batt, std::string(""));
          id(batt_charge_mosfet).resize(num_batt, false);
          id(batt_discharge_mosfet).resize(num_batt, false);
          id(batt_lmcharge_mosfet).resize(num_batt, false);
          id(batt_cw_active).resize(num_batt, false);
          id(batt_cw_cells).resize(num_batt, std::string(""));

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:
  level: INFO

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "${device_name}-fallback"
    password: "fallback123"

captive_portal:

mqtt:
  id: mqtt_client
  broker: !secret mqtt_host
  port: 1883
  username: !secret mqtt_user
  password: !secret mqtt_password

  # CAN bridge availability
  birth_message:
    topic: ${can_prefix}/status
    payload: "online"
    retain: true
  will_message:
    topic: ${can_prefix}/status
    payload: "offline"
    retain: true

  # Disable native discovery - we use Python discovery configs for compatibility
  discovery: false

  on_connect:
    - lambda: |-
        // Publish RS485 availability
        id(mqtt_client).publish(std::string("${rs485_prefix}/status"), std::string("online"), (uint8_t)0, true);
        ESP_LOGI("mqtt", "Connected, published availability");

        // Publish HA Discovery configs
        // Device info shared by all entities
        const char* device_json = R"("device":{"identifiers":["pylontech_rs485"],"name":"Pylontech RS485","manufacturer":"Pylontech","model":"BMS RS485"})";
        const char* avail_json = R"("availability_topic":"${rs485_prefix}/status","payload_available":"online","payload_not_available":"offline")";

        char topic[128];
        char payload[512];

        // Stack sensors
        const char* stack_sensors[][5] = {
          {"stack_cell_min", "Stack Cell Min", "${rs485_prefix}/stack/cell_min", "V", "voltage"},
          {"stack_cell_max", "Stack Cell Max", "${rs485_prefix}/stack/cell_max", "V", "voltage"},
          {"stack_cell_delta", "Stack Cell Delta", "${rs485_prefix}/stack/cell_delta_mv", "mV", ""},
          {"stack_voltage", "Stack Voltage", "${rs485_prefix}/stack/voltage", "V", "voltage"},
          {"stack_current", "Stack Current", "${rs485_prefix}/stack/current", "A", "current"},
          {"stack_temp_min", "Stack Temp Min", "${rs485_prefix}/stack/temp_min", "°C", "temperature"},
          {"stack_temp_max", "Stack Temp Max", "${rs485_prefix}/stack/temp_max", "°C", "temperature"},
          {"stack_balancing_count", "Stack Balancing Cells", "${rs485_prefix}/stack/balancing_count", "", ""},
          {"stack_balancing_cells", "Stack Balancing Cells List", "${rs485_prefix}/stack/balancing_cells", "", ""},
          {"stack_overvolt_count", "Stack Overvolt Cells", "${rs485_prefix}/stack/overvolt_count", "", ""},
          {"stack_overvolt_cells", "Stack Overvolt Cells List", "${rs485_prefix}/stack/overvolt_cells", "", ""},
          {"stack_alarms", "Stack Alarms", "${rs485_prefix}/stack/alarms", "", ""},
        };

        for (int i = 0; i < 12; i++) {
          snprintf(topic, sizeof(topic), "homeassistant/sensor/pylontech_rs485/%s/config", stack_sensors[i][0]);
          if (strlen(stack_sensors[i][3]) > 0 && strlen(stack_sensors[i][4]) > 0) {
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"%s","device_class":"%s","state_class":"measurement",%s,%s})",
              stack_sensors[i][1], stack_sensors[i][2], stack_sensors[i][0], stack_sensors[i][3], stack_sensors[i][4], avail_json, device_json);
          } else if (strlen(stack_sensors[i][3]) > 0) {
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"%s","state_class":"measurement",%s,%s})",
              stack_sensors[i][1], stack_sensors[i][2], stack_sensors[i][0], stack_sensors[i][3], avail_json, device_json);
          } else {
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s",%s,%s})",
              stack_sensors[i][1], stack_sensors[i][2], stack_sensors[i][0], avail_json, device_json);
          }
          id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
        }

        // Stack binary sensors
        snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/pylontech_rs485/stack_balancing_active/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"Stack Balancing Active","state_topic":"${rs485_prefix}/stack/balancing_active","unique_id":"pylontech_rs485_stack_balancing_active","payload_on":"1","payload_off":"0","icon":"mdi:scale-balance",%s,%s})",
          avail_json, device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/pylontech_rs485/stack_overvolt_active/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"Stack Overvolt Active","state_topic":"${rs485_prefix}/stack/overvolt_active","unique_id":"pylontech_rs485_stack_overvolt_active","payload_on":"1","payload_off":"0","icon":"mdi:flash-alert",%s,%s})",
          avail_json, device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        // Per-battery discovery
        for (int batt = 0; batt < ${num_batteries}; batt++) {
          char prefix[16], state_prefix[48];
          snprintf(prefix, sizeof(prefix), "batt%d", batt);
          snprintf(state_prefix, sizeof(state_prefix), "${rs485_prefix}/battery%d", batt);

          // Battery sensors
          const char* batt_sensor_names[][4] = {
            {"cell_min", "Cell Min", "V", "voltage"},
            {"cell_max", "Cell Max", "V", "voltage"},
            {"cell_delta", "Cell Delta", "mV", ""},
            {"voltage", "Voltage", "V", "voltage"},
            {"current", "Current", "A", "current"},
            {"soc", "SOC", "%", ""},
            {"remain_ah", "Remaining Capacity", "Ah", ""},
            {"total_ah", "Total Capacity", "Ah", ""},
            {"cycles", "Cycles", "", ""},
            {"balancing_count", "Balancing Cells", "", ""},
            {"balancing_cells", "Balancing Cells List", "", ""},
            {"overvolt_count", "Overvolt Cells", "", ""},
            {"overvolt_cells", "Overvolt Cells List", "", ""},
            {"state", "State", "", ""},
            {"warnings", "Warnings", "", ""},
            {"alarms", "Alarms", "", ""},
            {"cw_cells", "CW Cells List", "", ""},
          };

          for (int i = 0; i < 17; i++) {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_%s", prefix, batt_sensor_names[i][0]);
            snprintf(name, sizeof(name), "Battery %d %s", batt, batt_sensor_names[i][1]);
            snprintf(st, sizeof(st), "%s/%s", state_prefix, batt_sensor_names[i][0]);
            // Fix topic names for cell_delta
            if (strcmp(batt_sensor_names[i][0], "cell_delta") == 0) {
              snprintf(st, sizeof(st), "%s/cell_delta_mv", state_prefix);
            }

            snprintf(topic, sizeof(topic), "homeassistant/sensor/pylontech_rs485/%s/config", obj_id);
            if (strlen(batt_sensor_names[i][2]) > 0 && strlen(batt_sensor_names[i][3]) > 0) {
              snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"%s","device_class":"%s","state_class":"measurement",%s,%s})",
                name, st, obj_id, batt_sensor_names[i][2], batt_sensor_names[i][3], avail_json, device_json);
            } else if (strlen(batt_sensor_names[i][2]) > 0) {
              snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"%s","state_class":"measurement",%s,%s})",
                name, st, obj_id, batt_sensor_names[i][2], avail_json, device_json);
            } else {
              snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s",%s,%s})",
                name, st, obj_id, avail_json, device_json);
            }
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }

          // Battery binary sensors
          const char* batt_binary_names[][2] = {
            {"balancing_active", "Balancing Active"},
            {"overvolt_active", "Overvolt Active"},
            {"charge_mosfet", "Charge MOSFET"},
            {"discharge_mosfet", "Discharge MOSFET"},
            {"lmcharge_mosfet", "LM Charge MOSFET"},
            {"cw_active", "Cell Warning"},
          };

          for (int i = 0; i < 6; i++) {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_%s", prefix, batt_binary_names[i][0]);
            snprintf(name, sizeof(name), "Battery %d %s", batt, batt_binary_names[i][1]);
            snprintf(st, sizeof(st), "%s/%s", state_prefix, batt_binary_names[i][0]);

            snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/pylontech_rs485/%s/config", obj_id);
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","payload_on":"1","payload_off":"0",%s,%s})",
              name, st, obj_id, avail_json, device_json);
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }

          // Individual cell voltages
          for (int cell = 1; cell <= 16; cell++) {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_cell%02d", prefix, cell);
            snprintf(name, sizeof(name), "Battery %d Cell %d", batt, cell);
            snprintf(st, sizeof(st), "%s/cell%02d", state_prefix, cell);

            snprintf(topic, sizeof(topic), "homeassistant/sensor/pylontech_rs485/%s/config", obj_id);
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"V","device_class":"voltage","state_class":"measurement","suggested_display_precision":3,%s,%s})",
              name, st, obj_id, avail_json, device_json);
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }

          // Temperature sensors
          for (int temp = 1; temp <= 6; temp++) {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_temp%d", prefix, temp);
            snprintf(name, sizeof(name), "Battery %d Temp %d", batt, temp);
            snprintf(st, sizeof(st), "%s/temp%d", state_prefix, temp);

            snprintf(topic, sizeof(topic), "homeassistant/sensor/pylontech_rs485/%s/config", obj_id);
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"°C","device_class":"temperature","state_class":"measurement",%s,%s})",
              name, st, obj_id, avail_json, device_json);
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }
        }

        ESP_LOGI("mqtt", "Published HA discovery configs for %d batteries", ${num_batteries});

ota:
  - platform: esphome
    password: !secret ota_password

web_server:
  port: 80

# UART for RS485
uart:
  id: rs485_uart
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 9600
  data_bits: 8
  stop_bits: 1
  parity: NONE

# RS485 direction control (active high = transmit)
output:
  - platform: gpio
    id: rs485_en
    pin: GPIO21

# CAN bus configuration
canbus:
  - platform: esp32_can
    id: can_bus
    tx_pin: GPIO15
    rx_pin: GPIO16
    can_id: 0
    bit_rate: 500kbps

    on_frame:
      # 0x351: Voltage/current limits
      - can_id: 0x351
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              float v_charge_max = le_u16(x[0], x[1]) / 10.0f;
              float i_charge_lim = le_u16(x[2], x[3]) / 10.0f;
              float i_dis_lim = le_u16(x[4], x[5]) / 10.0f;
              float v_low_lim = le_u16(x[6], x[7]) / 10.0f;

              // Sanity checks
              if (v_charge_max >= 30.0f && v_charge_max <= 65.0f &&
                  v_low_lim >= 30.0f && v_low_lim <= 65.0f &&
                  i_charge_lim >= 0.0f && i_charge_lim <= 500.0f &&
                  i_dis_lim >= 0.0f && i_dis_lim <= 500.0f) {
                id(sensor_v_charge_max).publish_state(v_charge_max);
                id(sensor_v_low).publish_state(v_low_lim);
                id(sensor_i_charge).publish_state(i_charge_lim);
                id(sensor_i_discharge).publish_state(i_dis_lim);
              }

      # 0x355: SOC/SOH
      - can_id: 0x355
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              uint16_t soc = le_u16(x[0], x[1]);
              uint16_t soh = le_u16(x[2], x[3]);

              if (soc <= 100 && soh <= 100) {
                id(sensor_soc).publish_state(soc);
                id(sensor_soh).publish_state(soh);
              }

      # 0x359: Flags
      - can_id: 0x359
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              uint64_t flags = 0;
              for (int i = 7; i >= 0; i--) {
                flags = (flags << 8) | x[i];
              }
              char buf[32];
              snprintf(buf, sizeof(buf), "0x%016llX", flags);
              id(sensor_flags).publish_state(buf);

      # 0x370: Temperature and cell voltage extremes
      - can_id: 0x370
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              float t1 = le_u16(x[0], x[1]) / 10.0f;
              float t2 = le_u16(x[2], x[3]) / 10.0f;
              float tmin = (t1 <= t2) ? t1 : t2;
              float tmax = (t1 > t2) ? t1 : t2;

              float v1 = le_u16(x[4], x[5]) / 1000.0f;
              float v2 = le_u16(x[6], x[7]) / 1000.0f;

              if (tmin >= -10.0f && tmax <= 50.0f) {
                id(sensor_temp_min).publish_state(tmin);
                id(sensor_temp_max).publish_state(tmax);
              }

              float vmin = 0, vmax = 0;
              bool v1_valid = (v1 >= 2.0f && v1 <= 4.5f);
              bool v2_valid = (v2 >= 2.0f && v2 <= 4.5f);

              if (v1_valid && v2_valid) {
                vmin = (v1 < v2) ? v1 : v2;
                vmax = (v1 > v2) ? v1 : v2;
              } else if (v1_valid) {
                vmin = vmax = v1;
              } else if (v2_valid) {
                vmin = vmax = v2;
              }

              if (vmin > 0) {
                id(sensor_cell_v_min).publish_state(vmin);
                id(sensor_cell_v_max).publish_state(vmax);
                id(sensor_cell_v_delta).publish_state(vmax - vmin);
              }

# Global variables
globals:
  # CAN stale detection
  - id: last_can_rx
    type: uint32_t
    initial_value: '0'
  - id: can_stale
    type: bool
    initial_value: 'false'

  # RS485 polling state
  - id: rs485_poll_battery
    type: int
    initial_value: '0'

  # Cell voltages: 3 batteries x 16 cells = 48
  - id: cell_voltages
    type: std::vector<float>
    restore_value: no

  # Temperatures: 3 batteries x 6 sensors = 18
  - id: cell_temps
    type: std::vector<float>
    restore_value: no

  # Per-battery data
  - id: batt_current
    type: std::vector<float>
    restore_value: no
  - id: batt_voltage
    type: std::vector<float>
    restore_value: no
  - id: batt_soc
    type: std::vector<float>
    restore_value: no
  - id: batt_remain_ah
    type: std::vector<float>
    restore_value: no
  - id: batt_total_ah
    type: std::vector<float>
    restore_value: no
  - id: batt_cycles
    type: std::vector<int>
    restore_value: no
  - id: batt_balancing_count
    type: std::vector<int>
    restore_value: no
  - id: batt_balancing_cells
    type: std::vector<std::string>
    restore_value: no
  - id: batt_overvolt_count
    type: std::vector<int>
    restore_value: no
  - id: batt_overvolt_cells
    type: std::vector<std::string>
    restore_value: no
  - id: batt_alarms
    type: std::vector<std::string>
    restore_value: no
  - id: batt_warnings
    type: std::vector<std::string>
    restore_value: no
  - id: batt_state
    type: std::vector<std::string>
    restore_value: no
  - id: batt_charge_mosfet
    type: std::vector<bool>
    restore_value: no
  - id: batt_discharge_mosfet
    type: std::vector<bool>
    restore_value: no
  - id: batt_lmcharge_mosfet
    type: std::vector<bool>
    restore_value: no

  # CW (Cell Warning) flag - correlates with CW=Y on BMS display
  - id: batt_cw_active
    type: std::vector<bool>
    restore_value: no
  - id: batt_cw_cells
    type: std::vector<std::string>
    restore_value: no

  # Stack totals
  - id: stack_balancing_count
    type: int
    initial_value: '0'
  - id: stack_balancing_cells
    type: std::string
    restore_value: no
  - id: stack_overvolt_count
    type: int
    initial_value: '0'
  - id: stack_overvolt_cells
    type: std::string
    restore_value: no
  - id: stack_alarms
    type: std::string
    restore_value: no

# Intervals for stale detection and RS485 polling
interval:
  # CAN stale detection
  - interval: 5s
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t elapsed = now - id(last_can_rx);
          if (elapsed > 30000 && !id(can_stale) && id(last_can_rx) > 0) {
            id(can_stale) = true;
            ESP_LOGW("can", "No CAN data for 30s, marking stale");
            id(mqtt_client).publish(std::string("${can_prefix}/status"), std::string("offline"), (uint8_t)0, true);
          }

  # RS485 analog data polling - cycle through batteries
  - interval: 10s
    then:
      - lambda: |-
          // Pylontech RS485 command builder
          auto calc_chksum = [](const std::string& frame) -> std::string {
            uint32_t total = 0;
            for (char c : frame) total += (uint8_t)c;
            uint16_t chk = (~total + 1) & 0xFFFF;
            char buf[5];
            snprintf(buf, sizeof(buf), "%04X", chk);
            return std::string(buf);
          };

          auto make_cmd = [&calc_chksum](int addr, int cid2, int batt_num) -> std::string {
            char frame[32];
            char info[3];
            snprintf(info, sizeof(info), "%02X", batt_num);
            int info_len = 1;
            int lchksum = (~(0 + 0 + info_len) + 1) & 0xF;
            char lenid[5];
            snprintf(lenid, sizeof(lenid), "%X%03X", lchksum, info_len * 2);
            snprintf(frame, sizeof(frame), "20%02X46%02X%s%s", addr, cid2, lenid, info);
            std::string result = "~";
            result += frame;
            result += calc_chksum(frame);
            result += "\r";
            return result;
          };

          int batt = id(rs485_poll_battery);
          int addr = ${pylontech_addr};

          // Send analog data request (CID2=0x42)
          std::string cmd = make_cmd(addr, 0x42, batt);
          ESP_LOGD("rs485", "TX analog batt %d", batt);

          // Clear RX buffer
          while (id(rs485_uart).available()) {
            uint8_t c;
            id(rs485_uart).read_byte(&c);
          }

          // Enable RS485 transmit
          id(rs485_en).turn_on();

          for (char c : cmd) {
            id(rs485_uart).write_byte((uint8_t)c);
          }
          id(rs485_uart).flush();

          // Disable RS485 transmit (back to receive mode)
          id(rs485_en).turn_off();

          id(rs485_poll_battery) = (batt + 1) % ${num_batteries};

      - delay: 300ms

      - lambda: |-
          // Read response
          std::string response;
          while (id(rs485_uart).available()) {
            uint8_t c;
            id(rs485_uart).read_byte(&c);
            response += (char)c;
          }

          if (response.length() < 18 || response.substr(7, 2) != "00") {
            ESP_LOGW("rs485", "Analog response error");
            return;
          }

          // Extract INFO data
          std::string data = response.substr(13, response.length() - 13 - 5);
          int batt = (id(rs485_poll_battery) + ${num_batteries} - 1) % ${num_batteries};

          size_t i = 0;

          // Skip header (4 chars)
          if (data.length() < 6) return;
          i += 4;

          // Number of cells
          int num_cells = strtol(data.substr(i, 2).c_str(), nullptr, 16);
          i += 2;

          // Cell voltages
          for (int cell = 0; cell < num_cells && cell < 16; cell++) {
            if (data.length() < i + 4) break;
            int mv = strtol(data.substr(i, 4).c_str(), nullptr, 16);
            id(cell_voltages)[batt * 16 + cell] = mv / 1000.0f;
            i += 4;
          }

          // Number of temps
          if (data.length() < i + 2) return;
          int num_temps = strtol(data.substr(i, 2).c_str(), nullptr, 16);
          i += 2;

          // Temperatures (Kelvin * 10 - 2731 = Celsius * 10)
          for (int t = 0; t < num_temps && t < 6; t++) {
            if (data.length() < i + 4) break;
            int raw = strtol(data.substr(i, 4).c_str(), nullptr, 16);
            id(cell_temps)[batt * 6 + t] = (raw - 2731) / 10.0f;
            i += 4;
          }

          // Current (signed, 10mA units)
          if (data.length() >= i + 4) {
            int raw = strtol(data.substr(i, 4).c_str(), nullptr, 16);
            if (raw > 0x7FFF) raw -= 0x10000;
            id(batt_current)[batt] = raw / 100.0f;
            i += 4;
          }

          // Voltage (mV)
          if (data.length() >= i + 4) {
            id(batt_voltage)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16) / 1000.0f;
            i += 4;
          }

          // Remaining capacity (10mAh)
          if (data.length() >= i + 4) {
            id(batt_remain_ah)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16) / 100.0f;
            i += 4;
          }

          // Skip custom byte
          i += 2;

          // Total capacity (10mAh)
          if (data.length() >= i + 4) {
            id(batt_total_ah)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16) / 100.0f;
            i += 4;
          }

          // Cycles
          if (data.length() >= i + 4) {
            id(batt_cycles)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16);
          }

          // Calculate SOC
          if (id(batt_total_ah)[batt] > 0) {
            id(batt_soc)[batt] = (id(batt_remain_ah)[batt] / id(batt_total_ah)[batt]) * 100.0f;
          }

          ESP_LOGI("rs485", "Batt %d: %.3fV %.2fA SOC=%.0f%% cycles=%d",
                   batt, id(batt_voltage)[batt], id(batt_current)[batt],
                   id(batt_soc)[batt], id(batt_cycles)[batt]);

  # RS485 alarm/balancing polling
  - interval: 30s
    then:
      - lambda: |-
          auto calc_chksum = [](const std::string& frame) -> std::string {
            uint32_t total = 0;
            for (char c : frame) total += (uint8_t)c;
            uint16_t chk = (~total + 1) & 0xFFFF;
            char buf[5];
            snprintf(buf, sizeof(buf), "%04X", chk);
            return std::string(buf);
          };

          auto make_cmd = [&calc_chksum](int addr, int cid2, int batt_num) -> std::string {
            char frame[32];
            char info[3];
            snprintf(info, sizeof(info), "%02X", batt_num);
            int info_len = 1;
            int lchksum = (~(0 + 0 + info_len) + 1) & 0xF;
            char lenid[5];
            snprintf(lenid, sizeof(lenid), "%X%03X", lchksum, info_len * 2);
            snprintf(frame, sizeof(frame), "20%02X46%02X%s%s", addr, cid2, lenid, info);
            std::string result = "~";
            result += frame;
            result += calc_chksum(frame);
            result += "\r";
            return result;
          };

          int addr = ${pylontech_addr};
          int total_balancing = 0;
          int total_overvolt = 0;
          std::set<std::string> all_alarms;

          for (int batt = 0; batt < ${num_batteries}; batt++) {
            // Clear buffer
            while (id(rs485_uart).available()) {
              uint8_t c;
              id(rs485_uart).read_byte(&c);
            }

            // Send alarm request (CID2=0x44)
            std::string cmd = make_cmd(addr, 0x44, batt);

            // Enable RS485 transmit
            id(rs485_en).turn_on();

            for (char c : cmd) {
              id(rs485_uart).write_byte((uint8_t)c);
            }
            id(rs485_uart).flush();

            // Disable RS485 transmit (back to receive mode)
            id(rs485_en).turn_off();

            delay(300);

            // Read response
            std::string response;
            while (id(rs485_uart).available()) {
              uint8_t c;
              id(rs485_uart).read_byte(&c);
              response += (char)c;
            }

            if (response.length() < 18 || response.substr(7, 2) != "00") {
              continue;
            }

            std::string data = response.substr(13, response.length() - 13 - 5);
            if (data.length() < 40) continue;

            // Parse: skip info_flag(2), battery(2), get num_cells(2)
            int num_cells = strtol(data.substr(4, 2).c_str(), nullptr, 16);

            // Cell status bytes (0x00=normal, 0x01=undervolt, 0x02=overvolt)
            // Note: Balance flags are NOT in per-cell bytes - they're in status bytes 9-10
            std::set<std::string> batt_warnings_set;
            std::set<std::string> batt_alarms_set;
            int overvolt_count = 0;
            std::string ov_cells_str;

            for (int c = 0; c < num_cells && c < 16; c++) {
              int pos = 6 + c * 2;
              if (pos + 2 <= (int)data.length()) {
                int status = strtol(data.substr(pos, 2).c_str(), nullptr, 16);
                // Cell undervolt is an alarm, overvolt at 100% SOC is just a warning
                if (status == 0x01) { batt_alarms_set.insert("cell_undervolt"); all_alarms.insert("cell_undervolt"); }
                if (status == 0x02) {
                  batt_warnings_set.insert("cell_overvolt");
                  overvolt_count++;
                  if (!ov_cells_str.empty()) ov_cells_str += ",";
                  ov_cells_str += std::to_string(c + 1);
                }
              }
            }
            id(batt_overvolt_count)[batt] = overvolt_count;
            id(batt_overvolt_cells)[batt] = ov_cells_str;
            total_overvolt += overvolt_count;

            // Temperature status
            int temp_pos = 6 + num_cells * 2;
            if (temp_pos + 2 <= (int)data.length()) {
              int num_temps = strtol(data.substr(temp_pos, 2).c_str(), nullptr, 16);
              int t_start = temp_pos + 2;
              for (int t = 0; t < num_temps; t++) {
                int pos = t_start + t * 2;
                if (pos + 2 <= (int)data.length()) {
                  int status = strtol(data.substr(pos, 2).c_str(), nullptr, 16);
                  if (status == 0x01) { batt_alarms_set.insert("undertemp"); all_alarms.insert("undertemp"); }
                  if (status == 0x02) { batt_alarms_set.insert("overtemp"); all_alarms.insert("overtemp"); }
                }
              }

              // Status bytes start after temp status bytes
              // Structure: Current(1) + PackVolt(1) + ExtBitCount(1) + ExtBit data
              int status_pos = t_start + num_temps * 2;
              int ext_bit_start = status_pos + 6;  // Skip Current + PackVolt + Count (3 bytes = 6 hex chars)

              // Byte 0-1: Current/voltage status (before Ext_Bit section)
              if (status_pos + 2 <= (int)data.length()) {
                int charge_current = strtol(data.substr(status_pos, 2).c_str(), nullptr, 16);
                if (charge_current == 0x02) { batt_alarms_set.insert("charge_overcurrent"); all_alarms.insert("charge_overcurrent"); }
              }
              if (status_pos + 4 <= (int)data.length()) {
                int module_voltage = strtol(data.substr(status_pos + 2, 2).c_str(), nullptr, 16);
                if (module_voltage == 0x01) { batt_alarms_set.insert("pack_undervolt"); all_alarms.insert("pack_undervolt"); }
                if (module_voltage == 0x02) { batt_alarms_set.insert("pack_overvolt"); all_alarms.insert("pack_overvolt"); }
              }

              // ByteIndex 0: Balance On flag (in Ext_Bit section)
              bool balance_on = false;
              if (ext_bit_start + 2 <= (int)data.length()) {
                int balance_status = strtol(data.substr(ext_bit_start, 2).c_str(), nullptr, 16);
                balance_on = (balance_status & 0x01) != 0;
              }

              // ByteIndex 4 (ext_bit_start+8): Voltage status bitfield
              // bit0=CellOV_Alarm, bit1=CellOV_Protect, bit2=CellUV_Alarm, bit3=CellUV_Protect
              // bit4=PackOV_Alarm, bit5=PackOV_Protect, bit6=PackUV_Alarm, bit7=PackUV_Protect
              if (ext_bit_start + 10 <= (int)data.length()) {
                int voltage_status = strtol(data.substr(ext_bit_start + 8, 2).c_str(), nullptr, 16);
                // Warnings (informational - normal at 100% SOC)
                if (voltage_status & 0x01) batt_warnings_set.insert("cell_overvolt_alarm");
                if (voltage_status & 0x02) batt_warnings_set.insert("cell_overvolt_protect");
                if (voltage_status & 0x04) batt_warnings_set.insert("cell_undervolt_alarm");
                if (voltage_status & 0x10) batt_warnings_set.insert("pack_overvolt_alarm");
                if (voltage_status & 0x20) batt_warnings_set.insert("pack_overvolt_protect");
                if (voltage_status & 0x40) batt_warnings_set.insert("pack_undervolt_alarm");
                // Protections (actual problems)
                if (voltage_status & 0x08) { batt_alarms_set.insert("cell_undervolt_protect"); all_alarms.insert("cell_undervolt_protect"); }
                if (voltage_status & 0x80) { batt_alarms_set.insert("pack_undervolt_protect"); all_alarms.insert("pack_undervolt_protect"); }
              }

              // ByteIndex 9-10 (ext_bit_start+18): Individual cell balance flags
              // ByteIndex 9: Balance1-8 (bit0=cell1...bit7=cell8)
              // ByteIndex 10: Balance9-16 (bit0=cell9...bit7=cell16)
              // Only count balancing cells if Balance On flag is set
              int balancing = 0;
              std::string bal_cells_str;
              if (balance_on && ext_bit_start + 22 <= (int)data.length()) {
                int balance1_8 = strtol(data.substr(ext_bit_start + 18, 2).c_str(), nullptr, 16);
                int balance9_16 = strtol(data.substr(ext_bit_start + 20, 2).c_str(), nullptr, 16);
                for (int bit = 0; bit < 8; bit++) {
                  if (balance1_8 & (1 << bit)) {
                    balancing++;
                    if (!bal_cells_str.empty()) bal_cells_str += ",";
                    bal_cells_str += std::to_string(bit + 1);
                  }
                  if (balance9_16 & (1 << bit)) {
                    balancing++;
                    if (!bal_cells_str.empty()) bal_cells_str += ",";
                    bal_cells_str += std::to_string(bit + 9);
                  }
                }
              }
              id(batt_balancing_count)[batt] = balancing;
              id(batt_balancing_cells)[batt] = bal_cells_str;
              total_balancing += balancing;

              // ByteIndex 8 (ext_bit_start+16): MOSFET status
              // bit0=DISCHG_MOSFET, bit1=CHG_MOSFET, bit2=LMCHG_MOSFET
              if (ext_bit_start + 18 <= (int)data.length()) {
                int mosfet_status = strtol(data.substr(ext_bit_start + 16, 2).c_str(), nullptr, 16);
                id(batt_discharge_mosfet)[batt] = (mosfet_status & 0x01) != 0;
                id(batt_charge_mosfet)[batt] = (mosfet_status & 0x02) != 0;
                id(batt_lmcharge_mosfet)[batt] = (mosfet_status & 0x04) != 0;
              }

              // CW (Cell Warning) flag - read from OLD position (status_pos+18)
              // This correlates with CW=Y on BMS display
              if (status_pos + 22 <= (int)data.length()) {
                int cw_byte1 = strtol(data.substr(status_pos + 18, 2).c_str(), nullptr, 16);
                int cw_byte2 = strtol(data.substr(status_pos + 20, 2).c_str(), nullptr, 16);
                id(batt_cw_active)[batt] = (cw_byte1 != 0) || (cw_byte2 != 0);
                // Build CW cells string
                std::string cw_str;
                for (int bit = 0; bit < 8; bit++) {
                  if (cw_byte1 & (1 << bit)) {
                    if (!cw_str.empty()) cw_str += ",";
                    cw_str += std::to_string(bit + 1);
                  }
                  if (cw_byte2 & (1 << bit)) {
                    if (!cw_str.empty()) cw_str += ",";
                    cw_str += std::to_string(bit + 9);
                  }
                }
                id(batt_cw_cells)[batt] = cw_str;
              }

              // Operating state from last byte
              // 0x01=Discharge, 0x02=Charge, 0x04=Float, 0x08=Full, 0x10=Standby, 0x20=Shutdown
              if (data.length() >= 2) {
                int last_byte = strtol(data.substr(data.length() - 2, 2).c_str(), nullptr, 16);
                std::string state_str;
                if (last_byte & 0x01) { if (!state_str.empty()) state_str += ", "; state_str += "Discharge"; }
                if (last_byte & 0x02) { if (!state_str.empty()) state_str += ", "; state_str += "Charge"; }
                if (last_byte & 0x04) { if (!state_str.empty()) state_str += ", "; state_str += "Float"; }
                if (last_byte & 0x08) { if (!state_str.empty()) state_str += ", "; state_str += "Full"; }
                if (last_byte & 0x10) { if (!state_str.empty()) state_str += ", "; state_str += "Standby"; }
                if (last_byte & 0x20) { if (!state_str.empty()) state_str += ", "; state_str += "Shutdown"; }
                id(batt_state)[batt] = state_str.empty() ? "Idle" : state_str;
              }
            }

            // Build per-battery warning/alarm strings
            std::string warn_str, alarm_str;
            for (const auto& w : batt_warnings_set) {
              if (!warn_str.empty()) warn_str += ",";
              warn_str += w;
            }
            for (const auto& a : batt_alarms_set) {
              if (!alarm_str.empty()) alarm_str += ",";
              alarm_str += a;
            }
            id(batt_warnings)[batt] = warn_str;
            id(batt_alarms)[batt] = alarm_str;
          }

          id(stack_balancing_count) = total_balancing;

          // Build stack balancing cells string (e.g., "B0C3,B1C7")
          std::string stack_bal_str;
          for (int b = 0; b < ${num_batteries}; b++) {
            const std::string& cells = id(batt_balancing_cells)[b];
            if (!cells.empty()) {
              // Split cells and add battery prefix
              size_t pos = 0;
              size_t comma_pos;
              std::string cell_list = cells;
              while ((comma_pos = cell_list.find(',', pos)) != std::string::npos) {
                std::string cell = cell_list.substr(pos, comma_pos - pos);
                if (!stack_bal_str.empty()) stack_bal_str += ",";
                stack_bal_str += "B" + std::to_string(b) + "C" + cell;
                pos = comma_pos + 1;
              }
              // Last cell (or only cell if no commas)
              std::string cell = cell_list.substr(pos);
              if (!cell.empty()) {
                if (!stack_bal_str.empty()) stack_bal_str += ",";
                stack_bal_str += "B" + std::to_string(b) + "C" + cell;
              }
            }
          }
          id(stack_balancing_cells) = stack_bal_str;

          // Stack overvolt tracking
          id(stack_overvolt_count) = total_overvolt;

          // Build stack overvolt cells string (e.g., "B0C3,B1C7")
          std::string stack_ov_str;
          for (int b = 0; b < ${num_batteries}; b++) {
            const std::string& cells = id(batt_overvolt_cells)[b];
            if (!cells.empty()) {
              size_t pos = 0;
              size_t comma_pos;
              std::string cell_list = cells;
              while ((comma_pos = cell_list.find(',', pos)) != std::string::npos) {
                std::string cell = cell_list.substr(pos, comma_pos - pos);
                if (!stack_ov_str.empty()) stack_ov_str += ",";
                stack_ov_str += "B" + std::to_string(b) + "C" + cell;
                pos = comma_pos + 1;
              }
              std::string cell = cell_list.substr(pos);
              if (!cell.empty()) {
                if (!stack_ov_str.empty()) stack_ov_str += ",";
                stack_ov_str += "B" + std::to_string(b) + "C" + cell;
              }
            }
          }
          id(stack_overvolt_cells) = stack_ov_str;

          // Build alarm string
          std::string alarm_str;
          for (const auto& a : all_alarms) {
            if (!alarm_str.empty()) alarm_str += ",";
            alarm_str += a;
          }
          id(stack_alarms) = alarm_str;

          if (total_balancing > 0) {
            ESP_LOGI("rs485", "Stack: %d cells balancing", total_balancing);
          }
          if (!alarm_str.empty()) {
            ESP_LOGW("rs485", "Alarms: %s", alarm_str.c_str());
          }

  # Publish RS485 data to MQTT - matches Python topic structure exactly
  - interval: 30s
    then:
      - lambda: |-
          char topic[80], payload[32];

          // Calculate stack totals
          float stack_cell_min = 99.0f, stack_cell_max = 0.0f;
          float stack_temp_min = 99.0f, stack_temp_max = -99.0f;
          float stack_voltage = 0.0f;
          float stack_current = 0.0f;
          int valid_batts = 0;

          for (int batt = 0; batt < ${num_batteries}; batt++) {
            float batt_min = 99.0f, batt_max = 0.0f;

            // Find cell min/max for this battery
            for (int cell = 0; cell < 16; cell++) {
              float v = id(cell_voltages)[batt * 16 + cell];
              if (v > 0.1f) {
                if (v < batt_min) batt_min = v;
                if (v > batt_max) batt_max = v;
                if (v < stack_cell_min) stack_cell_min = v;
                if (v > stack_cell_max) stack_cell_max = v;
              }
            }

            // Find temp min/max for this battery
            for (int t = 0; t < 6; t++) {
              float temp = id(cell_temps)[batt * 6 + t];
              if (temp > -40.0f && temp < 100.0f) {
                if (temp < stack_temp_min) stack_temp_min = temp;
                if (temp > stack_temp_max) stack_temp_max = temp;
              }
            }

            // Stack totals (parallel config: voltage avg, current sum)
            if (id(batt_voltage)[batt] > 0.1f) {
              stack_voltage += id(batt_voltage)[batt];
              valid_batts++;
            }
            stack_current += id(batt_current)[batt];

            // Publish per-battery data
            if (batt_min < 99.0f) {
              // Cell min/max/delta
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cell_min", batt);
              snprintf(payload, sizeof(payload), "%.3f", batt_min);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cell_max", batt);
              snprintf(payload, sizeof(payload), "%.3f", batt_max);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cell_delta_mv", batt);
              snprintf(payload, sizeof(payload), "%.1f", (batt_max - batt_min) * 1000.0f);
              id(mqtt_client).publish(topic, payload);

              // Voltage, current, SOC, cycles
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/voltage", batt);
              snprintf(payload, sizeof(payload), "%.2f", id(batt_voltage)[batt]);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/current", batt);
              snprintf(payload, sizeof(payload), "%.2f", id(batt_current)[batt]);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/soc", batt);
              snprintf(payload, sizeof(payload), "%.0f", id(batt_soc)[batt]);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/remain_ah", batt);
              snprintf(payload, sizeof(payload), "%.1f", id(batt_remain_ah)[batt]);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/total_ah", batt);
              snprintf(payload, sizeof(payload), "%.1f", id(batt_total_ah)[batt]);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cycles", batt);
              snprintf(payload, sizeof(payload), "%d", id(batt_cycles)[batt]);
              id(mqtt_client).publish(topic, payload);

              // Balancing
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/balancing_count", batt);
              snprintf(payload, sizeof(payload), "%d", id(batt_balancing_count)[batt]);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/balancing_active", batt);
              snprintf(payload, sizeof(payload), "%d", id(batt_balancing_count)[batt] > 0 ? 1 : 0);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/balancing_cells", batt);
              id(mqtt_client).publish(topic, id(batt_balancing_cells)[batt].c_str());

              // Overvolt
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/overvolt_count", batt);
              snprintf(payload, sizeof(payload), "%d", id(batt_overvolt_count)[batt]);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/overvolt_active", batt);
              snprintf(payload, sizeof(payload), "%d", id(batt_overvolt_count)[batt] > 0 ? 1 : 0);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/overvolt_cells", batt);
              id(mqtt_client).publish(topic, id(batt_overvolt_cells)[batt].c_str());

              // State, warnings, alarms
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/state", batt);
              id(mqtt_client).publish(topic, id(batt_state)[batt].c_str());

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/warnings", batt);
              id(mqtt_client).publish(topic, id(batt_warnings)[batt].c_str());

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/alarms", batt);
              id(mqtt_client).publish(topic, id(batt_alarms)[batt].c_str());

              // MOSFET status
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/charge_mosfet", batt);
              id(mqtt_client).publish(topic, id(batt_charge_mosfet)[batt] ? "1" : "0");

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/discharge_mosfet", batt);
              id(mqtt_client).publish(topic, id(batt_discharge_mosfet)[batt] ? "1" : "0");

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/lmcharge_mosfet", batt);
              id(mqtt_client).publish(topic, id(batt_lmcharge_mosfet)[batt] ? "1" : "0");

              // CW (Cell Warning) flag
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cw_active", batt);
              id(mqtt_client).publish(topic, id(batt_cw_active)[batt] ? "1" : "0");

              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cw_cells", batt);
              id(mqtt_client).publish(topic, id(batt_cw_cells)[batt].c_str());

              // Individual cell voltages
              for (int cell = 0; cell < 16; cell++) {
                float v = id(cell_voltages)[batt * 16 + cell];
                if (v > 0.1f) {
                  snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cell%02d", batt, cell + 1);
                  snprintf(payload, sizeof(payload), "%.3f", v);
                  id(mqtt_client).publish(topic, payload);
                }
              }

              // Temperature sensors
              for (int t = 0; t < 6; t++) {
                float temp = id(cell_temps)[batt * 6 + t];
                if (temp > -40.0f && temp < 100.0f) {
                  snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/temp%d", batt, t + 1);
                  snprintf(payload, sizeof(payload), "%.1f", temp);
                  id(mqtt_client).publish(topic, payload);
                }
              }
            }
          }

          // Publish stack totals
          if (stack_cell_min < 99.0f && valid_batts > 0) {
            stack_voltage /= valid_batts;  // Average for parallel config

            snprintf(payload, sizeof(payload), "%.3f", stack_cell_min);
            id(mqtt_client).publish("${rs485_prefix}/stack/cell_min", payload);
            snprintf(payload, sizeof(payload), "%.3f", stack_cell_max);
            id(mqtt_client).publish("${rs485_prefix}/stack/cell_max", payload);
            snprintf(payload, sizeof(payload), "%.1f", (stack_cell_max - stack_cell_min) * 1000.0f);
            id(mqtt_client).publish("${rs485_prefix}/stack/cell_delta_mv", payload);
            snprintf(payload, sizeof(payload), "%.2f", stack_voltage);
            id(mqtt_client).publish("${rs485_prefix}/stack/voltage", payload);
            snprintf(payload, sizeof(payload), "%.2f", stack_current);
            id(mqtt_client).publish("${rs485_prefix}/stack/current", payload);

            if (stack_temp_min < 99.0f) {
              snprintf(payload, sizeof(payload), "%.1f", stack_temp_min);
              id(mqtt_client).publish("${rs485_prefix}/stack/temp_min", payload);
              snprintf(payload, sizeof(payload), "%.1f", stack_temp_max);
              id(mqtt_client).publish("${rs485_prefix}/stack/temp_max", payload);
            }

            // Balancing
            snprintf(payload, sizeof(payload), "%d", id(stack_balancing_count));
            id(mqtt_client).publish("${rs485_prefix}/stack/balancing_count", payload);
            id(mqtt_client).publish("${rs485_prefix}/stack/balancing_active",
                id(stack_balancing_count) > 0 ? "1" : "0");
            id(mqtt_client).publish("${rs485_prefix}/stack/balancing_cells",
                id(stack_balancing_cells).c_str());

            // Overvolt
            snprintf(payload, sizeof(payload), "%d", id(stack_overvolt_count));
            id(mqtt_client).publish("${rs485_prefix}/stack/overvolt_count", payload);
            id(mqtt_client).publish("${rs485_prefix}/stack/overvolt_active",
                id(stack_overvolt_count) > 0 ? "1" : "0");
            id(mqtt_client).publish("${rs485_prefix}/stack/overvolt_cells",
                id(stack_overvolt_cells).c_str());

            // Alarms
            id(mqtt_client).publish("${rs485_prefix}/stack/alarms",
                id(stack_alarms).empty() ? "" : id(stack_alarms).c_str());
          }

          ESP_LOGI("mqtt", "Published RS485 data for %d batteries", ${num_batteries});

# CAN sensors - publish to topics matching Python script
sensor:
  - platform: template
    id: sensor_soc
    name: "BMS SOC"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery"
    state_topic: ${can_prefix}/soc

  - platform: template
    id: sensor_soh
    name: "BMS SOH"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery-heart"
    state_topic: ${can_prefix}/soh

  - platform: template
    id: sensor_v_charge_max
    name: "BMS Charge Voltage Max"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    state_topic: ${can_prefix}/limit/v_charge_max

  - platform: template
    id: sensor_v_low
    name: "BMS Low Voltage Limit"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    state_topic: ${can_prefix}/limit/v_low

  - platform: template
    id: sensor_i_charge
    name: "BMS Charge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    state_topic: ${can_prefix}/limit/i_charge

  - platform: template
    id: sensor_i_discharge
    name: "BMS Discharge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    state_topic: ${can_prefix}/limit/i_discharge

  - platform: template
    id: sensor_cell_v_min
    name: "Cell Min Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    state_topic: ${can_prefix}/ext/cell_v_min

  - platform: template
    id: sensor_cell_v_max
    name: "Cell Max Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    state_topic: ${can_prefix}/ext/cell_v_max

  - platform: template
    id: sensor_cell_v_delta
    name: "Cell Delta Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    icon: "mdi:chart-bell-curve-cumulative"
    state_topic: ${can_prefix}/ext/cell_v_delta

  - platform: template
    id: sensor_temp_min
    name: "Min Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    state_topic: ${can_prefix}/ext/temp_min

  - platform: template
    id: sensor_temp_max
    name: "Max Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    state_topic: ${can_prefix}/ext/temp_max

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: uptime
    name: "Uptime"

text_sensor:
  - platform: template
    id: sensor_flags
    name: "BMS Flags"
    icon: "mdi:flag"
    state_topic: ${can_prefix}/flags

  - platform: version
    name: "ESPHome Version"

binary_sensor:
  - platform: template
    name: "CAN Data Stale"
    lambda: 'return id(can_stale);'
    device_class: problem

button:
  - platform: restart
    name: "Restart"
