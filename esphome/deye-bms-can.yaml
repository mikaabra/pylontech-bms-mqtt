# ESPHome configuration for Waveshare ESP32-S3-RS485-CAN
# Replaces pylon_can2mqtt.py - CAN->MQTT bridge for Deye/Shoto BMS
# Also reads individual cell voltages via RS485
#
# Hardware: Waveshare ESP32-S3-RS485-CAN
# CAN pins: TX=GPIO15, RX=GPIO16 (500kbps Pylontech protocol)
# RS485 pins: TX=GPIO17, RX=GPIO18 (9600 baud Pylontech protocol)

substitutions:
  device_name: deye-bms-can
  friendly_name: "Deye BMS (CAN)"
  # Must match existing MQTT topics for seamless migration
  mqtt_prefix: deye_bms
  # Number of batteries in stack (0, 1, 2)
  num_batteries: "3"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  on_boot:
    priority: -100
    then:
      - logger.log: "CAN bus bridge starting..."

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO

# WiFi configuration - UPDATE THESE
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Optional: static IP for reliability
  # manual_ip:
  #   static_ip: 192.168.200.xxx
  #   gateway: 192.168.200.1
  #   subnet: 255.255.255.0

  ap:
    ssid: "${device_name}-fallback"
    password: "fallback123"

captive_portal:

# MQTT configuration - UPDATE THESE
mqtt:
  id: mqtt_client
  broker: !secret mqtt_host
  port: 1883
  username: !secret mqtt_user
  password: !secret mqtt_password

  # Birth/will messages for availability
  birth_message:
    topic: ${mqtt_prefix}/status
    payload: "online"
    retain: true
  will_message:
    topic: ${mqtt_prefix}/status
    payload: "offline"
    retain: true

  # Disable HA discovery via MQTT component (we do it manually for compatibility)
  discovery: false

# OTA updates
ota:
  - platform: esphome
    password: !secret ota_password

# Web server for debugging
web_server:
  port: 80

# UART for RS485 - Pylontech protocol at 9600 baud
# Pins may need adjustment based on actual board - check schematic
uart:
  id: rs485_uart
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 9600
  data_bits: 8
  stop_bits: 1
  parity: NONE

# CAN bus configuration for Waveshare ESP32-S3-RS485-CAN
canbus:
  - platform: esp32_can
    id: can_bus
    tx_pin: GPIO15
    rx_pin: GPIO16
    can_id: 0
    bit_rate: 500kbps

    # 0x351: Voltage/current limits
    on_frame:
      - can_id: 0x351
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; ESP_LOGI("can", "CAN data resumed"); }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              float v_charge_max = le_u16(x[0], x[1]) / 10.0f;
              float i_charge_lim = le_u16(x[2], x[3]) / 10.0f;
              float i_dis_lim = le_u16(x[4], x[5]) / 10.0f;
              float v_low_lim = le_u16(x[6], x[7]) / 10.0f;

              if (v_charge_max >= 30.0f && v_charge_max <= 65.0f &&
                  v_low_lim >= 30.0f && v_low_lim <= 65.0f &&
                  i_charge_lim >= 0.0f && i_charge_lim <= 500.0f &&
                  i_dis_lim >= 0.0f && i_dis_lim <= 500.0f) {
                id(sensor_v_charge_max).publish_state(v_charge_max);
                id(sensor_v_low).publish_state(v_low_lim);
                id(sensor_i_charge).publish_state(i_charge_lim);
                id(sensor_i_discharge).publish_state(i_dis_lim);
              }

      # 0x355: SOC/SOH
      - can_id: 0x355
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              uint16_t soc = le_u16(x[0], x[1]);
              uint16_t soh = le_u16(x[2], x[3]);

              if (soc <= 100 && soh <= 100) {
                id(sensor_soc).publish_state(soc);
                id(sensor_soh).publish_state(soh);
              }

      # 0x359: Flags
      - can_id: 0x359
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              uint64_t flags = 0;
              for (int i = 7; i >= 0; i--) {
                flags = (flags << 8) | x[i];
              }
              char buf[32];
              snprintf(buf, sizeof(buf), "0x%016llX", flags);
              id(sensor_flags).publish_state(buf);

      # 0x370: Temperature and cell voltage extremes
      - can_id: 0x370
        then:
          - lambda: |-
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) return;
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              float t1 = le_u16(x[0], x[1]) / 10.0f;
              float t2 = le_u16(x[2], x[3]) / 10.0f;
              float tmin = (t1 <= t2) ? t1 : t2;
              float tmax = (t1 > t2) ? t1 : t2;

              float v1 = le_u16(x[4], x[5]) / 1000.0f;
              float v2 = le_u16(x[6], x[7]) / 1000.0f;

              if (tmin >= -10.0f && tmax <= 50.0f) {
                id(sensor_temp_min).publish_state(tmin);
                id(sensor_temp_max).publish_state(tmax);
              }

              float vmin = 0, vmax = 0;
              bool v1_valid = (v1 >= 2.0f && v1 <= 4.5f);
              bool v2_valid = (v2 >= 2.0f && v2 <= 4.5f);

              if (v1_valid && v2_valid) {
                vmin = (v1 < v2) ? v1 : v2;
                vmax = (v1 > v2) ? v1 : v2;
              } else if (v1_valid) {
                vmin = vmax = v1;
              } else if (v2_valid) {
                vmin = vmax = v2;
              }

              if (vmin > 0) {
                id(sensor_cell_v_min).publish_state(vmin);
                id(sensor_cell_v_max).publish_state(vmax);
                id(sensor_cell_v_delta).publish_state(vmax - vmin);
              }

# Global variables for stale detection and RS485 data
globals:
  - id: last_can_rx
    type: uint32_t
    initial_value: '0'
  - id: can_stale
    type: bool
    initial_value: 'false'
  # RS485 polling state
  - id: rs485_poll_battery
    type: int
    initial_value: '0'
  - id: rs485_rx_buffer
    type: std::string
  # Cell voltages: 3 batteries x 16 cells = 48 cells
  - id: cell_voltages
    type: std::vector<float>
    restore_value: no
    initial_value: 'std::vector<float>(48, 0.0f)'
  # Battery stats
  - id: batt_soc
    type: std::vector<float>
    restore_value: no
    initial_value: 'std::vector<float>(3, 0.0f)'
  - id: batt_cycles
    type: std::vector<int>
    restore_value: no
    initial_value: 'std::vector<int>(3, 0)'

# Stale data detection and RS485 polling intervals
interval:
  - interval: 5s
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t elapsed = now - id(last_can_rx);
          // 30 second timeout
          if (elapsed > 30000 && !id(can_stale) && id(last_can_rx) > 0) {
            id(can_stale) = true;
            ESP_LOGW("can", "No CAN data for 30s, marking stale");
          }

  # RS485 polling - cycle through batteries every 10 seconds
  - interval: 10s
    then:
      - lambda: |-
          // Pylontech RS485 protocol functions
          auto calc_chksum = [](const std::string& frame) -> std::string {
            uint32_t total = 0;
            for (char c : frame) total += (uint8_t)c;
            uint16_t chk = (~total + 1) & 0xFFFF;
            char buf[5];
            snprintf(buf, sizeof(buf), "%04X", chk);
            return std::string(buf);
          };

          auto make_cmd = [&calc_chksum](int addr, int batt_num) -> std::string {
            char frame[32];
            // Build INFO field (battery number)
            char info[3];
            snprintf(info, sizeof(info), "%02X", batt_num);

            // Calculate LENID with LCHKSUM
            int info_len = 1;  // 1 byte = 2 hex chars / 2
            int lchksum = (~(0 + 0 + info_len) + 1) & 0xF;
            char lenid[5];
            snprintf(lenid, sizeof(lenid), "%X%03X", lchksum, info_len * 2);  // *2 for hex chars

            // Build frame content
            snprintf(frame, sizeof(frame), "20%02X4642%s%s", addr, lenid, info);

            std::string result = "~";
            result += frame;
            result += calc_chksum(frame);
            result += "\r";
            return result;
          };

          // Get current battery to poll
          int batt = id(rs485_poll_battery);
          int addr = 2;  // Pylontech master address

          // Build and send command
          std::string cmd = make_cmd(addr, batt);
          ESP_LOGD("rs485", "TX battery %d: %s", batt, cmd.c_str());

          // Send via UART
          for (char c : cmd) {
            id(rs485_uart).write_byte((uint8_t)c);
          }
          id(rs485_uart).flush();

          // Move to next battery
          id(rs485_poll_battery) = (batt + 1) % 3;

      # Wait for response
      - delay: 300ms
      - lambda: |-
          // Read response
          std::string response;
          while (id(rs485_uart).available()) {
            uint8_t c;
            id(rs485_uart).read_byte(&c);
            response += (char)c;
          }

          if (response.empty()) {
            ESP_LOGW("rs485", "No RS485 response");
            return;
          }

          ESP_LOGD("rs485", "RX: %s", response.c_str());

          // Parse response: ~VERADRCID1RTN LENID INFO CHKSUM\r
          // Minimum length check
          if (response.length() < 18) {
            ESP_LOGW("rs485", "Response too short");
            return;
          }

          // Check RTN code (bytes 7-8 after ~)
          if (response.length() > 9 && response.substr(7, 2) != "00") {
            ESP_LOGW("rs485", "RTN error: %s", response.substr(7, 2).c_str());
            return;
          }

          // Extract INFO data (after LENID at position 13, before checksum at -4)
          if (response.length() < 18) return;
          std::string data = response.substr(13, response.length() - 13 - 5);

          // Decode battery number from context (poll_battery was incremented, so subtract 1)
          int batt = (id(rs485_poll_battery) + 2) % 3;  // Previous battery

          // Parse analog data
          size_t i = 0;

          // Skip header (4 chars)
          if (data.length() < i + 4) return;
          i += 4;

          // Number of cells
          if (data.length() < i + 2) return;
          int num_cells = strtol(data.substr(i, 2).c_str(), nullptr, 16);
          i += 2;

          // Cell voltages
          for (int cell = 0; cell < num_cells && cell < 16; cell++) {
            if (data.length() < i + 4) break;
            int mv = strtol(data.substr(i, 4).c_str(), nullptr, 16);
            float v = mv / 1000.0f;
            id(cell_voltages)[batt * 16 + cell] = v;
            i += 4;
          }

          // Skip temperatures
          if (data.length() >= i + 2) {
            int num_temps = strtol(data.substr(i, 2).c_str(), nullptr, 16);
            i += 2 + num_temps * 4;
          }

          // Skip current (4 chars)
          i += 4;

          // Skip voltage (4 chars)
          i += 4;

          // Remaining capacity (10mAh units)
          float remain_ah = 0;
          if (data.length() >= i + 4) {
            remain_ah = strtol(data.substr(i, 4).c_str(), nullptr, 16) / 100.0f;
            i += 4;
          }

          // Skip custom byte
          i += 2;

          // Total capacity
          float total_ah = 0;
          if (data.length() >= i + 4) {
            total_ah = strtol(data.substr(i, 4).c_str(), nullptr, 16) / 100.0f;
            i += 4;
          }

          // Cycles
          if (data.length() >= i + 4) {
            id(batt_cycles)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16);
          }

          // Calculate SOC
          if (total_ah > 0) {
            id(batt_soc)[batt] = (remain_ah / total_ah) * 100.0f;
          }

          ESP_LOGI("rs485", "Battery %d: %d cells, SOC=%.0f%%, cycles=%d",
                   batt, num_cells, id(batt_soc)[batt], id(batt_cycles)[batt]);

  # Publish RS485 cell data to MQTT every 30 seconds
  - interval: 30s
    then:
      - lambda: |-
          // Find stack min/max cell voltages
          float stack_min = 99.0f, stack_max = 0.0f;

          for (int batt = 0; batt < 3; batt++) {
            float batt_min = 99.0f, batt_max = 0.0f;

            for (int cell = 0; cell < 16; cell++) {
              float v = id(cell_voltages)[batt * 16 + cell];
              if (v > 0.1f) {  // Valid reading
                if (v < batt_min) batt_min = v;
                if (v > batt_max) batt_max = v;
                if (v < stack_min) stack_min = v;
                if (v > stack_max) stack_max = v;
              }
            }

            // Publish per-battery data
            if (batt_min < 99.0f) {
              float delta = (batt_max - batt_min) * 1000.0f;
              char topic[64], payload[16];

              snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/battery%d/cell_min", batt);
              snprintf(payload, sizeof(payload), "%.3f", batt_min);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/battery%d/cell_max", batt);
              snprintf(payload, sizeof(payload), "%.3f", batt_max);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/battery%d/cell_delta_mv", batt);
              snprintf(payload, sizeof(payload), "%.0f", delta);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/battery%d/soc", batt);
              snprintf(payload, sizeof(payload), "%.0f", id(batt_soc)[batt]);
              id(mqtt_client).publish(topic, payload);

              snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/battery%d/cycles", batt);
              snprintf(payload, sizeof(payload), "%d", id(batt_cycles)[batt]);
              id(mqtt_client).publish(topic, payload);

              // Publish individual cell voltages
              for (int cell = 0; cell < 16; cell++) {
                float v = id(cell_voltages)[batt * 16 + cell];
                if (v > 0.1f) {
                  snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/battery%d/cell%02d", batt, cell + 1);
                  snprintf(payload, sizeof(payload), "%.3f", v);
                  id(mqtt_client).publish(topic, payload);
                }
              }
            }
          }

          // Publish stack totals
          if (stack_min < 99.0f) {
            char topic[64], payload[16];

            snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/cell_min");
            snprintf(payload, sizeof(payload), "%.3f", stack_min);
            id(mqtt_client).publish(topic, payload);

            snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/cell_max");
            snprintf(payload, sizeof(payload), "%.3f", stack_max);
            id(mqtt_client).publish(topic, payload);

            snprintf(topic, sizeof(topic), "${mqtt_prefix}/rs485/cell_delta_mv");
            snprintf(payload, sizeof(payload), "%.0f", (stack_max - stack_min) * 1000.0f);
            id(mqtt_client).publish(topic, payload);
          }

# Sensors - these publish to MQTT topics matching the Python script
sensor:
  # SOC/SOH
  - platform: template
    id: sensor_soc
    name: "BMS SOC"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery"
    state_topic: ${mqtt_prefix}/soc

  - platform: template
    id: sensor_soh
    name: "BMS SOH"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery-heart"
    state_topic: ${mqtt_prefix}/soh
    retain: true

  # Voltage/current limits
  - platform: template
    id: sensor_v_charge_max
    name: "BMS Charge Voltage Max"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/limit/v_charge_max
    retain: true

  - platform: template
    id: sensor_v_low
    name: "BMS Low Voltage Limit"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/limit/v_low
    retain: true

  - platform: template
    id: sensor_i_charge
    name: "BMS Charge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/limit/i_charge

  - platform: template
    id: sensor_i_discharge
    name: "BMS Discharge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/limit/i_discharge

  # Cell voltage extremes
  - platform: template
    id: sensor_cell_v_min
    name: "Cell Min Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    state_topic: ${mqtt_prefix}/ext/cell_v_min

  - platform: template
    id: sensor_cell_v_max
    name: "Cell Max Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    state_topic: ${mqtt_prefix}/ext/cell_v_max

  - platform: template
    id: sensor_cell_v_delta
    name: "Cell Delta Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    icon: "mdi:chart-bell-curve-cumulative"
    state_topic: ${mqtt_prefix}/ext/cell_v_delta

  # Temperature extremes
  - platform: template
    id: sensor_temp_min
    name: "Min Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/ext/temp_min

  - platform: template
    id: sensor_temp_max
    name: "Max Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    state_topic: ${mqtt_prefix}/ext/temp_max

  # WiFi signal strength for diagnostics
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  # Uptime for diagnostics
  - platform: uptime
    name: "Uptime"

text_sensor:
  # BMS Flags
  - platform: template
    id: sensor_flags
    name: "BMS Flags"
    icon: "mdi:flag"
    state_topic: ${mqtt_prefix}/flags

  # ESPHome version
  - platform: version
    name: "ESPHome Version"

# Binary sensor for CAN stale status
binary_sensor:
  - platform: template
    name: "CAN Data Stale"
    lambda: 'return id(can_stale);'
    device_class: problem

# Restart button
button:
  - platform: restart
    name: "Restart"
