# ESPHome configuration for Waveshare ESP32-S3-RS485-CAN
# Drop-in replacement for pylon_can2mqtt.py and pylon_rs485_monitor.py
#
# Hardware: Waveshare ESP32-S3-RS485-CAN
# CAN pins: TX=GPIO15, RX=GPIO16 (500kbps Pylontech protocol)
# RS485 pins: TX=GPIO17, RX=GPIO18, EN=GPIO21 (9600 baud Pylontech protocol)
#
# MQTT topics match Python scripts exactly for seamless migration.
# Run Python scripts once to publish HA discovery configs, then switch to ESP32.

substitutions:
  device_name: deye-bms-can
  friendly_name: "Deye BMS"
  # MQTT prefixes - must match Python scripts
  can_prefix: deye_bms
  rs485_prefix: deye_bms/rs485
  # Number of batteries in stack
  num_batteries: "3"
  # Pylontech RS485 address
  pylontech_addr: "2"



esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  includes:
    - includes/set_include.h
  on_boot:
    priority: -100
    then:
      - logger.log: "BMS bridge starting..."
      - lambda: |-
          // Ensure logger starts in WARN mode (minimal logging)
          id(logger_level_global).set_log_level(ESPHOME_LOG_LEVEL_WARN);
          id(logger_level) = "WARN";
          id(debug_level_sensor).publish_state("WARN");
      - lambda: |-
          // Initialize arrays based on num_batteries
          const int num_batt = ${num_batteries};
          id(cell_voltages).resize(16 * num_batt, 0.0f);  // 16 cells per battery
          id(cell_temps).resize(6 * num_batt, 0.0f);      // 6 temps per battery
          id(batt_current).resize(num_batt, 0.0f);
          id(batt_voltage).resize(num_batt, 0.0f);
          id(batt_soc).resize(num_batt, 0.0f);
          id(batt_remain_ah).resize(num_batt, 0.0f);
          id(batt_total_ah).resize(num_batt, 0.0f);
          id(batt_cycles).resize(num_batt, 0);
          id(batt_balancing_count).resize(num_batt, 0);
          id(batt_balancing_cells).resize(num_batt, std::string(""));
          id(batt_overvolt_count).resize(num_batt, 0);
          id(batt_overvolt_cells).resize(num_batt, std::string(""));
          id(batt_alarms).resize(num_batt, std::string(""));
          id(batt_warnings).resize(num_batt, std::string(""));
          id(batt_state).resize(num_batt, std::string(""));
          id(batt_charge_mosfet).resize(num_batt, false);
          id(batt_discharge_mosfet).resize(num_batt, false);
          id(batt_lmcharge_mosfet).resize(num_batt, false);
          id(batt_cw_active).resize(num_batt, false);
          id(batt_cw_cells).resize(num_batt, std::string(""));
          id(batt_poll_failures).resize(num_batt, 0);
          id(batt_poll_alarm).resize(num_batt, false);
          // Initialize temperature hysteresis tracking (6 temps per battery, use -999 as invalid)
          id(last_batt_temps).resize(6 * num_batt, -999.0f);
          
          // Initialize cell voltage hysteresis tracking (16 cells per battery, use -1 as invalid)
          id(last_cell_voltages).resize(16 * num_batt, -1.0f);
          
          // Initialize RS485 hysteresis tracking
          id(last_batt_voltages).resize(num_batt, -1.0f);
          id(last_batt_currents).resize(num_batt, -1.0f);
          id(last_batt_socs).resize(num_batt, -1.0f);
          id(last_batt_remain_ah).resize(num_batt, -1.0f);
          id(last_batt_total_ah).resize(num_batt, -1.0f);
          id(last_batt_states).resize(num_batt, "");
          id(last_batt_warnings).resize(num_batt, "");
          id(last_batt_alarms).resize(num_batt, "");
          id(last_batt_cycles).resize(num_batt, -1);
          id(last_batt_balancing_count).resize(num_batt, -1);
          id(last_batt_balancing_cells).resize(num_batt, "");
          id(last_batt_overvolt_count).resize(num_batt, -1);
          id(last_batt_overvolt_cells).resize(num_batt, "");
          id(last_batt_charge_mosfet).resize(num_batt, false);
          id(last_batt_discharge_mosfet).resize(num_batt, false);
          id(last_batt_lmcharge_mosfet).resize(num_batt, false);
          id(last_batt_cw_active).resize(num_batt, false);
          id(last_batt_cw_cells).resize(num_batt, "");
          id(last_batt_cell_min).resize(num_batt, -1.0f);
          id(last_batt_cell_max).resize(num_batt, -1.0f);
          id(last_batt_cell_delta).resize(num_batt, -1.0f);

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:
  level: WARN  # Start with minimal logging, but compile with DEBUG support
  id: logger_level_global

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "${device_name}-fallback"
    password: "fallback123"

captive_portal:

mqtt:
  id: mqtt_client
  broker: !secret mqtt_host
  port: 1883
  username: !secret mqtt_user
  password: !secret mqtt_password

  # CAN bridge availability
  birth_message:
    topic: ${can_prefix}/status
    payload: "online"
    retain: true
  will_message:
    topic: ${can_prefix}/status
    payload: "offline"
    retain: true

  # Disable native discovery - we use Python discovery configs for compatibility
  discovery: false

  on_connect:
    - lambda: |-
        // Publish RS485 availability
        id(mqtt_client).publish(std::string("${rs485_prefix}/status"), std::string("online"), (uint8_t)0, true);
        ESP_LOGI("mqtt", "Connected, published availability");
        
        // Publish initial state of CAN sensors on connect to ensure Home Assistant gets current values
        // This prevents "Unknown" state in HA when the device reconnects
        id(sensor_can_module_count).publish_state(id(can_module_count));
        id(sensor_can_status_byte7).publish_state(id(can_status_byte7));
        id(sensor_can_alarm_summary).publish_state(id(can_alarm_summary));
        id(sensor_can_frame_count).publish_state(id(can_frame_count));
        id(sensor_can_error_count).publish_state(id(can_error_count));
        
        // Update tracking variables to current values
        id(last_module_count) = id(can_module_count);
        id(last_status_byte7) = id(can_status_byte7);
        id(last_alarm_summary) = id(can_alarm_summary);
        
        // Publish initial cell voltages on connect (force republish to ensure HA has current values)
        // Reset tracking to force next publish
        for (int i = 0; i < id(last_cell_voltages).size(); i++) {
            id(last_cell_voltages)[i] = -1.0f;  // Reset to force publish on next update
        }
        
        // Reset RS485 tracking variables to force publish on next update
        id(last_stack_voltage) = -1.0f;
        id(last_stack_current) = -1.0f;
        id(last_stack_cell_min) = -1.0f;
        id(last_stack_cell_max) = -1.0f;
        id(last_stack_cell_delta) = -1.0f;
        
        for (int i = 0; i < ${num_batteries}; i++) {
            id(last_batt_voltages)[i] = -1.0f;
            id(last_batt_currents)[i] = -1.0f;
            id(last_batt_socs)[i] = -1.0f;
            id(last_batt_remain_ah)[i] = -1.0f;
            id(last_batt_total_ah)[i] = -1.0f;
            id(last_batt_states)[i] = "";
            id(last_batt_warnings)[i] = "";
            id(last_batt_alarms)[i] = "";
            id(last_batt_cycles)[i] = -1;
            id(last_batt_balancing_count)[i] = -1;
            id(last_batt_balancing_cells)[i] = "";
            id(last_batt_overvolt_count)[i] = -1;
            id(last_batt_overvolt_cells)[i] = "";
            id(last_batt_charge_mosfet)[i] = false;
            id(last_batt_discharge_mosfet)[i] = false;
            id(last_batt_lmcharge_mosfet)[i] = false;
            id(last_batt_cw_active)[i] = false;
            id(last_batt_cw_cells)[i] = "";
            id(last_batt_cell_min)[i] = -1.0f;
            id(last_batt_cell_max)[i] = -1.0f;
            id(last_batt_cell_delta)[i] = -1.0f;
        }

        // Publish HA Discovery configs
        // Device info shared by all entities
        const char* device_json = R"("device":{"identifiers":["pylontech_rs485"],"name":"Pylontech RS485","manufacturer":"Pylontech","model":"BMS RS485"})";
        const char* avail_json = R"("availability_topic":"${rs485_prefix}/status","payload_available":"online","payload_not_available":"offline")";

        char topic[128];
        char payload[512];

        // Stack sensors
        const char* stack_sensors[][5] = {
          {"stack_cell_min", "Stack Cell Min", "${rs485_prefix}/stack/cell_min", "V", "voltage"},
          {"stack_cell_max", "Stack Cell Max", "${rs485_prefix}/stack/cell_max", "V", "voltage"},
          {"stack_cell_delta", "Stack Cell Delta", "${rs485_prefix}/stack/cell_delta_mv", "mV", ""},
          {"stack_voltage", "Stack Voltage", "${rs485_prefix}/stack/voltage", "V", "voltage"},
          {"stack_current", "Stack Current", "${rs485_prefix}/stack/current", "A", "current"},
          {"stack_temp_min", "Stack Temp Min", "${rs485_prefix}/stack/temp_min", "°C", "temperature"},
          {"stack_temp_max", "Stack Temp Max", "${rs485_prefix}/stack/temp_max", "°C", "temperature"},
          {"stack_balancing_count", "Stack Balancing Cells", "${rs485_prefix}/stack/balancing_count", "", ""},
          {"stack_balancing_cells", "Stack Balancing Cells List", "${rs485_prefix}/stack/balancing_cells", "", ""},
          {"stack_overvolt_count", "Stack Overvolt Cells", "${rs485_prefix}/stack/overvolt_count", "", ""},
          {"stack_overvolt_cells", "Stack Overvolt Cells List", "${rs485_prefix}/stack/overvolt_cells", "", ""},
          {"stack_alarms", "Stack Alarms", "${rs485_prefix}/stack/alarms", "", ""},
        };

        for (int i = 0; i < 12; i++) {
          snprintf(topic, sizeof(topic), "homeassistant/sensor/pylontech_rs485/%s/config", stack_sensors[i][0]);
          if (strlen(stack_sensors[i][3]) > 0 && strlen(stack_sensors[i][4]) > 0) {
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"%s","device_class":"%s","state_class":"measurement",%s,%s})",
              stack_sensors[i][1], stack_sensors[i][2], stack_sensors[i][0], stack_sensors[i][3], stack_sensors[i][4], avail_json, device_json);
          } else if (strlen(stack_sensors[i][3]) > 0) {
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"%s","state_class":"measurement",%s,%s})",
              stack_sensors[i][1], stack_sensors[i][2], stack_sensors[i][0], stack_sensors[i][3], avail_json, device_json);
          } else {
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s",%s,%s})",
              stack_sensors[i][1], stack_sensors[i][2], stack_sensors[i][0], avail_json, device_json);
          }
          id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
        }

        // Stack binary sensors
        snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/pylontech_rs485/stack_balancing_active/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"Stack Balancing Active","state_topic":"${rs485_prefix}/stack/balancing_active","unique_id":"pylontech_rs485_stack_balancing_active","payload_on":"1","payload_off":"0","icon":"mdi:scale-balance",%s,%s})",
          avail_json, device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/pylontech_rs485/stack_overvolt_active/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"Stack Overvolt Active","state_topic":"${rs485_prefix}/stack/overvolt_active","unique_id":"pylontech_rs485_stack_overvolt_active","payload_on":"1","payload_off":"0","icon":"mdi:flash-alert",%s,%s})",
          avail_json, device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        // Per-battery discovery
        for (int batt = 0; batt < ${num_batteries}; batt++) {
          char prefix[16], state_prefix[48];
          snprintf(prefix, sizeof(prefix), "batt%d", batt);
          snprintf(state_prefix, sizeof(state_prefix), "${rs485_prefix}/battery%d", batt);

          // Battery sensors
          const char* batt_sensor_names[][4] = {
            {"cell_min", "Cell Min", "V", "voltage"},
            {"cell_max", "Cell Max", "V", "voltage"},
            {"cell_delta", "Cell Delta", "mV", ""},
            {"voltage", "Voltage", "V", "voltage"},
            {"current", "Current", "A", "current"},
            {"soc", "SOC", "%", ""},
            {"remain_ah", "Remaining Capacity", "Ah", ""},
            {"total_ah", "Total Capacity", "Ah", ""},
            {"cycles", "Cycles", "", ""},
            {"balancing_count", "Balancing Cells", "", ""},
            {"balancing_cells", "Balancing Cells List", "", ""},
            {"overvolt_count", "Overvolt Cells", "", ""},
            {"overvolt_cells", "Overvolt Cells List", "", ""},
            {"state", "State", "", ""},
            {"warnings", "Warnings", "", ""},
            {"alarms", "Alarms", "", ""},
            {"cw_cells", "CW Cells List", "", ""},
          };

          for (int i = 0; i < 17; i++) {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_%s", prefix, batt_sensor_names[i][0]);
            snprintf(name, sizeof(name), "Battery %d %s", batt, batt_sensor_names[i][1]);
            snprintf(st, sizeof(st), "%s/%s", state_prefix, batt_sensor_names[i][0]);
            // Fix topic names for cell_delta
            if (strcmp(batt_sensor_names[i][0], "cell_delta") == 0) {
              snprintf(st, sizeof(st), "%s/cell_delta_mv", state_prefix);
            }

            snprintf(topic, sizeof(topic), "homeassistant/sensor/pylontech_rs485/%s/config", obj_id);
            if (strlen(batt_sensor_names[i][2]) > 0 && strlen(batt_sensor_names[i][3]) > 0) {
              snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"%s","device_class":"%s","state_class":"measurement",%s,%s})",
                name, st, obj_id, batt_sensor_names[i][2], batt_sensor_names[i][3], avail_json, device_json);
            } else if (strlen(batt_sensor_names[i][2]) > 0) {
              snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"%s","state_class":"measurement",%s,%s})",
                name, st, obj_id, batt_sensor_names[i][2], avail_json, device_json);
            } else {
              snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s",%s,%s})",
                name, st, obj_id, avail_json, device_json);
            }
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }

          // Battery binary sensors
          const char* batt_binary_names[][2] = {
            {"balancing_active", "Balancing Active"},
            {"overvolt_active", "Overvolt Active"},
            {"charge_mosfet", "Charge MOSFET"},
            {"discharge_mosfet", "Discharge MOSFET"},
            {"lmcharge_mosfet", "LM Charge MOSFET"},
            {"cw_active", "Cell Warning"},
          };

          for (int i = 0; i < 6; i++) {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_%s", prefix, batt_binary_names[i][0]);
            snprintf(name, sizeof(name), "Battery %d %s", batt, batt_binary_names[i][1]);
            snprintf(st, sizeof(st), "%s/%s", state_prefix, batt_binary_names[i][0]);

            snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/pylontech_rs485/%s/config", obj_id);
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","payload_on":"1","payload_off":"0",%s,%s})",
              name, st, obj_id, avail_json, device_json);
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }

          // Individual cell voltages
          for (int cell = 1; cell <= 16; cell++) {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_cell%02d", prefix, cell);
            snprintf(name, sizeof(name), "Battery %d Cell %d", batt, cell);
            snprintf(st, sizeof(st), "%s/cell%02d", state_prefix, cell);

            snprintf(topic, sizeof(topic), "homeassistant/sensor/pylontech_rs485/%s/config", obj_id);
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"V","device_class":"voltage","state_class":"measurement","suggested_display_precision":3,%s,%s})",
              name, st, obj_id, avail_json, device_json);
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }

          // Temperature sensors
          for (int temp = 1; temp <= 6; temp++) {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_temp%d", prefix, temp);
            snprintf(name, sizeof(name), "Battery %d Temp %d", batt, temp);
            snprintf(st, sizeof(st), "%s/temp%d", state_prefix, temp);

            snprintf(topic, sizeof(topic), "homeassistant/sensor/pylontech_rs485/%s/config", obj_id);
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","unit_of_measurement":"°C","device_class":"temperature","state_class":"measurement",%s,%s})",
              name, st, obj_id, avail_json, device_json);
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }

          // Poll alarm binary sensor (RS485 communication failure detection)
          {
            char obj_id[32], name[48], st[64];
            snprintf(obj_id, sizeof(obj_id), "%s_poll_alarm", prefix);
            snprintf(name, sizeof(name), "Battery %d Poll Alarm", batt);
            snprintf(st, sizeof(st), "%s/poll_alarm", state_prefix);

            snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/pylontech_rs485/%s/config", obj_id);
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"pylontech_rs485_%s","device_class":"problem","payload_on":"ON","payload_off":"OFF","icon":"mdi:lan-disconnect",%s,%s})",
              name, st, obj_id, avail_json, device_json);
            id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
          }
        }

        ESP_LOGI("mqtt", "Published HA discovery configs for %d batteries", ${num_batteries});

        // CAN bus device - separate from RS485 batteries
        const char* can_device_json = R"("device":{"identifiers":["deye_bms_can"],"name":"Deye BMS CAN","manufacturer":"Pylontech","model":"BMS CAN"})";
        const char* can_avail_json = R"("availability_topic":"${can_prefix}/status","payload_available":"online","payload_not_available":"offline")";

        // CAN binary sensors (charge/discharge control from 0x35C)
        snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/deye_bms/can_charge_enabled/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"CAN Charge Enabled","state_topic":"${can_prefix}/can/charge_enabled","unique_id":"deye_bms_can_charge_enabled","payload_on":"1","payload_off":"0","icon":"mdi:battery-charging",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/deye_bms/can_discharge_enabled/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"CAN Discharge Enabled","state_topic":"${can_prefix}/can/discharge_enabled","unique_id":"deye_bms_can_discharge_enabled","payload_on":"1","payload_off":"0","icon":"mdi:battery-minus",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/deye_bms/can_force_charge/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"CAN Force Charge Request","state_topic":"${can_prefix}/can/force_charge","unique_id":"deye_bms_can_force_charge","payload_on":"1","payload_off":"0","icon":"mdi:battery-alert",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        // CAN diagnostic sensors
        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_frame_count/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"CAN Frame Count","state_topic":"${can_prefix}/diag/frame_count","unique_id":"deye_bms_can_frame_count","icon":"mdi:counter","entity_category":"diagnostic",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_error_count/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"CAN Error Count","state_topic":"${can_prefix}/diag/error_count","unique_id":"deye_bms_can_error_count","icon":"mdi:alert-circle","entity_category":"diagnostic",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        // CAN 0x359 module count and status sensors
        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_module_count/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"CAN Module Count","state_topic":"${can_prefix}/can/module_count","unique_id":"deye_bms_can_module_count","icon":"mdi:battery-multiple",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_status_byte7/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"CAN Status Byte 7","state_topic":"${can_prefix}/can/status_byte7","unique_id":"deye_bms_can_status_byte7","icon":"mdi:information-outline","entity_category":"diagnostic",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        // CAN alarm summary text sensor
        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_alarm_summary/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"CAN Alarm Summary","state_topic":"${can_prefix}/can/alarm_summary","unique_id":"deye_bms_can_alarm_summary","icon":"mdi:alert",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        // CAN 0x359 protection binary sensors (device_class: problem)
        const char* prot_sensors[][3] = {
          {"prot_overvolt", "CAN Protection Overvolt", "mdi:flash-alert"},
          {"prot_undervolt", "CAN Protection Undervolt", "mdi:flash-off"},
          {"prot_overtemp", "CAN Protection Overtemp", "mdi:thermometer-alert"},
          {"prot_undertemp", "CAN Protection Undertemp", "mdi:snowflake-alert"},
          {"prot_discharge_overcurrent", "CAN Protection Discharge OC", "mdi:current-dc"},
          {"prot_charge_overcurrent", "CAN Protection Charge OC", "mdi:current-dc"},
          {"prot_system_error", "CAN Protection System Error", "mdi:alert-circle"},
        };
        for (int i = 0; i < 7; i++) {
          snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/deye_bms/can_%s/config", prot_sensors[i][0]);
          snprintf(payload, sizeof(payload),
            R"({"name":"%s","state_topic":"${can_prefix}/can/%s","unique_id":"deye_bms_can_%s","device_class":"problem","payload_on":"1","payload_off":"0","icon":"%s",%s,%s})",
            prot_sensors[i][1], prot_sensors[i][0], prot_sensors[i][0], prot_sensors[i][2], can_avail_json, can_device_json);
          id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
        }

        // CAN 0x359 warning binary sensors
        const char* warn_sensors[][3] = {
          {"warn_high_voltage", "CAN Warning High Voltage", "mdi:flash"},
          {"warn_low_voltage", "CAN Warning Low Voltage", "mdi:flash-outline"},
          {"warn_high_temp", "CAN Warning High Temp", "mdi:thermometer-high"},
          {"warn_low_temp", "CAN Warning Low Temp", "mdi:thermometer-low"},
          {"warn_high_discharge_current", "CAN Warning High Discharge", "mdi:current-dc"},
          {"warn_high_charge_current", "CAN Warning High Charge", "mdi:current-dc"},
          {"warn_comms_fail", "CAN Warning Comms Fail", "mdi:lan-disconnect"},
        };
        for (int i = 0; i < 7; i++) {
          snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/deye_bms/can_%s/config", warn_sensors[i][0]);
          // warn_comms_fail gets device_class: problem, others don't
          if (i == 6) {
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"${can_prefix}/can/%s","unique_id":"deye_bms_can_%s","device_class":"problem","payload_on":"1","payload_off":"0","icon":"%s",%s,%s})",
              warn_sensors[i][1], warn_sensors[i][0], warn_sensors[i][0], warn_sensors[i][2], can_avail_json, can_device_json);
          } else {
            snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"${can_prefix}/can/%s","unique_id":"deye_bms_can_%s","payload_on":"1","payload_off":"0","icon":"%s",%s,%s})",
              warn_sensors[i][1], warn_sensors[i][0], warn_sensors[i][0], warn_sensors[i][2], can_avail_json, can_device_json);
          }
          id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
        }

        // CAN main sensors (SOC, SOH, limits, extremes)
        // SOC and SOH
        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_soc/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"BMS SOC","state_topic":"${can_prefix}/soc","unique_id":"deye_bms_can_soc","unit_of_measurement":"%%","device_class":"battery","state_class":"measurement",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_soh/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"BMS SOH","state_topic":"${can_prefix}/soh","unique_id":"deye_bms_can_soh","unit_of_measurement":"%%","icon":"mdi:battery-heart-variant","state_class":"measurement",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        // Charge/discharge limits
        const char* limit_sensors[][4] = {
          {"v_charge_max", "BMS Charge Voltage Max", "V", "voltage"},
          {"v_low", "BMS Discharge Voltage Min", "V", "voltage"},
          {"i_charge", "BMS Charge Current Limit", "A", "current"},
          {"i_discharge", "BMS Discharge Current Limit", "A", "current"},
        };
        for (int i = 0; i < 4; i++) {
          snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_%s/config", limit_sensors[i][0]);
          snprintf(payload, sizeof(payload),
            R"({"name":"%s","state_topic":"${can_prefix}/limit/%s","unique_id":"deye_bms_can_%s","unit_of_measurement":"%s","device_class":"%s","state_class":"measurement",%s,%s})",
            limit_sensors[i][1], limit_sensors[i][0], limit_sensors[i][0], limit_sensors[i][2], limit_sensors[i][3], can_avail_json, can_device_json);
          id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
        }

        // Cell voltage and temperature extremes
        const char* ext_sensors[][4] = {
          {"cell_v_min", "BMS Cell Voltage Min", "V", "voltage"},
          {"cell_v_max", "BMS Cell Voltage Max", "V", "voltage"},
          {"cell_v_delta", "BMS Cell Voltage Delta", "V", "voltage"},
          {"temp_min", "BMS Temperature Min", "°C", "temperature"},
          {"temp_max", "BMS Temperature Max", "°C", "temperature"},
        };
        for (int i = 0; i < 5; i++) {
          snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_%s/config", ext_sensors[i][0]);
          snprintf(payload, sizeof(payload),
            R"({"name":"%s","state_topic":"${can_prefix}/ext/%s","unique_id":"deye_bms_can_%s","unit_of_measurement":"%s","device_class":"%s","state_class":"measurement",%s,%s})",
            ext_sensors[i][1], ext_sensors[i][0], ext_sensors[i][0], ext_sensors[i][2], ext_sensors[i][3], can_avail_json, can_device_json);
          id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);
        }

        // Raw flags text sensor
        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_flags/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"BMS Flags Raw","state_topic":"${can_prefix}/flags","unique_id":"deye_bms_can_flags","icon":"mdi:flag","entity_category":"diagnostic",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        // Free heap diagnostic
        snprintf(topic, sizeof(topic), "homeassistant/sensor/deye_bms/can_free_heap/config");
        snprintf(payload, sizeof(payload),
          R"({"name":"ESP Free Heap","state_topic":"${can_prefix}/diag/free_heap","unique_id":"deye_bms_can_free_heap","unit_of_measurement":"bytes","icon":"mdi:memory","entity_category":"diagnostic",%s,%s})",
          can_avail_json, can_device_json);
        id(mqtt_client).publish(std::string(topic), std::string(payload), (uint8_t)0, true);

        ESP_LOGI("mqtt", "Published HA discovery configs for CAN sensors");

ota:
  - platform: esphome
    password: !secret ota_password

web_server:
  port: 80

# UART for RS485
uart:
  id: rs485_uart
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: 9600
  data_bits: 8
  stop_bits: 1
  parity: NONE
  # Hardware RS485 half-duplex direction control
  flow_control_pin: GPIO21

  rx_buffer_size: 1024
# RS485 direction control now handled by UART flow_control_pin

# CAN bus configuration (listen-only mode - no ACKs sent)
canbus:
  - platform: esp32_can
    id: can_bus
    tx_pin: GPIO15
    rx_pin: GPIO16
    can_id: 0
    bit_rate: 500kbps
    mode: LISTENONLY

    on_frame:
      # 0x351: Voltage/current limits
      - can_id: 0x351
        then:
          - lambda: |-
              if (!can_frame_preamble(x, id(can_frame_count), id(last_can_rx), id(can_stale), id(can_error_count))) {
                return;
              }
              can_track_frame(0x351, true);
              
              // Check for recovery from stale state
              can_handle_stale_recovery(id(can_stale), id(mqtt_client), "${can_prefix}");

              float v_charge_max = can_le_u16(x[0], x[1]) / 10.0f;
              float i_charge_lim = can_le_u16(x[2], x[3]) / 10.0f;
              float i_dis_lim = can_le_u16(x[4], x[5]) / 10.0f;
              float v_low_lim = can_le_u16(x[6], x[7]) / 10.0f;

              // Sanity checks
              if (v_charge_max >= 30.0f && v_charge_max <= 65.0f &&
                  v_low_lim >= 30.0f && v_low_lim <= 65.0f &&
                  i_charge_lim >= 0.0f && i_charge_lim <= 500.0f &&
                  i_dis_lim >= 0.0f && i_dis_lim <= 500.0f) {
                id(sensor_v_charge_max).publish_state(v_charge_max);
                id(sensor_v_low).publish_state(v_low_lim);
                id(sensor_i_charge).publish_state(i_charge_lim);
                id(sensor_i_discharge).publish_state(i_dis_lim);
              }

      # 0x355: SOC/SOH
      - can_id: 0x355
        then:
          - lambda: |-
              if (!can_frame_preamble(x, id(can_frame_count), id(last_can_rx), id(can_stale), id(can_error_count))) {
                return;
              }
              can_track_frame(0x355, true);
              
              // Check for recovery from stale state
              can_handle_stale_recovery(id(can_stale), id(mqtt_client), "${can_prefix}");

              uint16_t soc = can_le_u16(x[0], x[1]);
              uint16_t soh = can_le_u16(x[2], x[3]);

              if (soc <= 100 && soh <= 100) {
                id(sensor_soc).publish_state(soc);
                id(sensor_soh).publish_state(soh);
              }

      # 0x359: Protection & Alarm Flags (Pylontech V1.2)
      # Byte 0: Protection - bit7=discharge_overcurrent, bit4=undertemp, bit3=overtemp, bit2=undervolt, bit1=overvolt
      # Byte 1: Protection - bit7=system_error, bit0=charge_overcurrent
      # Byte 2: Warning - bit7=high_discharge_current, bit4=low_temp, bit3=high_temp, bit2=low_volt, bit1=high_volt
      # Byte 3: Warning - bit7=comms_fail, bit0=high_charge_current
      # Byte 4: Module count
      # Byte 7: Additional status (Shoto-specific)
      - can_id: 0x359
        then:
          - lambda: |-
              if (!can_frame_preamble(x, id(can_frame_count), id(last_can_rx), id(can_stale), id(can_error_count))) {
                return;
              }
              can_track_frame(0x359, true);

              // Check for recovery from stale state
              can_handle_stale_recovery(id(can_stale), id(mqtt_client), "${can_prefix}");

              uint64_t flags = 0;
              for (int i = 7; i >= 0; i--) {
                flags = (flags << 8) | x[i];
              }

              // Decode protection flags (byte 0)
              uint8_t prot0 = x[0];
              id(can_prot_overvolt) = (prot0 & 0x02) != 0;           // bit 1
              id(can_prot_undervolt) = (prot0 & 0x04) != 0;          // bit 2
              id(can_prot_overtemp) = (prot0 & 0x08) != 0;           // bit 3
              id(can_prot_undertemp) = (prot0 & 0x10) != 0;          // bit 4
              id(can_prot_discharge_overcurrent) = (prot0 & 0x80) != 0;  // bit 7

              // Decode protection flags (byte 1)
              uint8_t prot1 = x[1];
              id(can_prot_charge_overcurrent) = (prot1 & 0x01) != 0; // bit 0
              id(can_prot_system_error) = (prot1 & 0x80) != 0;       // bit 7

              // Decode warning flags (byte 2)
              uint8_t warn2 = x[2];
              id(can_warn_high_voltage) = (warn2 & 0x02) != 0;       // bit 1
              id(can_warn_low_voltage) = (warn2 & 0x04) != 0;        // bit 2
              id(can_warn_high_temp) = (warn2 & 0x08) != 0;          // bit 3
              id(can_warn_low_temp) = (warn2 & 0x10) != 0;           // bit 4
              id(can_warn_high_discharge_current) = (warn2 & 0x80) != 0;  // bit 7

              // Decode warning flags (byte 3)
              uint8_t warn3 = x[3];
              id(can_warn_high_charge_current) = (warn3 & 0x01) != 0;  // bit 0
              id(can_warn_comms_fail) = (warn3 & 0x80) != 0;           // bit 7

              // Module count (byte 4) and status byte (byte 7)
              id(can_module_count) = x[4];
              id(can_status_byte7) = x[7];

              // Log if any protection or warning is active
              if (prot0 || prot1) {
                ESP_LOGW("can", "0x359 PROTECTION: byte0=0x%02X byte1=0x%02X", prot0, prot1);
              }
              if (warn2 || warn3) {
                ESP_LOGI("can", "0x359 WARNING: byte2=0x%02X byte3=0x%02X", warn2, warn3);
              }

              // Hysteresis: only publish if flags changed OR 60s passed
              uint32_t now = millis();
              bool changed = (flags != id(last_flags_value));
              bool heartbeat = (now - id(last_flags_publish) >= 60000);

              if (changed || heartbeat) {
                char buf[32];
                snprintf(buf, sizeof(buf), "0x%016llX", flags);
                id(sensor_flags).publish_state(buf);
                id(last_flags_value) = flags;
                id(last_flags_publish) = now;

                // Log module count changes
                ESP_LOGI("can", "0x359: modules=%d status_b7=0x%02X flags=%s",
                         x[4], x[7], buf);
              }

      # 0x370: Temperature and cell voltage extremes
      - can_id: 0x370
        then:
          - lambda: |-
              if (!can_frame_preamble(x, id(can_frame_count), id(last_can_rx), id(can_stale), id(can_error_count))) {
                return;
              }
              can_track_frame(0x370, true);
              
              // Check for recovery from stale state
              can_handle_stale_recovery(id(can_stale), id(mqtt_client), "${can_prefix}");

              float t1 = can_le_u16(x[0], x[1]) / 10.0f;
              float t2 = can_le_u16(x[2], x[3]) / 10.0f;
              float tmin = (t1 <= t2) ? t1 : t2;
              float tmax = (t1 > t2) ? t1 : t2;

              float v1 = can_le_u16(x[4], x[5]) / 1000.0f;
              float v2 = can_le_u16(x[6], x[7]) / 1000.0f;

              if (tmin >= -10.0f && tmax <= 50.0f) {
                id(sensor_temp_min).publish_state(tmin);
                id(sensor_temp_max).publish_state(tmax);
              }

              float vmin = 0, vmax = 0;
              bool v1_valid = (v1 >= 2.0f && v1 <= 4.5f);
              bool v2_valid = (v2 >= 2.0f && v2 <= 4.5f);

              if (v1_valid && v2_valid) {
                vmin = (v1 < v2) ? v1 : v2;
                vmax = (v1 > v2) ? v1 : v2;
              } else if (v1_valid) {
                vmin = vmax = v1;
              } else if (v2_valid) {
                vmin = vmax = v2;
              }

              if (vmin > 0) {
                id(sensor_cell_v_min).publish_state(vmin);
                id(sensor_cell_v_max).publish_state(vmax);
                id(sensor_cell_v_delta).publish_state(vmax - vmin);
              }

      # 0x35C: Battery Charge Request Flags (V1.2)
      # Bit 7 (0x80): Charge Enable (RCE)
      # Bit 6 (0x40): Discharge Enable (RDE)
      # Bit 5 (0x20): Force Charge Level 1
      - can_id: 0x35C
        then:
          - lambda: |-
              if (!can_frame_preamble(x, id(can_frame_count), id(last_can_rx), id(can_stale), id(can_error_count), 8)) {
                return;
              }
              can_track_frame(0x35C, true);
              
              // Check for recovery from stale state
              can_handle_stale_recovery(id(can_stale), id(mqtt_client), "${can_prefix}");

              uint8_t flags = x[0];

              // Correct bit mapping per Pylontech CAN V1.2 spec
              bool charge_en = (flags & 0x80) != 0;
              bool discharge_en = (flags & 0x40) != 0;
              bool force_chg = (flags & 0x20) != 0;

              bool changed = (charge_en != id(can_charge_enabled)) ||
                             (discharge_en != id(can_discharge_enabled)) ||
                             (force_chg != id(can_force_charge_request));

              if (changed) {
                id(can_charge_enabled) = charge_en;
                id(can_discharge_enabled) = discharge_en;
                id(can_force_charge_request) = force_chg;
                ESP_LOGI("can", "0x35C: Charge=%s Discharge=%s ForceChg=%s (0x%02X)",
                         charge_en ? "EN" : "DIS", discharge_en ? "EN" : "DIS",
                         force_chg ? "YES" : "NO", flags);
              }

# Global variables
globals:
  # Logger level tracking
  - id: logger_level
    type: std::string
    initial_value: '"WARN"'  # Default to minimal logging

  # CAN sensor hysteresis tracking - prevent excessive MQTT updates
  - id: last_module_count
    type: int
    initial_value: '-1'
  - id: last_status_byte7
    type: int
    initial_value: '-1'
  - id: last_alarm_summary
    type: std::string
    initial_value: '""'

  # Cell voltage hysteresis tracking - prevent excessive MQTT updates
  - id: last_cell_voltages
    type: std::vector<float>
    restore_value: no

  # RS485 hysteresis tracking - prevent excessive MQTT updates
  - id: last_stack_voltage
    type: float
    initial_value: '-1.0'
  - id: last_stack_current
    type: float
    initial_value: '-1.0'
  - id: last_stack_cell_min
    type: float
    initial_value: '-1.0'
  - id: last_stack_cell_max
    type: float
    initial_value: '-1.0'
  - id: last_stack_cell_delta
    type: float
    initial_value: '-1.0'
  - id: last_batt_voltages
    type: std::vector<float>
    restore_value: no
  - id: last_batt_currents
    type: std::vector<float>
    restore_value: no
  - id: last_batt_socs
    type: std::vector<float>
    restore_value: no
  - id: last_batt_remain_ah
    type: std::vector<float>
    restore_value: no
  - id: last_batt_total_ah
    type: std::vector<float>
    restore_value: no
  - id: last_batt_states
    type: std::vector<std::string>
    restore_value: no
  - id: last_batt_warnings
    type: std::vector<std::string>
    restore_value: no
  - id: last_batt_alarms
    type: std::vector<std::string>
    restore_value: no
  - id: last_batt_cycles
    type: std::vector<int>
    restore_value: no
  - id: last_batt_balancing_count
    type: std::vector<int>
    restore_value: no
  - id: last_batt_balancing_cells
    type: std::vector<std::string>
    restore_value: no
  - id: last_batt_overvolt_count
    type: std::vector<int>
    restore_value: no
  - id: last_batt_overvolt_cells
    type: std::vector<std::string>
    restore_value: no
  - id: last_batt_charge_mosfet
    type: std::vector<bool>
    restore_value: no
  - id: last_batt_discharge_mosfet
    type: std::vector<bool>
    restore_value: no
  - id: last_batt_lmcharge_mosfet
    type: std::vector<bool>
    restore_value: no
  - id: last_batt_cw_active
    type: std::vector<bool>
    restore_value: no
  - id: last_batt_cw_cells
    type: std::vector<std::string>
    restore_value: no
  - id: last_batt_cell_min
    type: std::vector<float>
    restore_value: no
  - id: last_batt_cell_max
    type: std::vector<float>
    restore_value: no
  - id: last_batt_cell_delta
    type: std::vector<float>
    restore_value: no

  # CAN stale detection
  - id: last_can_rx
    type: uint32_t
    initial_value: '0'
  - id: can_stale
    type: bool
    initial_value: 'false'

  # Flags hysteresis (text_sensor doesn't support filters)
  - id: last_flags_value
    type: uint64_t
    initial_value: '0'
  - id: last_flags_publish
    type: uint32_t
    initial_value: '0'

  # CAN charge/discharge enable flags (from 0x35C)
  - id: can_charge_enabled
    type: bool
    initial_value: 'true'
  - id: can_discharge_enabled
    type: bool
    initial_value: 'true'
  - id: can_force_charge_request
    type: bool
    initial_value: 'false'

  # CAN bus statistics
  - id: can_frame_count
    type: int
    initial_value: '0'
  - id: can_error_count
    type: int
    initial_value: '0'

  # CAN 0x359 decoded protection flags (byte 0-1)
  - id: can_prot_overvolt
    type: bool
    initial_value: 'false'
  - id: can_prot_undervolt
    type: bool
    initial_value: 'false'
  - id: can_prot_overtemp
    type: bool
    initial_value: 'false'
  - id: can_prot_undertemp
    type: bool
    initial_value: 'false'
  - id: can_prot_discharge_overcurrent
    type: bool
    initial_value: 'false'
  - id: can_prot_charge_overcurrent
    type: bool
    initial_value: 'false'
  - id: can_prot_system_error
    type: bool
    initial_value: 'false'

  # CAN 0x359 decoded warning flags (byte 2-3)
  - id: can_warn_high_voltage
    type: bool
    initial_value: 'false'
  - id: can_warn_low_voltage
    type: bool
    initial_value: 'false'
  - id: can_warn_high_temp
    type: bool
    initial_value: 'false'
  - id: can_warn_low_temp
    type: bool
    initial_value: 'false'
  - id: can_warn_high_discharge_current
    type: bool
    initial_value: 'false'
  - id: can_warn_high_charge_current
    type: bool
    initial_value: 'false'
  - id: can_warn_comms_fail
    type: bool
    initial_value: 'false'

  # CAN 0x359 module status (byte 4-7)
  - id: can_module_count
    type: int
    initial_value: '0'
  - id: can_status_byte7
    type: int
    initial_value: '0'

  # CAN 0x359 compact alarm summary for web UI
  - id: can_alarm_summary
    type: std::string
    restore_value: no

  # CAN 0x359 decoded flags hysteresis tracking
  - id: last_can_decoded_state
    type: uint32_t
    initial_value: '0'
  - id: last_can_decoded_publish
    type: uint32_t
    initial_value: '0'

  # CAN diagnostic counters hysteresis (60s interval)
  - id: last_can_diag_publish
    type: uint32_t
    initial_value: '0'

  # CAN charge/discharge flags hysteresis
  - id: last_can_charge_state
    type: uint8_t
    initial_value: '0xFF'  # Invalid initial to force first publish

  # RS485 temperature hysteresis tracking (0.2°C threshold)
  - id: last_batt_temps
    type: std::vector<float>
    restore_value: no

  # RS485 stack hysteresis tracking
  - id: last_stack_temp_min
    type: float
    initial_value: '-999.0'
  - id: last_stack_temp_max
    type: float
    initial_value: '-999.0'
  - id: last_stack_balancing_count
    type: int
    initial_value: '-1'
  - id: last_stack_balancing_cells
    type: std::string
    restore_value: no
  - id: last_stack_overvolt_count
    type: int
    initial_value: '-1'
  - id: last_stack_overvolt_cells
    type: std::string
    restore_value: no
  - id: last_stack_alarms
    type: std::string
    restore_value: no

  # RS485 stale detection
  - id: last_rs485_rx
    type: uint32_t
    initial_value: '0'
  - id: rs485_stale
    type: bool
    initial_value: 'true'  # Start as stale until first successful receive

  # RS485 polling state
  - id: rs485_poll_battery
    type: int
    initial_value: '0'

  # Cell voltages: 3 batteries x 16 cells = 48
  - id: cell_voltages
    type: std::vector<float>
    restore_value: no

  # Temperatures: 3 batteries x 6 sensors = 18
  - id: cell_temps
    type: std::vector<float>
    restore_value: no

  # Per-battery data
  - id: batt_current
    type: std::vector<float>
    restore_value: no
  - id: batt_voltage
    type: std::vector<float>
    restore_value: no
  - id: batt_soc
    type: std::vector<float>
    restore_value: no
  - id: batt_remain_ah
    type: std::vector<float>
    restore_value: no
  - id: batt_total_ah
    type: std::vector<float>
    restore_value: no
  - id: batt_cycles
    type: std::vector<int>
    restore_value: no
  - id: batt_balancing_count
    type: std::vector<int>
    restore_value: no
  - id: batt_balancing_cells
    type: std::vector<std::string>
    restore_value: no
  - id: batt_overvolt_count
    type: std::vector<int>
    restore_value: no
  - id: batt_overvolt_cells
    type: std::vector<std::string>
    restore_value: no
  - id: batt_alarms
    type: std::vector<std::string>
    restore_value: no
  - id: batt_warnings
    type: std::vector<std::string>
    restore_value: no
  - id: batt_state
    type: std::vector<std::string>
    restore_value: no
  - id: batt_charge_mosfet
    type: std::vector<bool>
    restore_value: no
  - id: batt_discharge_mosfet
    type: std::vector<bool>
    restore_value: no
  - id: batt_lmcharge_mosfet
    type: std::vector<bool>
    restore_value: no

  # CW (Cell Warning) flag - correlates with CW=Y on BMS display
  - id: batt_cw_active
    type: std::vector<bool>
    restore_value: no
  - id: batt_cw_cells
    type: std::vector<std::string>
    restore_value: no

  # Stack totals
  - id: stack_balancing_count
    type: int
    initial_value: '0'
  - id: stack_balancing_cells
    type: std::string
    restore_value: no
  - id: stack_overvolt_count
    type: int
    initial_value: '0'
  - id: stack_overvolt_cells
    type: std::string
    restore_value: no
  - id: stack_alarms
    type: std::string
    restore_value: no

  - id: rs485_busy
    type: bool
    restore_value: no
    initial_value: 'false'

  # Per-battery poll failure tracking (for poll alarm)
  - id: batt_poll_failures
    type: std::vector<int>
    restore_value: no
  - id: batt_poll_alarm
    type: std::vector<bool>
    restore_value: no

# Intervals for stale detection and RS485 polling
interval:
  # CAN stale detection
  - interval: 5s
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t elapsed = now - id(last_can_rx);
          if (elapsed > 30000 && !id(can_stale) && id(last_can_rx) > 0) {
            id(can_stale) = true;
            ESP_LOGW("can", "No CAN data for 30s, marking stale");
            id(mqtt_client).publish(std::string("${can_prefix}/status"), std::string("offline"), (uint8_t)0, true);
          }

  # CAN charge/discharge flags and diagnostics publishing
  - interval: 10s
    then:
      - lambda: |-
          char payload[16];
          uint32_t now = millis();

          // Charge/discharge flags hysteresis - pack into byte: bit0=charge, bit1=discharge, bit2=force
          uint8_t charge_state = 0;
          if (id(can_charge_enabled)) charge_state |= 0x01;
          if (id(can_discharge_enabled)) charge_state |= 0x02;
          if (id(can_force_charge_request)) charge_state |= 0x04;

          if (charge_state != id(last_can_charge_state)) {
            id(mqtt_client).publish(std::string("${can_prefix}/can/charge_enabled"),
                id(can_charge_enabled) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/discharge_enabled"),
                id(can_discharge_enabled) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/force_charge"),
                id(can_force_charge_request) ? std::string("1") : std::string("0"));
            id(last_can_charge_state) = charge_state;
          }

          // Publish diagnostic counters every 60s (not on change - they always change)
          if (now - id(last_can_diag_publish) >= 60000) {
            snprintf(payload, sizeof(payload), "%d", id(can_frame_count));
            id(mqtt_client).publish(std::string("${can_prefix}/diag/frame_count"), std::string(payload));
            snprintf(payload, sizeof(payload), "%d", id(can_error_count));
            id(mqtt_client).publish(std::string("${can_prefix}/diag/error_count"), std::string(payload));
            id(last_can_diag_publish) = now;
          }

          // Build combined state for hysteresis check (protection + warning + module count)
          uint32_t current_state = 0;
          // Pack protection flags into bits 0-6
          if (id(can_prot_overvolt)) current_state |= (1 << 0);
          if (id(can_prot_undervolt)) current_state |= (1 << 1);
          if (id(can_prot_overtemp)) current_state |= (1 << 2);
          if (id(can_prot_undertemp)) current_state |= (1 << 3);
          if (id(can_prot_discharge_overcurrent)) current_state |= (1 << 4);
          if (id(can_prot_charge_overcurrent)) current_state |= (1 << 5);
          if (id(can_prot_system_error)) current_state |= (1 << 6);
          // Pack warning flags into bits 7-13
          if (id(can_warn_high_voltage)) current_state |= (1 << 7);
          if (id(can_warn_low_voltage)) current_state |= (1 << 8);
          if (id(can_warn_high_temp)) current_state |= (1 << 9);
          if (id(can_warn_low_temp)) current_state |= (1 << 10);
          if (id(can_warn_high_discharge_current)) current_state |= (1 << 11);
          if (id(can_warn_high_charge_current)) current_state |= (1 << 12);
          if (id(can_warn_comms_fail)) current_state |= (1 << 13);
          // Pack module count and status_byte7 into bits 16-31
          current_state |= ((uint32_t)id(can_module_count) << 16);
          current_state |= ((uint32_t)id(can_status_byte7) << 24);

          // Hysteresis: only publish if state changed OR 60s heartbeat
          // (reuse 'now' from above)
          bool state_changed = (current_state != id(last_can_decoded_state));
          bool heartbeat = (now - id(last_can_decoded_publish) >= 60000);

          if (state_changed || heartbeat) {
            // Publish 0x359 decoded protection flags
            id(mqtt_client).publish(std::string("${can_prefix}/can/prot_overvolt"),
                id(can_prot_overvolt) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/prot_undervolt"),
                id(can_prot_undervolt) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/prot_overtemp"),
                id(can_prot_overtemp) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/prot_undertemp"),
                id(can_prot_undertemp) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/prot_discharge_overcurrent"),
                id(can_prot_discharge_overcurrent) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/prot_charge_overcurrent"),
                id(can_prot_charge_overcurrent) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/prot_system_error"),
                id(can_prot_system_error) ? std::string("1") : std::string("0"));

            // Publish 0x359 decoded warning flags
            id(mqtt_client).publish(std::string("${can_prefix}/can/warn_high_voltage"),
                id(can_warn_high_voltage) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/warn_low_voltage"),
                id(can_warn_low_voltage) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/warn_high_temp"),
                id(can_warn_high_temp) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/warn_low_temp"),
                id(can_warn_low_temp) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/warn_high_discharge_current"),
                id(can_warn_high_discharge_current) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/warn_high_charge_current"),
                id(can_warn_high_charge_current) ? std::string("1") : std::string("0"));
            id(mqtt_client).publish(std::string("${can_prefix}/can/warn_comms_fail"),
                id(can_warn_comms_fail) ? std::string("1") : std::string("0"));

            // Publish 0x359 module count and status byte 7
            snprintf(payload, sizeof(payload), "%d", id(can_module_count));
            id(mqtt_client).publish(std::string("${can_prefix}/can/module_count"), std::string(payload));
            snprintf(payload, sizeof(payload), "%d", id(can_status_byte7));
            id(mqtt_client).publish(std::string("${can_prefix}/can/status_byte7"), std::string(payload));

            // Publish alarm summary
            id(mqtt_client).publish(std::string("${can_prefix}/can/alarm_summary"),
                id(can_alarm_summary).empty() ? std::string("OK") : id(can_alarm_summary));

            // Update template sensors on change (for Home Assistant integration)
            // Module count - only update if changed
            if (id(can_module_count) != id(last_module_count)) {
                id(sensor_can_module_count).publish_state(id(can_module_count));
                id(last_module_count) = id(can_module_count);
            }
            
            // Status byte 7 - only update if changed
            if (id(can_status_byte7) != id(last_status_byte7)) {
                id(sensor_can_status_byte7).publish_state(id(can_status_byte7));
                id(last_status_byte7) = id(can_status_byte7);
            }
            
            // Alarm summary - only update if changed
            if (id(can_alarm_summary) != id(last_alarm_summary)) {
                id(sensor_can_alarm_summary).publish_state(id(can_alarm_summary));
                id(last_alarm_summary) = id(can_alarm_summary);
            }

            id(last_can_decoded_state) = current_state;
            id(last_can_decoded_publish) = now;
          }

  # RS485 stale detection and availability
  - interval: 30s
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t elapsed = now - id(last_rs485_rx);
          // Mark stale if no data for 90s (3 full polling cycles)
          if (elapsed > 90000 && !id(rs485_stale) && id(last_rs485_rx) > 0) {
            id(rs485_stale) = true;
            ESP_LOGW("rs485", "No RS485 data for 90s, marking stale");
            id(mqtt_client).publish(std::string("${rs485_prefix}/status"), std::string("offline"), (uint8_t)0, true);
          }
          // Republish current status periodically
          if (!id(rs485_stale)) {
            id(mqtt_client).publish(std::string("${rs485_prefix}/status"), std::string("online"), (uint8_t)0, true);
          }

  # RS485 analog data polling - cycle through batteries
  - interval: 10s
    then:
      - lambda: |-
          // Prevent overlapping RS485 transactions (10s/30s polls)
          if (id(rs485_busy)) {
            ESP_LOGW("rs485", "BUSY: skipping RS485 poll (another transaction in progress)");
            return;
          }
          Rs485BusyGuard _rs485_guard(id(rs485_busy));

          int batt = id(rs485_poll_battery);
          int addr = ${pylontech_addr};

          // Send analog data request (CID2=0x42)
          std::string cmd = rs485_make_cmd(addr, 0x42, batt);
          ESP_LOGD("rs485", "TX analog batt %d", batt);

          // Clear RX buffer
          while (id(rs485_uart).available()) {
            uint8_t c;
            id(rs485_uart).read_byte(&c);
          }

          ESP_LOGD("rs485", "TX: %s", cmd.c_str());

          for (char c : cmd) {
            id(rs485_uart).write_byte((uint8_t)c);
          }
          id(rs485_uart).flush();

          // Wait for transmission to complete (at 9600 baud, ~1ms per byte)
          delay(20);

          id(rs485_poll_battery) = (batt + 1) % ${num_batteries};

          // Wait for response
          delay(300);

          // Read response (frame-based: wait for '\r')
          std::string response;
          response.reserve(600);
          uint32_t start_ms = millis();
          bool got_eof = false;
          while (millis() - start_ms < 1200) {
            while (id(rs485_uart).available()) {
              uint8_t c;
              id(rs485_uart).read_byte(&c);
              response += (char)c;
              if (c == '\r') { got_eof = true; break; }
            }
            if (got_eof) break;
            delay(5);
          }
          // Trim leading garbage until start marker '~' (if present)
          auto tilde = response.find('~');
          if (tilde != std::string::npos) response = response.substr(tilde);
          ESP_LOGD("rs485", "RX len=%d: %s", response.length(), response.c_str());
          
          // Detailed response analysis for debugging
          if (response.length() >= 18) {
            std::string error_code = response.substr(7, 2);
            ESP_LOGD("rs485", "Response error code: %s (00=success, 02=invalid cmd, etc.)", error_code.c_str());
            if (error_code != "00") {
              ESP_LOGW("rs485", "BMS returned error code %s for command: %s", error_code.c_str(), cmd.c_str());
            }
          }

          // Helper to handle poll failure for this battery
          auto handle_poll_failure = [&batt](const char* reason) {
            ESP_LOGW("rs485", "Batt %d poll failed: %s", batt, reason);
            id(batt_poll_failures)[batt]++;
            if (id(batt_poll_failures)[batt] >= 10 && !id(batt_poll_alarm)[batt]) {
              id(batt_poll_alarm)[batt] = true;
              ESP_LOGW("rs485", "POLL ALARM: Battery %d not responding (10 consecutive failures)", batt);
              char topic[64];
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/poll_alarm", batt);
              id(mqtt_client).publish(std::string(topic), std::string("ON"), (uint8_t)0, true);
            }
          };

          // Validate response (checks length, error code, address, and checksum)
          std::string error = rs485_validate_response(response, addr);
          if (!error.empty()) {
            handle_poll_failure(error.c_str());
            return;
          }

          // Success! Reset poll failure counter and clear alarm if set
          if (id(batt_poll_failures)[batt] > 0 || id(batt_poll_alarm)[batt]) {
            id(batt_poll_failures)[batt] = 0;
            if (id(batt_poll_alarm)[batt]) {
              id(batt_poll_alarm)[batt] = false;
              ESP_LOGI("rs485", "Poll alarm cleared for battery %d", batt);
              char topic[64];
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/poll_alarm", batt);
              id(mqtt_client).publish(std::string(topic), std::string("OFF"), (uint8_t)0, true);
            }
          }

          // Mark as not stale
          id(last_rs485_rx) = millis();
          if (id(rs485_stale)) {
            id(rs485_stale) = false;
            id(mqtt_client).publish(std::string("${rs485_prefix}/status"), std::string("online"), (uint8_t)0, true);
            ESP_LOGI("rs485", "RS485 data received, marking online");
          }

          // Extract INFO data (batt variable already set at start of lambda)
          std::string data = response.substr(13, response.length() - 13 - 5);

          size_t i = 0;

          // Skip header (4 chars)
          if (data.length() < 6) return;
          i += 4;

          // Number of cells
          int num_cells = strtol(data.substr(i, 2).c_str(), nullptr, 16);
          i += 2;

          // Cell voltages
          for (int cell = 0; cell < num_cells && cell < 16; cell++) {
            if (data.length() < i + 4) break;
            int mv = strtol(data.substr(i, 4).c_str(), nullptr, 16);
            id(cell_voltages)[batt * 16 + cell] = mv / 1000.0f;
            i += 4;
          }

          // Number of temps
          if (data.length() < i + 2) return;
          int num_temps = strtol(data.substr(i, 2).c_str(), nullptr, 16);
          i += 2;

          // Temperatures (Kelvin * 10 - 2731 = Celsius * 10)
          for (int t = 0; t < num_temps && t < 6; t++) {
            if (data.length() < i + 4) break;
            int raw = strtol(data.substr(i, 4).c_str(), nullptr, 16);
            id(cell_temps)[batt * 6 + t] = (raw - 2731) / 10.0f;
            i += 4;
          }

          // Current (signed, 10mA units)
          if (data.length() >= i + 4) {
            int raw = strtol(data.substr(i, 4).c_str(), nullptr, 16);
            if (raw > 0x7FFF) raw -= 0x10000;
            id(batt_current)[batt] = raw / 100.0f;
            i += 4;
          }

          // Voltage (10mV units, same as current)
          if (data.length() >= i + 4) {
            id(batt_voltage)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16) / 100.0f;
            i += 4;
          }

          // Remaining capacity (10mAh)
          if (data.length() >= i + 4) {
            id(batt_remain_ah)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16) / 100.0f;
            i += 4;
          }

          // Skip custom byte
          i += 2;

          // Total capacity (10mAh)
          if (data.length() >= i + 4) {
            id(batt_total_ah)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16) / 100.0f;
            i += 4;
          }

          // Cycles
          if (data.length() >= i + 4) {
            id(batt_cycles)[batt] = strtol(data.substr(i, 4).c_str(), nullptr, 16);
          }

          // Calculate SOC
          if (id(batt_total_ah)[batt] > 0) {
            id(batt_soc)[batt] = (id(batt_remain_ah)[batt] / id(batt_total_ah)[batt]) * 100.0f;
          }

          ESP_LOGI("rs485", "Batt %d: %.3fV %.2fA SOC=%.0f%% cycles=%d",
                   batt, id(batt_voltage)[batt], id(batt_current)[batt],
                   id(batt_soc)[batt], id(batt_cycles)[batt]);

  # RS485 alarm/balancing polling
  - interval: 30s
    then:
      - lambda: |-
          // Prevent overlapping RS485 transactions (10s/30s polls)
          if (id(rs485_busy)) {
            ESP_LOGW("rs485", "BUSY: skipping RS485 poll (another transaction in progress)");
            return;
          }
          Rs485BusyGuard _rs485_guard(id(rs485_busy));

          int addr = ${pylontech_addr};
          int total_balancing = 0;
          int total_overvolt = 0;
          std::set<std::string> all_alarms;

          // Helper to handle poll failure for a battery
          auto handle_poll_failure = [](int batt, const char* reason) {
            ESP_LOGW("rs485", "Batt %d alarm poll failed: %s", batt, reason);
            id(batt_poll_failures)[batt]++;
            if (id(batt_poll_failures)[batt] >= 10 && !id(batt_poll_alarm)[batt]) {
              id(batt_poll_alarm)[batt] = true;
              ESP_LOGW("rs485", "POLL ALARM: Battery %d not responding (10 consecutive failures)", batt);
              char topic[64];
              snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/poll_alarm", batt);
              id(mqtt_client).publish(std::string(topic), std::string("ON"), (uint8_t)0, true);
            }
          };

          // Helper to handle poll success for a battery
          auto handle_poll_success = [](int batt) {
            if (id(batt_poll_failures)[batt] > 0 || id(batt_poll_alarm)[batt]) {
              id(batt_poll_failures)[batt] = 0;
              if (id(batt_poll_alarm)[batt]) {
                id(batt_poll_alarm)[batt] = false;
                ESP_LOGI("rs485", "Poll alarm cleared for battery %d", batt);
                char topic[64];
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/poll_alarm", batt);
                id(mqtt_client).publish(std::string(topic), std::string("OFF"), (uint8_t)0, true);
              }
            }
          };

          for (int batt = 0; batt < ${num_batteries}; batt++) {
            // Clear buffer
            while (id(rs485_uart).available()) {
              uint8_t c;
              id(rs485_uart).read_byte(&c);
            }

            // Send alarm request (CID2=0x44)
            std::string cmd = rs485_make_cmd(addr, 0x44, batt);
            ESP_LOGD("rs485", "TX alarm batt %d", batt);
            ESP_LOGD("rs485", "TX: %s", cmd.c_str());

            for (char c : cmd) {
              id(rs485_uart).write_byte((uint8_t)c);
            }
            id(rs485_uart).flush();

            // Wait for transmission to complete (at 9600 baud, ~1ms per byte)
            delay(20);

            delay(300);

            // Read response (frame-based: wait for '\r')
            std::string response;
            response.reserve(600);
            uint32_t start_ms = millis();
            bool got_eof = false;
            while (millis() - start_ms < 1200) {
              while (id(rs485_uart).available()) {
                uint8_t c;
                id(rs485_uart).read_byte(&c);
                response += (char)c;
                if (c == '\r') { got_eof = true; break; }
              }
              if (got_eof) break;
              delay(5);
            }
            // Trim leading garbage until start marker '~' (if present)
            auto tilde = response.find('~');
            if (tilde != std::string::npos) response = response.substr(tilde);
            ESP_LOGD("rs485", "RX alarm len=%d: %s", response.length(), response.c_str());
            
            // Detailed response analysis for debugging
            if (response.length() >= 18) {
              std::string error_code = response.substr(7, 2);
              ESP_LOGD("rs485", "Alarm response error code: %s", error_code.c_str());
              if (error_code != "00") {
                ESP_LOGW("rs485", "BMS returned alarm error %s for command: %s", error_code.c_str(), cmd.c_str());
              }
            }

            // Validate response (checks length, error code, address, and checksum)
            std::string error = rs485_validate_response(response, addr);
            if (!error.empty()) {
              ESP_LOGW("rs485", "Alarm poll validation failed: %s. Response: %s", error.c_str(), response.c_str());
              handle_poll_failure(batt, error.c_str());
              continue;
            }

            handle_poll_success(batt);

            std::string data = response.substr(13, response.length() - 13 - 5);
            if (data.length() < 40) continue;

            // Parse: skip info_flag(2), battery(2), get num_cells(2)
            int num_cells = strtol(data.substr(4, 2).c_str(), nullptr, 16);

            // Cell status bytes (0x00=normal, 0x01=undervolt, 0x02=overvolt)
            // Note: Balance flags are NOT in per-cell bytes - they're in status bytes 9-10
            std::set<std::string> batt_warnings_set;
            std::set<std::string> batt_alarms_set;
            int overvolt_count = 0;
            std::string ov_cells_str;

            for (int c = 0; c < num_cells && c < 16; c++) {
              int pos = 6 + c * 2;
              if (pos + 2 <= (int)data.length()) {
                int status = strtol(data.substr(pos, 2).c_str(), nullptr, 16);
                // Cell undervolt is an alarm, overvolt at 100% SOC is just a warning
                if (status == 0x01) { batt_alarms_set.insert("cell_undervolt"); all_alarms.insert("cell_undervolt"); }
                if (status == 0x02) {
                  batt_warnings_set.insert("cell_overvolt");
                  overvolt_count++;
                  if (!ov_cells_str.empty()) ov_cells_str += ",";
                  ov_cells_str += std::to_string(c + 1);
                }
              }
            }
            id(batt_overvolt_count)[batt] = overvolt_count;
            id(batt_overvolt_cells)[batt] = ov_cells_str;
            total_overvolt += overvolt_count;

            // Temperature status
            int temp_pos = 6 + num_cells * 2;
            if (temp_pos + 2 <= (int)data.length()) {
              int num_temps = strtol(data.substr(temp_pos, 2).c_str(), nullptr, 16);
              int t_start = temp_pos + 2;
              for (int t = 0; t < num_temps; t++) {
                int pos = t_start + t * 2;
                if (pos + 2 <= (int)data.length()) {
                  int status = strtol(data.substr(pos, 2).c_str(), nullptr, 16);
                  if (status == 0x01) { batt_alarms_set.insert("undertemp"); all_alarms.insert("undertemp"); }
                  if (status == 0x02) { batt_alarms_set.insert("overtemp"); all_alarms.insert("overtemp"); }
                }
              }

              // Status bytes start after temp status bytes
              // Structure: Current(1) + PackVolt(1) + ExtBitCount(1) + ExtBit data
              int status_pos = t_start + num_temps * 2;
              int ext_bit_start = status_pos + 6;  // Skip Current + PackVolt + Count (3 bytes = 6 hex chars)

              // Byte 0-1: Current/voltage status (before Ext_Bit section)
              if (status_pos + 2 <= (int)data.length()) {
                int charge_current = strtol(data.substr(status_pos, 2).c_str(), nullptr, 16);
                if (charge_current == 0x02) { batt_alarms_set.insert("charge_overcurrent"); all_alarms.insert("charge_overcurrent"); }
              }
              if (status_pos + 4 <= (int)data.length()) {
                int module_voltage = strtol(data.substr(status_pos + 2, 2).c_str(), nullptr, 16);
                if (module_voltage == 0x01) { batt_alarms_set.insert("pack_undervolt"); all_alarms.insert("pack_undervolt"); }
                if (module_voltage == 0x02) { batt_alarms_set.insert("pack_overvolt"); all_alarms.insert("pack_overvolt"); }
              }

              // ByteIndex 0: Balance On flag (in Ext_Bit section)
              bool balance_on = false;
              if (ext_bit_start + 2 <= (int)data.length()) {
                int balance_status = strtol(data.substr(ext_bit_start, 2).c_str(), nullptr, 16);
                balance_on = (balance_status & 0x01) != 0;
              }

              // ByteIndex 4 (ext_bit_start+8): Voltage status bitfield
              // bit0=CellOV_Alarm, bit1=CellOV_Protect, bit2=CellUV_Alarm, bit3=CellUV_Protect
              // bit4=PackOV_Alarm, bit5=PackOV_Protect, bit6=PackUV_Alarm, bit7=PackUV_Protect
              if (ext_bit_start + 10 <= (int)data.length()) {
                int voltage_status = strtol(data.substr(ext_bit_start + 8, 2).c_str(), nullptr, 16);
                // Warnings (informational - normal at 100% SOC)
                if (voltage_status & 0x01) batt_warnings_set.insert("cell_overvolt_alarm");
                if (voltage_status & 0x02) batt_warnings_set.insert("cell_overvolt_protect");
                if (voltage_status & 0x04) batt_warnings_set.insert("cell_undervolt_alarm");
                if (voltage_status & 0x10) batt_warnings_set.insert("pack_overvolt_alarm");
                if (voltage_status & 0x20) batt_warnings_set.insert("pack_overvolt_protect");
                if (voltage_status & 0x40) batt_warnings_set.insert("pack_undervolt_alarm");
                // Protections (actual problems)
                if (voltage_status & 0x08) { batt_alarms_set.insert("cell_undervolt_protect"); all_alarms.insert("cell_undervolt_protect"); }
                if (voltage_status & 0x80) { batt_alarms_set.insert("pack_undervolt_protect"); all_alarms.insert("pack_undervolt_protect"); }
              }

              // ByteIndex 9-10 (ext_bit_start+18): Individual cell balance flags
              // ByteIndex 9: Balance1-8 (bit0=cell1...bit7=cell8)
              // ByteIndex 10: Balance9-16 (bit0=cell9...bit7=cell16)
              // Only count balancing cells if Balance On flag is set
              int balancing = 0;
              std::string bal_cells_str;
              if (balance_on && ext_bit_start + 22 <= (int)data.length()) {
                int balance1_8 = strtol(data.substr(ext_bit_start + 18, 2).c_str(), nullptr, 16);
                int balance9_16 = strtol(data.substr(ext_bit_start + 20, 2).c_str(), nullptr, 16);
                for (int bit = 0; bit < 8; bit++) {
                  if (balance1_8 & (1 << bit)) {
                    balancing++;
                    if (!bal_cells_str.empty()) bal_cells_str += ",";
                    bal_cells_str += std::to_string(bit + 1);
                  }
                  if (balance9_16 & (1 << bit)) {
                    balancing++;
                    if (!bal_cells_str.empty()) bal_cells_str += ",";
                    bal_cells_str += std::to_string(bit + 9);
                  }
                }
              }
              id(batt_balancing_count)[batt] = balancing;
              id(batt_balancing_cells)[batt] = bal_cells_str;
              total_balancing += balancing;

              // ByteIndex 8 (ext_bit_start+16): MOSFET status
              // bit0=DISCHG_MOSFET, bit1=CHG_MOSFET, bit2=LMCHG_MOSFET
              if (ext_bit_start + 18 <= (int)data.length()) {
                int mosfet_status = strtol(data.substr(ext_bit_start + 16, 2).c_str(), nullptr, 16);
                id(batt_discharge_mosfet)[batt] = (mosfet_status & 0x01) != 0;
                id(batt_charge_mosfet)[batt] = (mosfet_status & 0x02) != 0;
                id(batt_lmcharge_mosfet)[batt] = (mosfet_status & 0x04) != 0;
              }

              // CW (Cell Warning) flag - read from OLD position (status_pos+18)
              // This correlates with CW=Y on BMS display
              if (status_pos + 22 <= (int)data.length()) {
                int cw_byte1 = strtol(data.substr(status_pos + 18, 2).c_str(), nullptr, 16);
                int cw_byte2 = strtol(data.substr(status_pos + 20, 2).c_str(), nullptr, 16);
                id(batt_cw_active)[batt] = (cw_byte1 != 0) || (cw_byte2 != 0);
                // Build CW cells string
                std::string cw_str;
                for (int bit = 0; bit < 8; bit++) {
                  if (cw_byte1 & (1 << bit)) {
                    if (!cw_str.empty()) cw_str += ",";
                    cw_str += std::to_string(bit + 1);
                  }
                  if (cw_byte2 & (1 << bit)) {
                    if (!cw_str.empty()) cw_str += ",";
                    cw_str += std::to_string(bit + 9);
                  }
                }
                id(batt_cw_cells)[batt] = cw_str;
              }

              // Operating state from last byte
              // 0x01=Discharge, 0x02=Charge, 0x04=Float, 0x08=Full, 0x10=Standby, 0x20=Shutdown
              if (data.length() >= 2) {
                int last_byte = strtol(data.substr(data.length() - 2, 2).c_str(), nullptr, 16);
                std::string state_str;
                if (last_byte & 0x01) { if (!state_str.empty()) state_str += ", "; state_str += "Discharge"; }
                if (last_byte & 0x02) { if (!state_str.empty()) state_str += ", "; state_str += "Charge"; }
                if (last_byte & 0x04) { if (!state_str.empty()) state_str += ", "; state_str += "Float"; }
                if (last_byte & 0x08) { if (!state_str.empty()) state_str += ", "; state_str += "Full"; }
                if (last_byte & 0x10) { if (!state_str.empty()) state_str += ", "; state_str += "Standby"; }
                if (last_byte & 0x20) { if (!state_str.empty()) state_str += ", "; state_str += "Shutdown"; }
                id(batt_state)[batt] = state_str.empty() ? "Idle" : state_str;
              }
            }

            // Build per-battery warning/alarm strings
            std::string warn_str, alarm_str;
            for (const auto& w : batt_warnings_set) {
              if (!warn_str.empty()) warn_str += ",";
              warn_str += w;
            }
            for (const auto& a : batt_alarms_set) {
              if (!alarm_str.empty()) alarm_str += ",";
              alarm_str += a;
            }
            id(batt_warnings)[batt] = warn_str;
            id(batt_alarms)[batt] = alarm_str;
          }

          id(stack_balancing_count) = total_balancing;
          id(stack_balancing_cells) = build_stack_cells_string(id(batt_balancing_cells), ${num_batteries});

          id(stack_overvolt_count) = total_overvolt;
          id(stack_overvolt_cells) = build_stack_cells_string(id(batt_overvolt_cells), ${num_batteries});

          // Build alarm string
          std::string alarm_str;
          for (const auto& a : all_alarms) {
            if (!alarm_str.empty()) alarm_str += ",";
            alarm_str += a;
          }
          id(stack_alarms) = alarm_str;

          if (total_balancing > 0) {
            ESP_LOGI("rs485", "Stack: %d cells balancing", total_balancing);
          }
          if (!alarm_str.empty()) {
            ESP_LOGW("rs485", "Alarms: %s", alarm_str.c_str());
          }

  # Publish RS485 data to MQTT - matches Python topic structure exactly
  - interval: 30s
    then:
      - lambda: |-
          char topic[80], payload[32];

          // Calculate stack totals
          float stack_cell_min = 99.0f, stack_cell_max = 0.0f;
          float stack_temp_min = 99.0f, stack_temp_max = -99.0f;
          float stack_voltage = 0.0f;
          float stack_current = 0.0f;
          int valid_batts = 0;

          for (int batt = 0; batt < ${num_batteries}; batt++) {
            float batt_min = 99.0f, batt_max = 0.0f;

            // Find cell min/max for this battery
            for (int cell = 0; cell < 16; cell++) {
              float v = id(cell_voltages)[batt * 16 + cell];
              if (v > 0.1f) {
                if (v < batt_min) batt_min = v;
                if (v > batt_max) batt_max = v;
                if (v < stack_cell_min) stack_cell_min = v;
                if (v > stack_cell_max) stack_cell_max = v;
              }
            }

            // Find temp min/max for this battery
            for (int t = 0; t < 6; t++) {
              float temp = id(cell_temps)[batt * 6 + t];
              if (temp > -40.0f && temp < 100.0f) {
                if (temp < stack_temp_min) stack_temp_min = temp;
                if (temp > stack_temp_max) stack_temp_max = temp;
              }
            }

            // Stack totals (parallel config: voltage avg, current sum)
            if (id(batt_voltage)[batt] > 0.1f) {
              stack_voltage += id(batt_voltage)[batt];
              valid_batts++;
            }
            stack_current += id(batt_current)[batt];

            // Publish per-battery data with hysteresis
            if (batt_min < 99.0f) {
              // Cell min/max/delta with 5mV hysteresis
              if (id(last_batt_cell_min)[batt] < 0 || fabsf(batt_min - id(last_batt_cell_min)[batt]) >= 0.005f) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cell_min", batt);
                snprintf(payload, sizeof(payload), "%.3f", batt_min);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_cell_min)[batt] = batt_min;
              }

              if (id(last_batt_cell_max)[batt] < 0 || fabsf(batt_max - id(last_batt_cell_max)[batt]) >= 0.005f) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cell_max", batt);
                snprintf(payload, sizeof(payload), "%.3f", batt_max);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_cell_max)[batt] = batt_max;
              }

              float cell_delta = (batt_max - batt_min) * 1000.0f;
              if (id(last_batt_cell_delta)[batt] < 0 || fabsf(cell_delta - id(last_batt_cell_delta)[batt]) >= 5.0f) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cell_delta_mv", batt);
                snprintf(payload, sizeof(payload), "%.1f", cell_delta);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_cell_delta)[batt] = cell_delta;
              }

              // Voltage with 100mV hysteresis, current with 50mA hysteresis
              if (id(last_batt_voltages)[batt] < 0 || fabsf(id(batt_voltage)[batt] - id(last_batt_voltages)[batt]) >= 0.1f) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/voltage", batt);
                snprintf(payload, sizeof(payload), "%.2f", id(batt_voltage)[batt]);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_voltages)[batt] = id(batt_voltage)[batt];
              }

              if (id(last_batt_currents)[batt] < 0 || fabsf(id(batt_current)[batt] - id(last_batt_currents)[batt]) >= 0.05f) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/current", batt);
                snprintf(payload, sizeof(payload), "%.2f", id(batt_current)[batt]);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_currents)[batt] = id(batt_current)[batt];
              }

              // SOC with 1% hysteresis, capacity with 0.5Ah hysteresis
              if (id(last_batt_socs)[batt] < 0 || fabsf(id(batt_soc)[batt] - id(last_batt_socs)[batt]) >= 1.0f) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/soc", batt);
                snprintf(payload, sizeof(payload), "%.0f", id(batt_soc)[batt]);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_socs)[batt] = id(batt_soc)[batt];
              }

              if (id(last_batt_remain_ah)[batt] < 0 || fabsf(id(batt_remain_ah)[batt] - id(last_batt_remain_ah)[batt]) >= 0.5f) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/remain_ah", batt);
                snprintf(payload, sizeof(payload), "%.1f", id(batt_remain_ah)[batt]);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_remain_ah)[batt] = id(batt_remain_ah)[batt];
              }

              if (id(last_batt_total_ah)[batt] < 0 || fabsf(id(batt_total_ah)[batt] - id(last_batt_total_ah)[batt]) >= 0.5f) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/total_ah", batt);
                snprintf(payload, sizeof(payload), "%.1f", id(batt_total_ah)[batt]);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_total_ah)[batt] = id(batt_total_ah)[batt];
              }

              // Cycles only publish on change (integer value)
              if (id(batt_cycles)[batt] != id(last_batt_cycles)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cycles", batt);
                snprintf(payload, sizeof(payload), "%d", id(batt_cycles)[batt]);
                id(mqtt_client).publish(topic, payload);
                id(last_batt_cycles)[batt] = id(batt_cycles)[batt];
              }

              // Balancing with change detection
              if (id(batt_balancing_count)[batt] != id(last_batt_balancing_count)[batt] ||
                  id(batt_balancing_cells)[batt] != id(last_batt_balancing_cells)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/balancing_count", batt);
                snprintf(payload, sizeof(payload), "%d", id(batt_balancing_count)[batt]);
                id(mqtt_client).publish(topic, payload);
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/balancing_active", batt);
                id(mqtt_client).publish(topic, id(batt_balancing_count)[batt] > 0 ? "1" : "0");
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/balancing_cells", batt);
                id(mqtt_client).publish(topic, id(batt_balancing_cells)[batt].c_str());
                id(last_batt_balancing_count)[batt] = id(batt_balancing_count)[batt];
                id(last_batt_balancing_cells)[batt] = id(batt_balancing_cells)[batt];
              }

              // Overvolt with change detection
              if (id(batt_overvolt_count)[batt] != id(last_batt_overvolt_count)[batt] ||
                  id(batt_overvolt_cells)[batt] != id(last_batt_overvolt_cells)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/overvolt_count", batt);
                snprintf(payload, sizeof(payload), "%d", id(batt_overvolt_count)[batt]);
                id(mqtt_client).publish(topic, payload);
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/overvolt_active", batt);
                id(mqtt_client).publish(topic, id(batt_overvolt_count)[batt] > 0 ? "1" : "0");
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/overvolt_cells", batt);
                id(mqtt_client).publish(topic, id(batt_overvolt_cells)[batt].c_str());
                id(last_batt_overvolt_count)[batt] = id(batt_overvolt_count)[batt];
                id(last_batt_overvolt_cells)[batt] = id(batt_overvolt_cells)[batt];
              }

              // State, warnings, alarms with change detection
              if (id(batt_state)[batt] != id(last_batt_states)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/state", batt);
                id(mqtt_client).publish(topic, id(batt_state)[batt].c_str());
                id(last_batt_states)[batt] = id(batt_state)[batt];
              }

              if (id(batt_warnings)[batt] != id(last_batt_warnings)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/warnings", batt);
                id(mqtt_client).publish(topic, id(batt_warnings)[batt].c_str());
                id(last_batt_warnings)[batt] = id(batt_warnings)[batt];
              }

              if (id(batt_alarms)[batt] != id(last_batt_alarms)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/alarms", batt);
                id(mqtt_client).publish(topic, id(batt_alarms)[batt].c_str());
                id(last_batt_alarms)[batt] = id(batt_alarms)[batt];
              }

              // MOSFET status with change detection
              if (id(batt_charge_mosfet)[batt] != id(last_batt_charge_mosfet)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/charge_mosfet", batt);
                id(mqtt_client).publish(topic, id(batt_charge_mosfet)[batt] ? "1" : "0");
                id(last_batt_charge_mosfet)[batt] = id(batt_charge_mosfet)[batt];
              }

              if (id(batt_discharge_mosfet)[batt] != id(last_batt_discharge_mosfet)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/discharge_mosfet", batt);
                id(mqtt_client).publish(topic, id(batt_discharge_mosfet)[batt] ? "1" : "0");
                id(last_batt_discharge_mosfet)[batt] = id(batt_discharge_mosfet)[batt];
              }

              if (id(batt_lmcharge_mosfet)[batt] != id(last_batt_lmcharge_mosfet)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/lmcharge_mosfet", batt);
                id(mqtt_client).publish(topic, id(batt_lmcharge_mosfet)[batt] ? "1" : "0");
                id(last_batt_lmcharge_mosfet)[batt] = id(batt_lmcharge_mosfet)[batt];
              }

              // CW (Cell Warning) flag with change detection
              if (id(batt_cw_active)[batt] != id(last_batt_cw_active)[batt] ||
                  id(batt_cw_cells)[batt] != id(last_batt_cw_cells)[batt]) {
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cw_active", batt);
                id(mqtt_client).publish(topic, id(batt_cw_active)[batt] ? "1" : "0");
                snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cw_cells", batt);
                id(mqtt_client).publish(topic, id(batt_cw_cells)[batt].c_str());
                id(last_batt_cw_active)[batt] = id(batt_cw_active)[batt];
                id(last_batt_cw_cells)[batt] = id(batt_cw_cells)[batt];
              }

              // Individual cell voltages with 10mV hysteresis
              for (int cell = 0; cell < 16; cell++) {
                float v = id(cell_voltages)[batt * 16 + cell];
                if (v > 0.1f) {
                  int cell_idx = batt * 16 + cell;
                  float last_v = id(last_cell_voltages)[cell_idx];
                  
                  // Publish if first time or changed by >= 10mV (0.010V)
                  if (last_v < 0 || fabsf(v - last_v) >= 0.010f) {
                    snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/cell%02d", batt, cell + 1);
                    snprintf(payload, sizeof(payload), "%.3f", v);
                    id(mqtt_client).publish(topic, payload);
                    id(last_cell_voltages)[cell_idx] = v;  // Update tracking
                  }
                }
              }

              // Temperature sensors with 0.2°C hysteresis
              for (int t = 0; t < 6; t++) {
                float temp = id(cell_temps)[batt * 6 + t];
                if (temp > -40.0f && temp < 100.0f) {
                  int temp_idx = batt * 6 + t;
                  float last_temp = id(last_batt_temps)[temp_idx];
                  // Publish if first time (last=-999) or changed by >= 0.2°C
                  if (last_temp < -900.0f || fabsf(temp - last_temp) >= 0.2f) {
                    snprintf(topic, sizeof(topic), "${rs485_prefix}/battery%d/temp%d", batt, t + 1);
                    snprintf(payload, sizeof(payload), "%.1f", temp);
                    id(mqtt_client).publish(topic, payload);
                    id(last_batt_temps)[temp_idx] = temp;
                  }
                }
              }
            }
          }

          // Publish stack totals with hysteresis
          if (stack_cell_min < 99.0f && valid_batts > 0) {
            stack_voltage /= valid_batts;  // Average for parallel config

            // Cell min/max/delta with 5mV hysteresis
            if (id(last_stack_cell_min) < 0 || fabsf(stack_cell_min - id(last_stack_cell_min)) >= 0.005f) {
              snprintf(payload, sizeof(payload), "%.3f", stack_cell_min);
              id(mqtt_client).publish("${rs485_prefix}/stack/cell_min", payload);
              id(last_stack_cell_min) = stack_cell_min;
            }

            if (id(last_stack_cell_max) < 0 || fabsf(stack_cell_max - id(last_stack_cell_max)) >= 0.005f) {
              snprintf(payload, sizeof(payload), "%.3f", stack_cell_max);
              id(mqtt_client).publish("${rs485_prefix}/stack/cell_max", payload);
              id(last_stack_cell_max) = stack_cell_max;
            }

            float stack_cell_delta = (stack_cell_max - stack_cell_min) * 1000.0f;
            if (id(last_stack_cell_delta) < 0 || fabsf(stack_cell_delta - id(last_stack_cell_delta)) >= 5.0f) {
              snprintf(payload, sizeof(payload), "%.1f", stack_cell_delta);
              id(mqtt_client).publish("${rs485_prefix}/stack/cell_delta_mv", payload);
              id(last_stack_cell_delta) = stack_cell_delta;
            }

            // Voltage with 100mV hysteresis, current with 50mA hysteresis
            if (id(last_stack_voltage) < 0 || fabsf(stack_voltage - id(last_stack_voltage)) >= 0.1f) {
              snprintf(payload, sizeof(payload), "%.2f", stack_voltage);
              id(mqtt_client).publish("${rs485_prefix}/stack/voltage", payload);
              id(last_stack_voltage) = stack_voltage;
            }

            if (id(last_stack_current) < 0 || fabsf(stack_current - id(last_stack_current)) >= 0.05f) {
              snprintf(payload, sizeof(payload), "%.2f", stack_current);
              id(mqtt_client).publish("${rs485_prefix}/stack/current", payload);
              id(last_stack_current) = stack_current;
            }

            // Stack temperatures with 0.2°C hysteresis
            if (stack_temp_min < 99.0f) {
              if (id(last_stack_temp_min) < -900.0f || fabsf(stack_temp_min - id(last_stack_temp_min)) >= 0.2f) {
                snprintf(payload, sizeof(payload), "%.1f", stack_temp_min);
                id(mqtt_client).publish("${rs485_prefix}/stack/temp_min", payload);
                id(last_stack_temp_min) = stack_temp_min;
              }
              if (id(last_stack_temp_max) < -900.0f || fabsf(stack_temp_max - id(last_stack_temp_max)) >= 0.2f) {
                snprintf(payload, sizeof(payload), "%.1f", stack_temp_max);
                id(mqtt_client).publish("${rs485_prefix}/stack/temp_max", payload);
                id(last_stack_temp_max) = stack_temp_max;
              }
            }

            // Balancing with change detection
            if (id(stack_balancing_count) != id(last_stack_balancing_count) ||
                id(stack_balancing_cells) != id(last_stack_balancing_cells)) {
              snprintf(payload, sizeof(payload), "%d", id(stack_balancing_count));
              id(mqtt_client).publish("${rs485_prefix}/stack/balancing_count", payload);
              id(mqtt_client).publish("${rs485_prefix}/stack/balancing_active",
                  id(stack_balancing_count) > 0 ? "1" : "0");
              id(mqtt_client).publish("${rs485_prefix}/stack/balancing_cells",
                  id(stack_balancing_cells).c_str());
              id(last_stack_balancing_count) = id(stack_balancing_count);
              id(last_stack_balancing_cells) = id(stack_balancing_cells);
            }

            // Overvolt with change detection
            if (id(stack_overvolt_count) != id(last_stack_overvolt_count) ||
                id(stack_overvolt_cells) != id(last_stack_overvolt_cells)) {
              snprintf(payload, sizeof(payload), "%d", id(stack_overvolt_count));
              id(mqtt_client).publish("${rs485_prefix}/stack/overvolt_count", payload);
              id(mqtt_client).publish("${rs485_prefix}/stack/overvolt_active",
                  id(stack_overvolt_count) > 0 ? "1" : "0");
              id(mqtt_client).publish("${rs485_prefix}/stack/overvolt_cells",
                  id(stack_overvolt_cells).c_str());
              id(last_stack_overvolt_count) = id(stack_overvolt_count);
              id(last_stack_overvolt_cells) = id(stack_overvolt_cells);
            }

            // Alarms with change detection
            if (id(stack_alarms) != id(last_stack_alarms)) {
              id(mqtt_client).publish("${rs485_prefix}/stack/alarms",
                  id(stack_alarms).empty() ? "" : id(stack_alarms).c_str());
              id(last_stack_alarms) = id(stack_alarms);
            }
          }

          ESP_LOGI("mqtt", "Published RS485 data for %d batteries", ${num_batteries});

# CAN sensors - publish to topics matching Python script
# Filters: publish every 60s OR immediately if value changes significantly
sensor:
  - platform: template
    id: sensor_soc
    name: "BMS SOC"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery"
    state_topic: ${can_prefix}/soc
    filters:
      - or:
        - heartbeat: 60s
        - delta: 1.0

  - platform: template
    id: sensor_soh
    name: "BMS SOH"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery-heart"
    state_topic: ${can_prefix}/soh
    filters:
      - or:
        - heartbeat: 60s
        - delta: 1.0

  - platform: template
    id: sensor_v_charge_max
    name: "BMS Charge Voltage Max"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    state_topic: ${can_prefix}/limit/v_charge_max
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.1

  - platform: template
    id: sensor_v_low
    name: "BMS Low Voltage Limit"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    state_topic: ${can_prefix}/limit/v_low
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.1

  - platform: template
    id: sensor_i_charge
    name: "BMS Charge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    state_topic: ${can_prefix}/limit/i_charge
    filters:
      - or:
        - heartbeat: 60s
        - delta: 1.0

  - platform: template
    id: sensor_i_discharge
    name: "BMS Discharge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    state_topic: ${can_prefix}/limit/i_discharge
    filters:
      - or:
        - heartbeat: 60s
        - delta: 1.0

  - platform: template
    id: sensor_cell_v_min
    name: "Cell Min Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    state_topic: ${can_prefix}/ext/cell_v_min
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.005

  - platform: template
    id: sensor_cell_v_max
    name: "Cell Max Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    state_topic: ${can_prefix}/ext/cell_v_max
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.005

  - platform: template
    id: sensor_cell_v_delta
    name: "Cell Delta Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    icon: "mdi:chart-bell-curve-cumulative"
    state_topic: ${can_prefix}/ext/cell_v_delta
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.010  # Increased from 0.002V (2mV) to 0.010V (10mV)

  - platform: template
    id: sensor_temp_min
    name: "Min Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    state_topic: ${can_prefix}/ext/temp_min
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.5

  - platform: template
    id: sensor_temp_max
    name: "Max Temperature"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    state_topic: ${can_prefix}/ext/temp_max
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.5

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: uptime
    name: "Uptime"

  - platform: template
    name: "Free Heap"
    id: sensor_free_heap
    unit_of_measurement: "bytes"
    icon: "mdi:memory"
    entity_category: diagnostic
    state_topic: ${can_prefix}/diag/free_heap
    update_interval: 60s
    lambda: 'return heap_caps_get_free_size(MALLOC_CAP_INTERNAL);'

  # CAN bus diagnostic counters
  - platform: template
    name: "CAN Frame Count"
    id: sensor_can_frame_count
    icon: "mdi:counter"
    entity_category: diagnostic
    update_interval: 60s  # Reduced from 10s to 60s
    lambda: 'return id(can_frame_count);'

  - platform: template
    name: "CAN Error Count"
    id: sensor_can_error_count
    icon: "mdi:alert-circle"
    entity_category: diagnostic
    update_interval: 60s  # Reduced from 10s to 60s
    lambda: 'return id(can_error_count);'

  # CAN 0x359 module count (byte 4) - shows number of active modules
  - platform: template
    name: "CAN Module Count"
    id: sensor_can_module_count
    icon: "mdi:battery-multiple"
    state_topic: ${can_prefix}/can/module_count
    update_interval: never  # Changed from 10s to never (on-change only)
    lambda: 'return id(can_module_count);'

  # CAN 0x359 status byte 7 (Shoto-specific diagnostic)
  - platform: template
    name: "CAN Status Byte 7"
    id: sensor_can_status_byte7
    icon: "mdi:information-outline"
    entity_category: diagnostic
    state_topic: ${can_prefix}/can/status_byte7
    update_interval: never  # Changed from 10s to never (on-change only)
    lambda: 'return id(can_status_byte7);'

text_sensor:
  - platform: template
    id: sensor_flags
    name: "BMS Flags"
    icon: "mdi:flag"
    state_topic: ${can_prefix}/flags

  - platform: template
    id: sensor_can_alarm_summary
    name: "CAN Alarm Summary"
    icon: "mdi:alert"
    state_topic: ${can_prefix}/can/alarm_summary
    update_interval: never  # Changed from 10s to never (on-change only)
    lambda: |-
      std::string alarms;
      // Protection flags (critical)
      if (id(can_prot_overvolt)) { if (!alarms.empty()) alarms += ","; alarms += "P:OV"; }
      if (id(can_prot_undervolt)) { if (!alarms.empty()) alarms += ","; alarms += "P:UV"; }
      if (id(can_prot_overtemp)) { if (!alarms.empty()) alarms += ","; alarms += "P:OT"; }
      if (id(can_prot_undertemp)) { if (!alarms.empty()) alarms += ","; alarms += "P:UT"; }
      if (id(can_prot_discharge_overcurrent)) { if (!alarms.empty()) alarms += ","; alarms += "P:DOC"; }
      if (id(can_prot_charge_overcurrent)) { if (!alarms.empty()) alarms += ","; alarms += "P:COC"; }
      if (id(can_prot_system_error)) { if (!alarms.empty()) alarms += ","; alarms += "P:SYS"; }
      // Warning flags
      if (id(can_warn_high_voltage)) { if (!alarms.empty()) alarms += ","; alarms += "W:HV"; }
      if (id(can_warn_low_voltage)) { if (!alarms.empty()) alarms += ","; alarms += "W:LV"; }
      if (id(can_warn_high_temp)) { if (!alarms.empty()) alarms += ","; alarms += "W:HT"; }
      if (id(can_warn_low_temp)) { if (!alarms.empty()) alarms += ","; alarms += "W:LT"; }
      if (id(can_warn_high_discharge_current)) { if (!alarms.empty()) alarms += ","; alarms += "W:HDI"; }
      if (id(can_warn_high_charge_current)) { if (!alarms.empty()) alarms += ","; alarms += "W:HCI"; }
      if (id(can_warn_comms_fail)) { if (!alarms.empty()) alarms += ","; alarms += "W:COMM"; }
      // Add module count if less than expected
      if (id(can_module_count) > 0 && id(can_module_count) < ${num_batteries}) {
        char buf[16];
        snprintf(buf, sizeof(buf), " [%d/%d mods]", id(can_module_count), ${num_batteries});
        alarms += buf;
      }
      id(can_alarm_summary) = alarms.empty() ? "OK" : alarms;
      return id(can_alarm_summary);

  - platform: template
    name: "Debug Logging Level"
    id: debug_level_sensor
    icon: "mdi:bug"
    lambda: 'return id(logger_level);'
    update_interval: never

  - platform: version
    name: "ESPHome Version"

binary_sensor:
  - platform: template
    name: "CAN Data Stale"
    lambda: 'return id(can_stale);'
    device_class: problem

  # MQTT connection status
  - platform: template
    name: "MQTT Connected"
    id: mqtt_connected
    icon: "mdi:cloud-check"
    lambda: 'return id(mqtt_client).is_connected();'

  # CAN charge/discharge control flags (from 0x35C)
  - platform: template
    name: "CAN Charge Enabled"
    id: bs_can_charge_enabled
    icon: "mdi:battery-charging"
    lambda: 'return id(can_charge_enabled);'

  - platform: template
    name: "CAN Discharge Enabled"
    id: bs_can_discharge_enabled
    icon: "mdi:battery-minus"
    lambda: 'return id(can_discharge_enabled);'

  - platform: template
    name: "CAN Force Charge Request"
    id: bs_can_force_charge
    icon: "mdi:battery-alert"
    lambda: 'return id(can_force_charge_request);'

  # Per-battery poll alarms (10 consecutive failures)
  - platform: template
    name: "Battery 0 Poll Alarm"
    device_class: problem
    state_topic: ${rs485_prefix}/battery0/poll_alarm
    lambda: 'return id(batt_poll_alarm).size() > 0 ? id(batt_poll_alarm)[0] : false;'

  - platform: template
    name: "Battery 1 Poll Alarm"
    device_class: problem
    state_topic: ${rs485_prefix}/battery1/poll_alarm
    lambda: 'return id(batt_poll_alarm).size() > 1 ? id(batt_poll_alarm)[1] : false;'

  - platform: template
    name: "Battery 2 Poll Alarm"
    device_class: problem
    state_topic: ${rs485_prefix}/battery2/poll_alarm
    lambda: 'return id(batt_poll_alarm).size() > 2 ? id(batt_poll_alarm)[2] : false;'

  # CAN 0x359 Protection flags (device_class: problem for alerts)
  - platform: template
    name: "CAN Protection Overvolt"
    id: bs_can_prot_overvolt
    device_class: problem
    icon: "mdi:flash-alert"
    lambda: 'return id(can_prot_overvolt);'

  - platform: template
    name: "CAN Protection Undervolt"
    id: bs_can_prot_undervolt
    device_class: problem
    icon: "mdi:flash-off"
    lambda: 'return id(can_prot_undervolt);'

  - platform: template
    name: "CAN Protection Overtemp"
    id: bs_can_prot_overtemp
    device_class: problem
    icon: "mdi:thermometer-alert"
    lambda: 'return id(can_prot_overtemp);'

  - platform: template
    name: "CAN Protection Undertemp"
    id: bs_can_prot_undertemp
    device_class: problem
    icon: "mdi:snowflake-alert"
    lambda: 'return id(can_prot_undertemp);'

  - platform: template
    name: "CAN Protection Discharge Overcurrent"
    id: bs_can_prot_discharge_oc
    device_class: problem
    icon: "mdi:current-dc"
    lambda: 'return id(can_prot_discharge_overcurrent);'

  - platform: template
    name: "CAN Protection Charge Overcurrent"
    id: bs_can_prot_charge_oc
    device_class: problem
    icon: "mdi:current-dc"
    lambda: 'return id(can_prot_charge_overcurrent);'

  - platform: template
    name: "CAN Protection System Error"
    id: bs_can_prot_system_error
    device_class: problem
    icon: "mdi:alert-circle"
    lambda: 'return id(can_prot_system_error);'

  # CAN 0x359 Warning flags
  - platform: template
    name: "CAN Warning High Voltage"
    id: bs_can_warn_high_volt
    icon: "mdi:flash"
    lambda: 'return id(can_warn_high_voltage);'

  - platform: template
    name: "CAN Warning Low Voltage"
    id: bs_can_warn_low_volt
    icon: "mdi:flash-outline"
    lambda: 'return id(can_warn_low_voltage);'

  - platform: template
    name: "CAN Warning High Temp"
    id: bs_can_warn_high_temp
    icon: "mdi:thermometer-high"
    lambda: 'return id(can_warn_high_temp);'

  - platform: template
    name: "CAN Warning Low Temp"
    id: bs_can_warn_low_temp
    icon: "mdi:thermometer-low"
    lambda: 'return id(can_warn_low_temp);'

  - platform: template
    name: "CAN Warning High Discharge Current"
    id: bs_can_warn_high_discharge
    icon: "mdi:current-dc"
    lambda: 'return id(can_warn_high_discharge_current);'

  - platform: template
    name: "CAN Warning High Charge Current"
    id: bs_can_warn_high_charge
    icon: "mdi:current-dc"
    lambda: 'return id(can_warn_high_charge_current);'

  - platform: template
    name: "CAN Warning Comms Fail"
    id: bs_can_warn_comms_fail
    device_class: problem
    icon: "mdi:lan-disconnect"
    lambda: 'return id(can_warn_comms_fail);'

button:
  - platform: restart
    name: "Restart"
  
  - platform: template
    name: "Toggle Debug Logging"
    id: debug_toggle_button
    on_press:
      - lambda: |-
          if (id(logger_level) == "DEBUG") {
            id(logger_level) = "WARN";
            ESP_LOGI("main", "Debug logging DISABLED (WARN level)");
            id(logger_level_global).set_log_level(ESPHOME_LOG_LEVEL_WARN);
          } else {
            id(logger_level) = "DEBUG";
            ESP_LOGI("main", "Debug logging ENABLED");
            id(logger_level_global).set_log_level(ESPHOME_LOG_LEVEL_DEBUG);
          }
          id(debug_level_sensor).publish_state(id(logger_level));
