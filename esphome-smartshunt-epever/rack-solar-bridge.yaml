# Rack Solar Bridge - Refactored with threshold-based publishing
# ESP32-S3 Waveshare board for SmartShunt (VE.Direct) + EPEVER MPPT (RS485)
# Uses helper functions from solar_helpers.h for threshold checking and pacing

substitutions:
  device_name: rack-solar-bridge
  friendly_name: "Rack Solar Bridge"
  mqtt_prefix: rack-solar
  version: "2026.2.0-refactored"
  hardware_model: "ESP32-S3 Waveshare"
  manufacturer: "ESPHome"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  min_version: 2026.1.0
  includes:
    - includes/solar_helpers.h
  on_boot:
    priority: -100
    then:
      - logger.log:
          format: "Rack Solar Bridge booting - Refactored version"
          level: INFO
      - lambda: |-
          id(discovery_sent) = false;
      - lambda: |-
          // Start with WARN level to reduce noise, can be toggled at runtime
          id(logger_level_global).set_log_level(ESPHOME_LOG_LEVEL_WARN);
          id(logger_level) = "WARN";

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Enable logging - compile with DEBUG support, but start at WARN level
logger:
  level: DEBUG
  id: logger_level_global
  baud_rate: 115200

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Enable fallback hotspot (captive portal)
  ap:
    ssid: "${device_name}-fallback"
    password: "fallback123"

captive_portal:

# Web server for debugging
web_server:
  port: 80

# MQTT configuration
mqtt:
  id: mqtt_client
  broker: !secret mqtt_host
  port: 1883
  username: !secret mqtt_user
  password: !secret mqtt_password
  
  # Device availability
  birth_message:
    topic: ${mqtt_prefix}/status
    payload: "online"
    retain: true
  will_message:
    topic: ${mqtt_prefix}/status
    payload: "offline"
    retain: true
  
  # Disable native discovery - we'll use custom HA Discovery
  discovery: false
  
  on_connect:
    - logger.log:
        format: "MQTT connected to broker"
        level: INFO
    - lambda: |-
        // Track availability transitions - publish only on state change
        if (!id(last_smartshunt_online)) {
          id(mqtt_client).publish(std::string("${mqtt_prefix}/smartshunt/status"), std::string("online"), (uint8_t)0, true);
          id(last_smartshunt_online) = true;
          ESP_LOGI("mqtt", "SmartShunt availability: online");
        }
        if (!id(last_epever_online)) {
          id(mqtt_client).publish(std::string("${mqtt_prefix}/epever/status"), std::string("online"), (uint8_t)0, true);
          id(last_epever_online) = true;
          ESP_LOGI("mqtt", "EPEVER availability: online");
        }
    - lambda: |-
        if (!id(discovery_sent)) {
          id(publish_discovery).execute();
          id(discovery_sent) = true;
        } else {
          ESP_LOGI("mqtt", "Discovery already sent this boot, skipping");
        }
    - lambda: |-
        // Force re-publish all sensor values on reconnect by resetting publish timestamps.
        // This prevents "Unknown" states in Home Assistant after MQTT broker restart.
        // The threshold helper functions will see (millis() - 0) >= heartbeat and publish immediately.
        ESP_LOGI("mqtt", "Resetting publish timestamps for re-publish on reconnect...");
        // SmartShunt sensors (19)
        id(last_ss_battery_voltage_publish) = 0;
        id(last_ss_battery_current_publish) = 0;
        id(last_ss_state_of_charge_publish) = 0;
        id(last_ss_instantaneous_power_publish) = 0;
        id(last_ss_battery_temperature_publish) = 0;
        id(last_ss_consumed_amp_hours_publish) = 0;
        id(last_ss_time_to_go_publish) = 0;
        id(last_ss_depth_deepest_discharge_publish) = 0;
        id(last_ss_depth_last_discharge_publish) = 0;
        id(last_ss_depth_average_discharge_publish) = 0;
        id(last_ss_number_charge_cycles_publish) = 0;
        id(last_ss_number_full_discharges_publish) = 0;
        id(last_ss_cumulative_amp_hours_publish) = 0;
        id(last_ss_min_battery_voltage_publish) = 0;
        id(last_ss_max_battery_voltage_publish) = 0;
        id(last_ss_last_full_charge_publish) = 0;
        id(last_ss_amount_discharged_energy_publish) = 0;
        id(last_ss_amount_charged_energy_publish) = 0;
        // EPEVER sensors (8)
        id(last_epever_solar_voltage_publish) = 0;
        id(last_epever_pv_current_publish) = 0;
        id(last_epever_solar_power_publish) = 0;
        id(last_epever_battery_capacity_publish) = 0;
        id(last_epever_device_temp_publish) = 0;
        id(last_epever_battery_voltage_publish) = 0;
        id(last_epever_battery_current_publish) = 0;
        id(last_epever_total_energy_publish) = 0;
        ESP_LOGI("mqtt", "Reset publish timestamps for re-publish on reconnect");
    - mqtt.publish:
        topic: ${mqtt_prefix}/info
        payload: "Rack Solar Bridge - Refactored version"
        retain: false

# OTA configuration
ota:
  - platform: esphome
    password: !secret ota_password

# =============================================================================
# HA Discovery publishing script
# =============================================================================

script:
  - id: publish_discovery
    mode: single
    then:
      - lambda: |-
          ESP_LOGI("mqtt", "Publishing HA Discovery configs for Rack Solar Bridge...");
          
           // Device info shared by all entities
          char device_payload[256];
          snprintf(device_payload, sizeof(device_payload),
            R"("device":{"identifiers":["rack_solar_bridge"],"name":"Rack Solar Bridge","model":"Waveshare ESP32-S3","manufacturer":"ESPHome"})");
          
          // Availability topics for subsystems
          char smartshunt_avail[128];
          snprintf(smartshunt_avail, sizeof(smartshunt_avail),
            R"("availability_topic":"${mqtt_prefix}/smartshunt/status","payload_available":"online","payload_not_available":"offline")");
          
          char epever_avail[128];
          snprintf(epever_avail, sizeof(epever_avail),
            R"("availability_topic":"${mqtt_prefix}/epever/status","payload_available":"online","payload_not_available":"offline")");
          
          char topic[160];
          char payload[768];
          int publish_count = 0;
          
          // Helper lambda: pace publishes (20 messages / 10ms delay)
          auto pace_publish = [&publish_count]() {
            publish_solar(publish_count);
          };
          
          // SmartShunt sensors (19 sensors)
          const char* smartshunt_sensors[][5] = {
            {"ss_battery_voltage", "SmartShunt Battery Voltage", "${mqtt_prefix}/smartshunt/battery_voltage", "V", "voltage"},
            {"ss_battery_current", "SmartShunt Battery Current", "${mqtt_prefix}/smartshunt/battery_current", "A", "current"},
            {"ss_state_of_charge", "SmartShunt State of Charge", "${mqtt_prefix}/smartshunt/state_of_charge", "%", "battery"},
            {"ss_instantaneous_power", "SmartShunt Power", "${mqtt_prefix}/smartshunt/instantaneous_power", "W", "power"},
            {"ss_battery_temperature", "SmartShunt Battery Temperature", "${mqtt_prefix}/smartshunt/battery_temperature", "째C", "temperature"},
            {"ss_consumed_amp_hours", "SmartShunt Consumed Ah", "${mqtt_prefix}/smartshunt/consumed_amp_hours", "Ah", ""},
            {"ss_time_to_go", "SmartShunt Time To Go", "${mqtt_prefix}/smartshunt/time_to_go", "min", ""},
            {"ss_depth_deepest_discharge", "SmartShunt Deepest Discharge", "${mqtt_prefix}/smartshunt/depth_deepest_discharge", "Ah", ""},
            {"ss_depth_last_discharge", "SmartShunt Last Discharge", "${mqtt_prefix}/smartshunt/depth_last_discharge", "Ah", ""},
            {"ss_depth_average_discharge", "SmartShunt Avg Discharge", "${mqtt_prefix}/smartshunt/depth_average_discharge", "Ah", ""},
            {"ss_number_charge_cycles", "SmartShunt Charge Cycles", "${mqtt_prefix}/smartshunt/number_charge_cycles", "", ""},
            {"ss_number_full_discharges", "SmartShunt Full Discharges", "${mqtt_prefix}/smartshunt/number_full_discharges", "", ""},
            {"ss_cumulative_amp_hours", "SmartShunt Cumulative Ah", "${mqtt_prefix}/smartshunt/cumulative_amp_hours", "Ah", ""},
            {"ss_min_battery_voltage", "SmartShunt Min Voltage", "${mqtt_prefix}/smartshunt/min_battery_voltage", "V", "voltage"},
            {"ss_max_battery_voltage", "SmartShunt Max Voltage", "${mqtt_prefix}/smartshunt/max_battery_voltage", "V", "voltage"},
            {"ss_last_full_charge", "SmartShunt Last Full Charge", "${mqtt_prefix}/smartshunt/last_full_charge", "min", ""},
            {"ss_amount_discharged_energy", "SmartShunt Discharged Energy", "${mqtt_prefix}/smartshunt/amount_discharged_energy", "Wh", "energy"},
            {"ss_amount_charged_energy", "SmartShunt Charged Energy", "${mqtt_prefix}/smartshunt/amount_charged_energy", "Wh", "energy"},
          };
          
          for (int i = 0; i < 19; i++) {
            snprintf(topic, sizeof(topic), "homeassistant/sensor/rack_solar/%s/config", smartshunt_sensors[i][0]);
            bool ok = false;
            if (strlen(smartshunt_sensors[i][3]) > 0 && strlen(smartshunt_sensors[i][4]) > 0) {
              ok = snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"rack_solar_%s","unit_of_measurement":"%s","device_class":"%s","state_class":"measurement",%s,%s})",
                smartshunt_sensors[i][1], smartshunt_sensors[i][2], smartshunt_sensors[i][0], 
                smartshunt_sensors[i][3], smartshunt_sensors[i][4], smartshunt_avail, device_payload) > 0;
            } else if (strlen(smartshunt_sensors[i][3]) > 0) {
              ok = snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"rack_solar_%s","unit_of_measurement":"%s","state_class":"measurement",%s,%s})",
                smartshunt_sensors[i][1], smartshunt_sensors[i][2], smartshunt_sensors[i][0], 
                smartshunt_sensors[i][3], smartshunt_avail, device_payload) > 0;
            } else {
              ok = snprintf(payload, sizeof(payload),
                R"({"name":"%s","state_topic":"%s","unique_id":"rack_solar_%s",%s,%s})",
                smartshunt_sensors[i][1], smartshunt_sensors[i][2], smartshunt_sensors[i][0], 
                smartshunt_avail, device_payload) > 0;
            }
            if (ok) {
              id(mqtt_client).publish(std::string(topic), std::string(payload), 0, true);
              pace_publish();
            }
          }
          
          // EPEVER sensors (8 sensors)
          const char* epever_sensors[][5] = {
            {"epever_solar_voltage", "EPEVER Solar Voltage", "${mqtt_prefix}/epever/solar_voltage", "V", "voltage"},
            {"epever_pv_current", "EPEVER PV Current", "${mqtt_prefix}/epever/pv_current", "A", "current"},
            {"epever_solar_power", "EPEVER Solar Power", "${mqtt_prefix}/epever/solar_power", "W", "power"},
            {"epever_battery_capacity", "EPEVER Battery Capacity", "${mqtt_prefix}/epever/battery_capacity", "%", "battery"},
            {"epever_device_temp", "EPEVER Device Temperature", "${mqtt_prefix}/epever/device_temp", "째C", "temperature"},
            {"epever_battery_voltage", "EPEVER Battery Voltage", "${mqtt_prefix}/epever/battery_voltage", "V", "voltage"},
            {"epever_battery_current", "EPEVER Battery Current", "${mqtt_prefix}/epever/battery_current", "A", "current"},
            {"epever_total_energy", "EPEVER Total Energy", "${mqtt_prefix}/epever/total_energy", "kWh", "energy"},
          };
          
          for (int i = 0; i < 8; i++) {
            snprintf(topic, sizeof(topic), "homeassistant/sensor/rack_solar/%s/config", epever_sensors[i][0]);
            bool ok = snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"rack_solar_%s","unit_of_measurement":"%s","device_class":"%s","state_class":"measurement",%s,%s})",
              epever_sensors[i][1], epever_sensors[i][2], epever_sensors[i][0], 
              epever_sensors[i][3], epever_sensors[i][4], epever_avail, device_payload) > 0;
            if (ok) {
              id(mqtt_client).publish(std::string(topic), std::string(payload), 0, true);
              pace_publish();
            }
          }
          
          // SmartShunt text sensors (7 sensors)
          const char* smartshunt_text_sensors[][3] = {
            {"ss_model_description", "SmartShunt Model", "${mqtt_prefix}/smartshunt/model_description"},
            {"ss_firmware_version", "SmartShunt Firmware", "${mqtt_prefix}/smartshunt/firmware_version"},
            {"ss_device_type", "SmartShunt Device Type", "${mqtt_prefix}/smartshunt/device_type"},
            {"ss_serial_number", "SmartShunt Serial", "${mqtt_prefix}/smartshunt/serial_number"},
            {"ss_dc_monitor_mode", "SmartShunt Monitor Mode", "${mqtt_prefix}/smartshunt/dc_monitor_mode"},
            {"ss_alarm_condition", "SmartShunt Alarm Condition", "${mqtt_prefix}/smartshunt/alarm_condition"},
            {"ss_alarm_reason", "SmartShunt Alarm Reason", "${mqtt_prefix}/smartshunt/alarm_reason"},
          };
          
          for (int i = 0; i < 7; i++) {
            snprintf(topic, sizeof(topic), "homeassistant/sensor/rack_solar/%s/config", smartshunt_text_sensors[i][0]);
            if (snprintf(payload, sizeof(payload),
              R"({"name":"%s","state_topic":"%s","unique_id":"rack_solar_%s",%s,%s})",
              smartshunt_text_sensors[i][1], smartshunt_text_sensors[i][2], smartshunt_text_sensors[i][0], 
              smartshunt_avail, device_payload) > 0) {
              id(mqtt_client).publish(std::string(topic), std::string(payload), 0, true);
              pace_publish();
            }
          }
          
          // SmartShunt binary sensor (relay_state)
          snprintf(topic, sizeof(topic), "homeassistant/binary_sensor/rack_solar/ss_relay_state/config");
          if (snprintf(payload, sizeof(payload),
            R"({"name":"SmartShunt Relay State","state_topic":"${mqtt_prefix}/smartshunt/relay_state","unique_id":"rack_solar_ss_relay_state","payload_on":"ON","payload_off":"OFF",%s,%s})",
            smartshunt_avail, device_payload) > 0) {
            id(mqtt_client).publish(std::string(topic), std::string(payload), 0, true);
            pace_publish();
          }
          
          ESP_LOGI("mqtt", "Published %d discovery configs", publish_count);

# =============================================================================
# HARDWARE INTERFACES
# =============================================================================

# UART interfaces (VE.Direct + RS485)
uart:
  - id: vedirect_uart
    rx_pin: GPIO4
    baud_rate: 19200
    rx_buffer_size: 1024
  
  - id: rs485_uart
    tx_pin: GPIO17
    rx_pin: GPIO18
    baud_rate: 115200
    data_bits: 8
    stop_bits: 1
    parity: NONE
    flow_control_pin: GPIO21
    rx_buffer_size: 1024

# External component for Victron (SmartShunt)
external_components:
  - source: github://KinDR007/VictronMPPT-ESPHOME@main
    refresh: 0s

# Victron component - 1s throttle (kept as-is)
victron:
  uart_id: vedirect_uart
  id: smartshunt
  throttle: 1s

# Internal victron text sensors (receive data from SmartShunt)
text_sensor:
  - platform: victron
    victron_id: smartshunt
    model_description:
      id: ss_model_description_internal
      on_value:
        then:
          - lambda: "if (!x.empty()) id(ss_model_description_val) = x;"
    firmware_version:
      id: ss_firmware_version_internal
      on_value:
        then:
          - lambda: "if (!x.empty()) id(ss_firmware_version_val) = x;"
    device_type:
      id: ss_device_type_internal
      on_value:
        then:
          - lambda: "if (!x.empty()) id(ss_device_type_val) = x;"
    serial_number:
      id: ss_serial_number_internal
      on_value:
        then:
          - lambda: "if (!x.empty()) id(ss_serial_number_val) = x;"
    dc_monitor_mode:
      id: ss_dc_monitor_mode_internal
      on_value:
        then:
          - lambda: "if (!x.empty()) id(ss_dc_monitor_mode_val) = x;"
    alarm_condition_active:
      id: ss_alarm_condition_internal
      on_value:
        then:
          - lambda: "if (!x.empty()) id(ss_alarm_condition_val) = x;"
    alarm_reason:
      id: ss_alarm_reason_internal
      on_value:
        then:
          - lambda: "if (!x.empty()) id(ss_alarm_reason_val) = x;"

  # Template text sensors for MQTT/HA (update_interval: never - manual updates only)
  - platform: template
    name: "SmartShunt Model"
    id: ss_model_description
    icon: "mdi:information"
    update_interval: never
    lambda: return id(ss_model_description_val);

  - platform: template
    name: "SmartShunt Firmware"
    id: ss_firmware_version
    icon: "mdi:information"
    update_interval: never
    lambda: return id(ss_firmware_version_val);

  - platform: template
    name: "SmartShunt Device Type"
    id: ss_device_type
    icon: "mdi:information"
    update_interval: never
    lambda: return id(ss_device_type_val);

  - platform: template
    name: "SmartShunt Serial"
    id: ss_serial_number
    icon: "mdi:numeric"
    update_interval: never
    lambda: return id(ss_serial_number_val);

  - platform: template
    name: "SmartShunt Monitor Mode"
    id: ss_dc_monitor_mode
    icon: "mdi:cog"
    update_interval: never
    lambda: return id(ss_dc_monitor_mode_val);

  - platform: template
    name: "SmartShunt Alarm Condition"
    id: ss_alarm_condition
    icon: "mdi:alert"
    update_interval: never
    lambda: return id(ss_alarm_condition_val);

  - platform: template
    name: "SmartShunt Alarm Reason"
    id: ss_alarm_reason
    icon: "mdi:alert-circle"
    update_interval: never
    lambda: return id(ss_alarm_reason_val);

  # Debug level indicator for runtime log toggle
  - platform: template
    name: "Debug Level"
    id: debug_level_sensor
    icon: "mdi:console"
    update_interval: never
    lambda: return id(logger_level);

# Internal binary sensor (receive from SmartShunt) + Template for MQTT/HA
binary_sensor:
  - platform: victron
    victron_id: smartshunt
    relay_state:
      id: ss_relay_state_internal
      on_state:
        then:
          - lambda: "id(ss_relay_state_val) = x;"

  - platform: template
    name: "SmartShunt Relay State"
    id: ss_relay_state
    device_class: power
    lambda: return id(ss_relay_state_val);

# Modbus controller for EPEVER - 30s update_interval (kept as-is)
modbus:
  id: modbus1
  uart_id: rs485_uart

modbus_controller:
  - id: epever
    address: 0x1
    modbus_id: modbus1
    command_throttle: 0ms
    update_interval: 30s

# =============================================================================
# SENSORS - Raw sensors from platforms + Template sensors for publishing
# =============================================================================

sensor:
  # Uptime sensor for basic monitoring
  - platform: uptime
    name: "Uptime"
    id: uptime_sensor
    update_interval: 60s

  # WiFi signal strength
  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_db
    update_interval: 60s
    unit_of_measurement: "dBm"
    device_class: signal_strength

  # Free heap for diagnostics
  - platform: template
    name: "Free Heap"
    id: free_heap_sensor
    unit_of_measurement: "bytes"
    lambda: return heap_caps_get_free_size(MALLOC_CAP_8BIT);
    update_interval: 30s
    entity_category: diagnostic

  # ============================================================
  # SMARTSHUNT SENSORS (victron platform with direct MQTT publishing)
  # ============================================================
  - platform: victron
    victron_id: smartshunt
    battery_voltage:
      name: "SmartShunt Battery Voltage"
      id: ss_battery_voltage
      internal: true
      unit_of_measurement: "V"
      device_class: voltage
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              if (check_threshold_float(x, id(last_ss_battery_voltage),
                                         id(last_ss_battery_voltage_publish),
                                         0.1f, 15.0f, 30.0f)) {
                static char val[16];
                snprintf(val, sizeof(val), "%.2f", x);
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/battery_voltage", val);
              }
    battery_current:
      name: "SmartShunt Battery Current"
      id: ss_battery_current
      internal: true
      unit_of_measurement: "A"
      device_class: current
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              if (check_threshold_float(x, id(last_ss_battery_current),
                                         id(last_ss_battery_current_publish),
                                         0.1f, -500.0f, 500.0f)) {
                static char val[16];
                snprintf(val, sizeof(val), "%.2f", x);
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/battery_current", val);
              }
    state_of_charge:
      name: "SmartShunt State of Charge"
      id: ss_state_of_charge
      internal: true
      unit_of_measurement: "%"
      device_class: battery
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              int val = (int) roundf(x);
              if (val < 0 || val > 100) return;
              if (check_threshold_int(val, id(last_ss_state_of_charge),
                                      id(last_ss_state_of_charge_publish), 1)) {
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/state_of_charge", to_string(val));
              }
    instantaneous_power:
      name: "SmartShunt Power"
      id: ss_instantaneous_power
      internal: true
      unit_of_measurement: "W"
      device_class: power
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              if (check_threshold_float(x, id(last_ss_instantaneous_power),
                                         id(last_ss_instantaneous_power_publish),
                                         1.0f, -10000.0f, 10000.0f)) {
                static char val[16];
                snprintf(val, sizeof(val), "%.0f", x);  // Whole watts
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/instantaneous_power", val);
              }
    battery_temperature:
      name: "SmartShunt Battery Temperature"
      id: ss_battery_temperature
      internal: true
      unit_of_measurement: "째C"
      device_class: temperature
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              if (check_threshold_float(x, id(last_ss_battery_temperature),
                                         id(last_ss_battery_temperature_publish),
                                         0.5f, -40.0f, 100.0f)) {
                static char val[16];
                snprintf(val, sizeof(val), "%.1f", x);
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/battery_temperature", val);
              }
    consumed_amp_hours:
      name: "SmartShunt Consumed Ah"
      id: ss_consumed_amp_hours
      internal: true
      unit_of_measurement: "Ah"
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              // Cumulative counter - use 1.0 Ah threshold to update on whole numbers only
              if (check_threshold_float(x, id(last_ss_consumed_amp_hours),
                                         id(last_ss_consumed_amp_hours_publish),
                                         1.0f, -999999.0f, 999999.0f)) {
                static char val[16];
                snprintf(val, sizeof(val), "%.0f", x);  // Whole Ah
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/consumed_amp_hours", val);
              }
    time_to_go:
      name: "SmartShunt Time To Go"
      id: ss_time_to_go
      internal: true
      unit_of_measurement: "min"
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              int val = (int) roundf(x);
              if (check_threshold_int(val, id(last_ss_time_to_go),
                                      id(last_ss_time_to_go_publish), 1)) {
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/time_to_go", to_string(val));
              }
    depth_of_the_deepest_discharge:
      name: "SmartShunt Deepest Discharge"
      id: ss_depth_deepest_discharge
      internal: true
      unit_of_measurement: "Ah"
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              if (check_threshold_float(x, id(last_ss_depth_deepest_discharge),
                                         id(last_ss_depth_deepest_discharge_publish),
                                         0.1f, 0.0f, 999999.0f)) {
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/depth_deepest_discharge", to_string(x));
              }
    depth_of_the_last_discharge:
      name: "SmartShunt Last Discharge"
      id: ss_depth_last_discharge
      internal: true
      unit_of_measurement: "Ah"
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              if (check_threshold_float(x, id(last_ss_depth_last_discharge),
                                         id(last_ss_depth_last_discharge_publish),
                                         0.1f, 0.0f, 999999.0f)) {
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/depth_last_discharge", to_string(x));
              }
    depth_of_the_average_discharge:
      name: "SmartShunt Avg Discharge"
      id: ss_depth_average_discharge
      internal: true
      unit_of_measurement: "Ah"
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              // Historical average - rarely changes
              if (check_threshold_float(x, id(last_ss_depth_average_discharge),
                                         id(last_ss_depth_average_discharge_publish),
                                         1.0f, 0.0f, 999999.0f, 300000)) {  // 1.0Ah threshold, 5min heartbeat
                static char val[16];
                snprintf(val, sizeof(val), "%.1f", x);
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/depth_average_discharge", val);
              }
    number_of_charge_cycles:
      name: "SmartShunt Charge Cycles"
      id: ss_number_charge_cycles
      internal: true
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              int val = (int) roundf(x);
              if (val < 0 || val > 999999) return;
              if (check_threshold_int(val, id(last_ss_number_charge_cycles),
                                      id(last_ss_number_charge_cycles_publish), 1)) {
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/number_charge_cycles", to_string(val));
              }
    number_of_full_discharges:
      name: "SmartShunt Full Discharges"
      id: ss_number_full_discharges
      internal: true
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              int val = (int) roundf(x);
              if (val < 0 || val > 999999) return;
              if (check_threshold_int(val, id(last_ss_number_full_discharges),
                                      id(last_ss_number_full_discharges_publish), 1)) {
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/number_full_discharges", to_string(val));
              }
    cumulative_amp_hours_drawn:
      name: "SmartShunt Cumulative Ah"
      id: ss_cumulative_amp_hours
      internal: true  # Only publish via custom MQTT with hysteresis
      unit_of_measurement: "Ah"
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              // Cumulative counter - use 1.0 Ah threshold to update on whole numbers only
              float last_val = id(last_ss_cumulative_amp_hours);
              uint32_t last_pub = id(last_ss_cumulative_amp_hours_publish);
              uint32_t now = millis();
              bool should_pub = check_threshold_float(x, id(last_ss_cumulative_amp_hours),
                                         id(last_ss_cumulative_amp_hours_publish),
                                         1.0f, 0.0f, 999999.0f);
              if (should_pub) {
                static char val[16];
                snprintf(val, sizeof(val), "%.0f", x);
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/cumulative_amp_hours", val);
                ESP_LOGI("hysteresis", "cumulative_ah PUBLISH: x=%.3f, last=%.3f, diff=%.3f, last_pub=%u, now=%u, elapsed=%u",
                         x, last_val, fabs(x - last_val), last_pub, now, now - last_pub);
              } else {
                ESP_LOGD("hysteresis", "cumulative_ah SKIP: x=%.3f, last=%.3f, diff=%.3f",
                         x, last_val, fabs(x - last_val));
              }
    min_battery_voltage:
      name: "SmartShunt Min Voltage"
      id: ss_min_battery_voltage
      internal: true
      unit_of_measurement: "V"
      device_class: voltage
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              // Historical min - only changes when new min recorded
              if (check_threshold_float(x, id(last_ss_min_battery_voltage),
                                         id(last_ss_min_battery_voltage_publish),
                                         0.5f, 15.0f, 30.0f, 300000)) {  // 0.5V threshold, 5min heartbeat
                static char val[16];
                snprintf(val, sizeof(val), "%.2f", x);
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/min_battery_voltage", val);
              }
    max_battery_voltage:
      name: "SmartShunt Max Voltage"
      id: ss_max_battery_voltage
      internal: true
      unit_of_measurement: "V"
      device_class: voltage
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              // Historical max - only changes when new max recorded
              // Use larger threshold since it should only change occasionally
              if (check_threshold_float(x, id(last_ss_max_battery_voltage),
                                         id(last_ss_max_battery_voltage_publish),
                                         0.5f, 15.0f, 30.0f, 300000)) {  // 0.5V threshold, 5min heartbeat
                static char val[16];
                snprintf(val, sizeof(val), "%.2f", x);
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/max_battery_voltage", val);
                ESP_LOGD("mqtt", "Published max_voltage: %.2f (last: %.2f)", x, id(last_ss_max_battery_voltage));
              }
    last_full_charge:
      name: "SmartShunt Last Full Charge"
      id: ss_last_full_charge
      internal: true
      unit_of_measurement: "min"
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              int val = (int) roundf(x);
              if (check_threshold_int(val, id(last_ss_last_full_charge),
                                      id(last_ss_last_full_charge_publish), 1)) {
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/last_full_charge", to_string(val));
              }
    amount_of_discharged_energy:
      name: "SmartShunt Discharged Energy"
      id: ss_amount_discharged_energy
      internal: true
      unit_of_measurement: "Wh"
      device_class: energy
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              // Cumulative energy counter - use 10 Wh threshold for whole tens
              if (check_threshold_float(x, id(last_ss_amount_discharged_energy),
                                         id(last_ss_amount_discharged_energy_publish),
                                         10.0f, 0.0f, 999999.0f)) {
                static char val[16];
                snprintf(val, sizeof(val), "%.0f", x);  // Whole Wh
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/amount_discharged_energy", val);
              }
    amount_of_charged_energy:
      name: "SmartShunt Charged Energy"
      id: ss_amount_charged_energy
      internal: true
      unit_of_measurement: "Wh"
      device_class: energy
      state_class: measurement
      on_value:
        then:
          - lambda: |-
              // Cumulative energy counter - use 10 Wh threshold for whole tens
              if (check_threshold_float(x, id(last_ss_amount_charged_energy),
                                         id(last_ss_amount_charged_energy_publish),
                                         10.0f, 0.0f, 999999.0f)) {
                static char val[16];
                snprintf(val, sizeof(val), "%.0f", x);  // Whole Wh
                id(mqtt_client).publish("${mqtt_prefix}/smartshunt/amount_charged_energy", val);
              }

  # ============================================================
  # EPEVER SENSORS (modbus_controller with direct MQTT publishing)
  # ============================================================
  - platform: modbus_controller
    modbus_controller_id: epever
    name: "EPEVER Solar Voltage"
    id: epever_solar_voltage
    register_type: read
    address: 12544
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    filters:
      - multiply: 0.01
    on_value:
      then:
        - lambda: |-
            if (check_threshold_float(x, id(last_epever_solar_voltage),
                                       id(last_epever_solar_voltage_publish),
                                       0.1f, 0.0f, 100.0f)) {
              id(mqtt_client).publish("${mqtt_prefix}/epever/solar_voltage", to_string(x));
            }

  - platform: modbus_controller
    modbus_controller_id: epever
    name: "EPEVER PV Current"
    id: epever_pv_current
    register_type: read
    address: 12545
    value_type: U_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    filters:
      - multiply: 0.01
    on_value:
      then:
        - lambda: |-
            if (check_threshold_float(x, id(last_epever_pv_current),
                                       id(last_epever_pv_current_publish),
                                       0.1f, 0.0f, 100.0f)) {
              id(mqtt_client).publish("${mqtt_prefix}/epever/pv_current", to_string(x));
            }

  - platform: modbus_controller
    modbus_controller_id: epever
    name: "EPEVER Solar Power"
    id: epever_solar_power
    register_type: read
    address: 12546
    value_type: U_DWORD_R
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    filters:
      - multiply: 0.01
    on_value:
      then:
        - lambda: |-
            if (check_threshold_float(x, id(last_epever_solar_power),
                                       id(last_epever_solar_power_publish),
                                       1.0f, 0.0f, 10000.0f)) {
              id(mqtt_client).publish("${mqtt_prefix}/epever/solar_power", to_string(x));
            }

  - platform: modbus_controller
    modbus_controller_id: epever
    name: "EPEVER Battery Capacity"
    id: epever_battery_capacity
    register_type: read
    address: 12570
    value_type: U_WORD
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    on_value:
      then:
        - lambda: |-
            int val = (int) roundf(x);
            if (val < 0 || val > 100) return;
            if (check_threshold_int(val, id(last_epever_battery_capacity),
                                    id(last_epever_battery_capacity_publish), 1)) {
              id(mqtt_client).publish("${mqtt_prefix}/epever/battery_capacity", to_string(val));
            }

  - platform: modbus_controller
    modbus_controller_id: epever
    name: "EPEVER Device Temperature"
    id: epever_device_temp
    register_type: read
    address: 12561
    value_type: S_WORD
    unit_of_measurement: "째C"
    device_class: temperature
    state_class: measurement
    filters:
      - multiply: 0.01
    on_value:
      then:
        - lambda: |-
            if (check_threshold_float(x, id(last_epever_device_temp),
                                       id(last_epever_device_temp_publish),
                                       0.5f, -40.0f, 100.0f)) {
              id(mqtt_client).publish("${mqtt_prefix}/epever/device_temp", to_string(x));
            }

  - platform: modbus_controller
    modbus_controller_id: epever
    name: "EPEVER Battery Voltage"
    id: epever_battery_voltage
    register_type: read
    address: 13082
    value_type: U_WORD
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    filters:
      - multiply: 0.01
    on_value:
      then:
        - lambda: |-
            if (check_threshold_float(x, id(last_epever_battery_voltage),
                                       id(last_epever_battery_voltage_publish),
                                       0.1f, 15.0f, 30.0f)) {
              id(mqtt_client).publish("${mqtt_prefix}/epever/battery_voltage", to_string(x));
            }

  - platform: modbus_controller
    modbus_controller_id: epever
    name: "EPEVER Battery Current"
    id: epever_battery_current
    register_type: read
    address: 13083
    value_type: U_WORD
    unit_of_measurement: "A"
    device_class: current
    state_class: measurement
    filters:
      - multiply: 0.01
    on_value:
      then:
        - lambda: |-
            if (check_threshold_float(x, id(last_epever_battery_current),
                                       id(last_epever_battery_current_publish),
                                       0.1f, -100.0f, 100.0f)) {
              id(mqtt_client).publish("${mqtt_prefix}/epever/battery_current", to_string(x));
            }

  - platform: modbus_controller
    modbus_controller_id: epever
    name: "EPEVER Total Energy"
    id: epever_total_energy
    register_type: read
    address: 13074
    value_type: U_DWORD_R
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    filters:
      - multiply: 0.01
    on_value:
      then:
        - lambda: |-
            if (check_threshold_float(x, id(last_epever_total_energy),
                                       id(last_epever_total_energy_publish),
                                       0.1f, 0.0f, 999999.0f)) {
              id(mqtt_client).publish("${mqtt_prefix}/epever/total_energy", to_string(x));
            }



# =============================================================================
# GLOBALS - 54 variables for hysteresis tracking
# =============================================================================

globals:
  # HA Discovery tracking
  - id: discovery_sent
    type: bool
    initial_value: 'false'
    restore_value: false

  # Logger level tracking for runtime toggle
  - id: logger_level
    type: std::string
    initial_value: '"WARN"'
    restore_value: false

  # Availability tracking - publish only on transitions
  - id: last_smartshunt_online
    type: bool
    initial_value: 'false'
  - id: last_epever_online
    type: bool
    initial_value: 'false'
  - id: last_availability_heartbeat
    type: uint32_t
    initial_value: '0'

  # ============================================================
  # SMARTSHUNT SENSOR VALUES (19 sensors * 2 each = 38: value + timestamp)
  # ============================================================
  - id: last_ss_battery_voltage
    type: float
    initial_value: '-1.0'
  - id: last_ss_battery_voltage_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_battery_current
    type: float
    initial_value: '-999.0'
  - id: last_ss_battery_current_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_state_of_charge
    type: int
    initial_value: '-1'
  - id: last_ss_state_of_charge_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_instantaneous_power
    type: float
    initial_value: '-1.0'
  - id: last_ss_instantaneous_power_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_battery_temperature
    type: float
    initial_value: '-999.0'
  - id: last_ss_battery_temperature_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_consumed_amp_hours
    type: float
    initial_value: '-999.0'
  - id: last_ss_consumed_amp_hours_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_time_to_go
    type: int
    initial_value: '-1'
  - id: last_ss_time_to_go_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_depth_deepest_discharge
    type: float
    initial_value: '-1.0'
  - id: last_ss_depth_deepest_discharge_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_depth_last_discharge
    type: float
    initial_value: '-1.0'
  - id: last_ss_depth_last_discharge_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_depth_average_discharge
    type: float
    initial_value: '-1.0'
  - id: last_ss_depth_average_discharge_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_number_charge_cycles
    type: int
    initial_value: '-1'
  - id: last_ss_number_charge_cycles_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_number_full_discharges
    type: int
    initial_value: '-1'
  - id: last_ss_number_full_discharges_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_cumulative_amp_hours
    type: float
    initial_value: '-999.0'
  - id: last_ss_cumulative_amp_hours_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_min_battery_voltage
    type: float
    initial_value: '-1.0'
  - id: last_ss_min_battery_voltage_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_max_battery_voltage
    type: float
    initial_value: '-1.0'
  - id: last_ss_max_battery_voltage_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_last_full_charge
    type: int
    initial_value: '-1'
  - id: last_ss_last_full_charge_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_amount_discharged_energy
    type: float
    initial_value: '-1.0'
  - id: last_ss_amount_discharged_energy_publish
    type: uint32_t
    initial_value: '0'
  - id: last_ss_amount_charged_energy
    type: float
    initial_value: '-1.0'
  - id: last_ss_amount_charged_energy_publish
    type: uint32_t
    initial_value: '0'

  # ============================================================
  # EPEVER SENSOR VALUES (8 sensors * 2 each = 16: value + timestamp)
  # ============================================================
  - id: last_epever_solar_voltage
    type: float
    initial_value: '-1.0'
  - id: last_epever_solar_voltage_publish
    type: uint32_t
    initial_value: '0'
  - id: last_epever_pv_current
    type: float
    initial_value: '-1.0'
  - id: last_epever_pv_current_publish
    type: uint32_t
    initial_value: '0'
  - id: last_epever_solar_power
    type: float
    initial_value: '-1.0'
  - id: last_epever_solar_power_publish
    type: uint32_t
    initial_value: '0'
  - id: last_epever_battery_capacity
    type: int
    initial_value: '-1'
  - id: last_epever_battery_capacity_publish
    type: uint32_t
    initial_value: '0'
  - id: last_epever_device_temp
    type: float
    initial_value: '-999.0'
  - id: last_epever_device_temp_publish
    type: uint32_t
    initial_value: '0'
  - id: last_epever_battery_voltage
    type: float
    initial_value: '-1.0'
  - id: last_epever_battery_voltage_publish
    type: uint32_t
    initial_value: '0'
  - id: last_epever_battery_current
    type: float
    initial_value: '-1.0'
  - id: last_epever_battery_current_publish
    type: uint32_t
    initial_value: '0'
  - id: last_epever_total_energy
    type: float
    initial_value: '-1.0'
  - id: last_epever_total_energy_publish
    type: uint32_t
    initial_value: '0'

  # ============================================================
  # TEXT SENSOR VALUES (current state from SmartShunt)
  # ============================================================
  - id: ss_model_description_val
    type: std::string
    initial_value: '""'
  - id: ss_firmware_version_val
    type: std::string
    initial_value: '""'
  - id: ss_device_type_val
    type: std::string
    initial_value: '""'
  - id: ss_serial_number_val
    type: std::string
    initial_value: '""'
  - id: ss_dc_monitor_mode_val
    type: std::string
    initial_value: '""'
  - id: ss_alarm_condition_val
    type: std::string
    initial_value: '""'
  - id: ss_alarm_reason_val
    type: std::string
    initial_value: '""'

  # ============================================================
  # TEXT SENSOR LAST PUBLISHED VALUES (for change detection)
  # ============================================================
  - id: last_ss_model_description
    type: std::string
    initial_value: '"UNINITIALIZED"'
  - id: last_ss_firmware_version
    type: std::string
    initial_value: '"UNINITIALIZED"'
  - id: last_ss_device_type
    type: std::string
    initial_value: '"UNINITIALIZED"'
  - id: last_ss_serial_number
    type: std::string
    initial_value: '"UNINITIALIZED"'
  - id: last_ss_dc_monitor_mode
    type: std::string
    initial_value: '"UNINITIALIZED"'
  - id: last_ss_alarm_condition
    type: std::string
    initial_value: '"UNINITIALIZED"'
  - id: last_ss_alarm_reason
    type: std::string
    initial_value: '"UNINITIALIZED"'

  # ============================================================
  # BINARY SENSOR VALUES
  # ============================================================
  - id: ss_relay_state_val
    type: bool
    initial_value: 'false'
  - id: last_ss_relay_state
    type: int
    initial_value: '-1'

# =============================================================================
# INTERVAL-BASED PUBLISHING FOR TEXT/BINARY SENSORS
# Publishes to MQTT only when values change (following deye-bms-can.yaml pattern)
# =============================================================================

interval:
  - interval: 5s
    then:
      - lambda: |-
          // Helper lambda to publish text sensor with change detection
          auto publish_text = [&](const char* topic, 
                                  const std::string& current_val, 
                                  std::string& last_val,
                                  esphome::text_sensor::TextSensor* sensor) {
            if (current_val != last_val) {
              // Publish to MQTT
              id(mqtt_client).publish(topic, current_val.c_str());
              // Update entity state for HA
              sensor->publish_state(current_val);
              // Track last published value
              last_val = current_val;
            }
          };
          
          // Publish all 7 text sensors
          publish_text("${mqtt_prefix}/smartshunt/model_description",
                       id(ss_model_description_val),
                       id(last_ss_model_description),
                       id(ss_model_description));
          
          publish_text("${mqtt_prefix}/smartshunt/firmware_version",
                       id(ss_firmware_version_val),
                       id(last_ss_firmware_version),
                       id(ss_firmware_version));
          
          publish_text("${mqtt_prefix}/smartshunt/device_type",
                       id(ss_device_type_val),
                       id(last_ss_device_type),
                       id(ss_device_type));
          
          publish_text("${mqtt_prefix}/smartshunt/serial_number",
                       id(ss_serial_number_val),
                       id(last_ss_serial_number),
                       id(ss_serial_number));
          
          publish_text("${mqtt_prefix}/smartshunt/dc_monitor_mode",
                       id(ss_dc_monitor_mode_val),
                       id(last_ss_dc_monitor_mode),
                       id(ss_dc_monitor_mode));
          
          publish_text("${mqtt_prefix}/smartshunt/alarm_condition",
                       id(ss_alarm_condition_val),
                       id(last_ss_alarm_condition),
                       id(ss_alarm_condition));
          
          publish_text("${mqtt_prefix}/smartshunt/alarm_reason",
                       id(ss_alarm_reason_val),
                       id(last_ss_alarm_reason),
                       id(ss_alarm_reason));
          
          // Publish binary sensor with tristate logic
          int current_relay = id(ss_relay_state_val) ? 1 : 0;
          if (current_relay != id(last_ss_relay_state)) {
            const char* payload = id(ss_relay_state_val) ? "ON" : "OFF";
            id(mqtt_client).publish("${mqtt_prefix}/smartshunt/relay_state", payload);
            id(ss_relay_state).publish_state(id(ss_relay_state_val));
            id(last_ss_relay_state) = current_relay;
          }

  # Availability heartbeat - republish online status every 10 minutes
  - interval: 10min
    then:
      - lambda: |-
          uint32_t now = millis();
          if (now - id(last_availability_heartbeat) >= 600000) {
            if (id(last_smartshunt_online)) {
              id(mqtt_client).publish(std::string("${mqtt_prefix}/smartshunt/status"), std::string("online"), (uint8_t)0, true);
            }
            if (id(last_epever_online)) {
              id(mqtt_client).publish(std::string("${mqtt_prefix}/epever/status"), std::string("online"), (uint8_t)0, true);
            }
            id(last_availability_heartbeat) = now;
            ESP_LOGD("mqtt", "Availability heartbeat published");
          }

# =============================================================================
# BUTTONS
# =============================================================================

button:
  - platform: template
    name: "Toggle Debug Level"
    id: toggle_debug_button
    icon: "mdi:toggle-switch"
    on_press:
      - lambda: |-
          if (id(logger_level) == "WARN") {
            id(logger_level_global).set_log_level(ESPHOME_LOG_LEVEL_DEBUG);
            id(logger_level) = "DEBUG";
            ESP_LOGI("main", "Debug level changed to DEBUG");
          } else {
            id(logger_level_global).set_log_level(ESPHOME_LOG_LEVEL_WARN);
            id(logger_level) = "WARN";
            ESP_LOGI("main", "Debug level changed to WARN");
          }
          id(debug_level_sensor).publish_state(id(logger_level));
