# ESPHome CAN-to-RS485 Bridge for Epever Inverter
#
# Hardware: Waveshare ESP32-S3-RS485-CAN
# CAN pins: TX=GPIO15, RX=GPIO16 (500kbps Pylontech protocol from batteries)
# RS485 pins: TX=GPIO17, RX=GPIO18 (Modbus RTU to Epever inverter)
#
# Function: Reads battery data from CAN bus, responds to Epever RS485 Modbus queries
# This bridges the protocol gap: batteries speak Pylontech CAN, Epever speaks Modbus RTU
#
# Protocol modes supported:
# - Modbus RTU slave (Protocol 10 on Epever): 9600 baud, slave addr 1, function code 03/04
# - Pylontech ASCII (Protocol 21 on Epever): 115200 baud - currently disabled

substitutions:
  device_name: epever-can-bridge
  friendly_name: "Epever CAN Bridge"

  # Modbus configuration for Protocol 10 (EPever BMS RS485 Modbus)
  # Per BMS-Link Communication Address V1.6:
  #   - BMS side: ID=1, 9600 bps (battery to BMS-Link)
  #   - Header side: ID=4, 115200 bps (BMS-Link to inverter)
  #
  # When connecting directly to inverter (no BMS-Link), try:
  #   Option A: modbus_addr=1, modbus_baud=9600 (if inverter polls BMS directly)
  #   Option B: modbus_addr=4, modbus_baud=115200 (if inverter expects BMS-Link)
  #
  modbus_addr: "1"
  modbus_baud: "9600"

  # Inverter Modbus TCP configuration
  inverter_host: !secret inverter_host
  inverter_port: !secret inverter_port
  inverter_slave: !secret inverter_slave
  inverter_priority_update_interval: !secret inverter_priority_update_interval

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  min_version: "2026.1.0"
  on_boot:
    - priority: -100
      then:
        - lambda: |-
            // Initialize Address 3 (BMS-Link) configuration storage
            id(addr3_config_0x9000).resize(32, 0);
            // Set sensible defaults (will be overwritten by inverter writes)
            id(addr3_config_0x9000)[0] = 5460;   // 0x9000: UV Warning 54.6V
            id(addr3_config_0x9000)[1] = 4800;   // 0x9001: LV Protection 48V
            id(addr3_config_0x9000)[2] = 5620;   // 0x9002: OV Warning 56.2V
            id(addr3_config_0x9000)[3] = 5500;   // 0x9003: OV Protection 55V
            id(addr3_config_0x9000)[4] = 10000;  // 0x9004: Charge Rated 100A
            id(addr3_config_0x9000)[5] = 10000;  // 0x9005: Charge Limit 100A
            id(addr3_config_0x9000)[6] = 20000;  // 0x9006: Discharge Rated 200A
            id(addr3_config_0x9000)[7] = 20000;  // 0x9007: Discharge Limit 200A
            id(addr3_config_0x9000)[8] = 4500;   // 0x9008: Charge High Temp 45°C
            id(addr3_config_0x9000)[9] = 0;      // 0x9009: AC Frequency (inverter will write)
            ESP_LOGI("main", "Address 3 config storage initialized (32 registers)");
        - logger.log: "CAN-to-RS485 bridge ready"

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:
  level: INFO  # INFO for production with inverter priority logging, WARN to suppress all, DEBUG for deep troubleshooting
  logs:
    # canbus: ERROR  # Uncomment to suppress per-frame CAN logs
    # modbus: ERROR  # Uncomment to suppress per-request modbus logs
    modbus_raw: ERROR  # Suppress RX hex dumps (use DEBUG level to enable)
    modbus_tx: ERROR  # Suppress TX hex dumps (use DEBUG level to enable)
    inverter_priority: INFO  # Enable logging for inverter priority control
    test_button: INFO  # Enable test button logging

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Static IP configuration (comment out for DHCP)
  manual_ip:
    static_ip: !secret static_ip
    gateway: !secret gateway
    subnet: !secret subnet
    # dns1: !secret dns1  # Optional: custom DNS server

  ap:
    ssid: "${device_name}-fallback"
    password: "fallback123"

captive_portal:

ota:
  - platform: esphome
    password: !secret ota_password

web_server:
  port: 80
  auth:
    username: !secret web_username
    password: !secret web_password
  # Note: ESPHome web_server doesn't support custom page handlers
  # The Modbus log is available via API: http://10.10.0.45/text_sensor/modbus_log_text
  # Or create an external HTML file that fetches from this endpoint

api:
  encryption:
    key: !secret api_key
  reboot_timeout: 0s  # Disable watchdog - don't reboot when no clients connected

# UART for RS485 Modbus to Epever
uart:
  id: rs485_uart
  tx_pin: GPIO17
  rx_pin: GPIO18
  baud_rate: ${modbus_baud}
  data_bits: 8
  stop_bits: 1
  parity: NONE
  rx_buffer_size: 256
  # Flow control pin for half-duplex RS485 direction control
  # GPIO21 is connected to DE/RE pins on the Waveshare board's RS485 transceiver
  # HIGH = transmit mode, LOW = receive mode (ESPHome handles this automatically)
  # This is CRITICAL for RS485 to work - without it the transceiver stays in TX mode
  # and can't receive data from the Epever inverter
  flow_control_pin: GPIO21

# CAN bus configuration - NORMAL mode to allow heartbeat transmission
canbus:
  - platform: esp32_can
    id: can_bus
    tx_pin: GPIO15
    rx_pin: GPIO16
    can_id: 0
    bit_rate: 500kbps
    mode: NORMAL

    on_frame:
      # 0x351: Voltage/current limits
      - can_id: 0x351
        then:
          - lambda: |-
              id(can_frame_count)++;
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) {
                id(can_error_count)++;
                return;
              }
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              float v_charge_max = le_u16(x[0], x[1]) / 10.0f;
              float i_charge_lim = le_u16(x[2], x[3]) / 10.0f;
              float i_dis_lim = le_u16(x[4], x[5]) / 10.0f;
              float v_low_lim = le_u16(x[6], x[7]) / 10.0f;

              // Sanity checks
              if (v_charge_max >= 30.0f && v_charge_max <= 65.0f &&
                  v_low_lim >= 30.0f && v_low_lim <= 65.0f &&
                  i_charge_lim >= 0.0f && i_charge_lim <= 500.0f &&
                  i_dis_lim >= 0.0f && i_dis_lim <= 500.0f) {
                id(sensor_v_charge_max).publish_state(v_charge_max);
                id(sensor_v_low).publish_state(v_low_lim);
                id(sensor_i_charge).publish_state(i_charge_lim);
                id(sensor_i_discharge).publish_state(i_dis_lim);

                // Store for RS485 responses
                id(bms_v_charge_max) = v_charge_max;
                id(bms_v_low_limit) = v_low_lim;
                id(bms_i_charge_limit) = i_charge_lim;
                id(bms_i_discharge_limit) = i_dis_lim;
              }

      # 0x355: SOC/SOH
      - can_id: 0x355
        then:
          - lambda: |-
              id(can_frame_count)++;
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) {
                id(can_error_count)++;
                return;
              }
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              uint16_t soc = le_u16(x[0], x[1]);
              uint16_t soh = le_u16(x[2], x[3]);

              if (soc <= 100 && soh <= 100) {
                id(sensor_soc).publish_state(soc);
                id(sensor_soh).publish_state(soh);
                id(bms_soc) = soc;
                id(bms_soh) = soh;

                // SOC-based hysteresis control (if enabled)
                if (id(soc_control_enabled)) {
                  // Discharge blocking hysteresis - controls inverter priority mode
                  // When blocked: inverter switches to Utility priority (grid)
                  // When allowed: inverter switches to Inverter priority (battery)
                  if (soc < id(soc_discharge_block_threshold) && !id(soc_discharge_blocked)) {
                    id(soc_discharge_blocked) = true;
                    ESP_LOGI("soc_control", "Discharge BLOCKED at %d%% (threshold: %d%%) - will switch to Utility priority",
                             soc, id(soc_discharge_block_threshold));
                    // Trigger immediate inverter priority update
                    id(inverter_priority_update_requested) = true;
                  }
                  if (soc > id(soc_discharge_allow_threshold) && id(soc_discharge_blocked)) {
                    id(soc_discharge_blocked) = false;
                    ESP_LOGI("soc_control", "Discharge ALLOWED at %d%% (threshold: %d%%) - will switch to Inverter priority",
                             soc, id(soc_discharge_allow_threshold));
                    // Trigger immediate inverter priority update
                    id(inverter_priority_update_requested) = true;
                  }

                  // Check if inverter mode needs update (even if soc_discharge_blocked didn't change)
                  // This handles the case where we're in the hysteresis zone but inverter mode is wrong
                  // Skip during first 60 seconds to avoid spam while initial sync happens
                  if (millis() >= 60000) {
                    int desired_mode = id(soc_discharge_blocked) ? 1 : 0;
                    if (id(inverter_priority_control_mode) == 0 && desired_mode != id(inverter_priority_mode)) {
                      // Rate limit: only log once per minute to avoid spam
                      uint32_t now = millis();
                      if (now - id(last_mismatch_log_time) >= 60000) {
                        ESP_LOGI("soc_control", "Inverter mode mismatch detected: current=%d, desired=%d (SOC=%d%%, blocked=%d)",
                                 id(inverter_priority_mode), desired_mode, soc, id(soc_discharge_blocked));
                        id(last_mismatch_log_time) = now;
                      }
                      id(inverter_priority_update_requested) = true;
                    }
                  }

                  // Force charge hysteresis
                  if (soc < id(soc_force_charge_on_threshold) && !id(soc_force_charge_active)) {
                    id(soc_force_charge_active) = true;
                    ESP_LOGI("soc_control", "Force charge ON at %d%% (threshold: %d%%)",
                             soc, id(soc_force_charge_on_threshold));
                  }
                  if (soc >= id(soc_force_charge_off_threshold) && id(soc_force_charge_active)) {
                    id(soc_force_charge_active) = false;
                    ESP_LOGI("soc_control", "Force charge OFF at %d%% (threshold: %d%%)",
                             soc, id(soc_force_charge_off_threshold));
                  }
                }
              }

      # 0x359: Flags - decode protection/warning flags per Pylontech CAN V1.2 spec
      - can_id: 0x359
        then:
          - lambda: |-
              id(can_frame_count)++;
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) {
                id(can_error_count)++;
                return;
              }

              // Decode protection flags (bytes 0-1)
              uint8_t prot0 = x[0];
              uint8_t prot1 = x[1];
              id(can_prot_overvolt) = (prot0 & 0x02) != 0;           // bit 1
              id(can_prot_undervolt) = (prot0 & 0x04) != 0;          // bit 2
              id(can_prot_overtemp) = (prot0 & 0x08) != 0;           // bit 3
              id(can_prot_undertemp) = (prot0 & 0x10) != 0;          // bit 4
              id(can_prot_discharge_overcurrent) = (prot0 & 0x80) != 0;  // bit 7

              id(can_prot_charge_overcurrent) = (prot1 & 0x01) != 0; // bit 0
              id(can_prot_system_error) = (prot1 & 0x80) != 0;       // bit 7

              // Decode warning flags (bytes 2-3)
              uint8_t warn2 = x[2];
              uint8_t warn3 = x[3];
              id(can_warn_high_voltage) = (warn2 & 0x02) != 0;       // bit 1
              id(can_warn_low_voltage) = (warn2 & 0x04) != 0;        // bit 2
              id(can_warn_high_temp) = (warn2 & 0x08) != 0;          // bit 3
              id(can_warn_low_temp) = (warn2 & 0x10) != 0;           // bit 4
              id(can_warn_high_discharge_current) = (warn2 & 0x80) != 0;  // bit 7

              id(can_warn_high_charge_current) = (warn3 & 0x01) != 0;  // bit 0
              id(can_warn_comms_fail) = (warn3 & 0x80) != 0;           // bit 7

              // Module count and status byte
              id(can_module_count) = x[4];
              id(can_status_byte7) = x[7];

              // Build raw hex for display
              uint64_t flags = 0;
              for (int i = 7; i >= 0; i--) {
                flags = (flags << 8) | x[i];
              }

              // Hysteresis: only publish if flags changed OR 60s passed
              uint32_t now = millis();
              bool changed = (flags != id(last_flags_value));
              bool heartbeat = (now - id(last_flags_publish) >= 60000);

              if (changed || heartbeat) {
                char buf[32];
                snprintf(buf, sizeof(buf), "0x%016llX", flags);
                id(sensor_flags).publish_state(buf);
                id(last_flags_value) = flags;
                id(last_flags_publish) = now;
              }

      # 0x370: Temperature and cell voltage extremes
      - can_id: 0x370
        then:
          - lambda: |-
              id(can_frame_count)++;
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() != 8) {
                id(can_error_count)++;
                return;
              }
              auto le_u16 = [](uint8_t b0, uint8_t b1) -> uint16_t { return b0 | (b1 << 8); };

              float t1 = le_u16(x[0], x[1]) / 10.0f;
              float t2 = le_u16(x[2], x[3]) / 10.0f;
              float tmin = (t1 <= t2) ? t1 : t2;
              float tmax = (t1 > t2) ? t1 : t2;

              float v1 = le_u16(x[4], x[5]) / 1000.0f;
              float v2 = le_u16(x[6], x[7]) / 1000.0f;

              if (tmin >= -10.0f && tmax <= 50.0f) {
                id(sensor_temp_min).publish_state(tmin);
                id(sensor_temp_max).publish_state(tmax);
                id(bms_temp_min) = tmin;
                id(bms_temp_max) = tmax;
              }

              float vmin = 0, vmax = 0;
              bool v1_valid = (v1 >= 2.0f && v1 <= 4.5f);
              bool v2_valid = (v2 >= 2.0f && v2 <= 4.5f);

              if (v1_valid && v2_valid) {
                vmin = (v1 < v2) ? v1 : v2;
                vmax = (v1 > v2) ? v1 : v2;
              } else if (v1_valid) {
                vmin = vmax = v1;
              } else if (v2_valid) {
                vmin = vmax = v2;
              }

              if (vmin > 0) {
                id(sensor_cell_v_min).publish_state(vmin);
                id(sensor_cell_v_max).publish_state(vmax);
                id(sensor_cell_v_delta).publish_state(vmax - vmin);
                id(bms_cell_v_min) = vmin;
                id(bms_cell_v_max) = vmax;
              }

      # 0x35C: Battery Charge Request Flags (V1.2)
      # 0x35F: Battery Charge Request Flags (V1.3)
      - can_id: 0x35C
        then:
          - lambda: |-
              id(can_frame_count)++;
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() < 1) {
                id(can_error_count)++;
                return;
              }
              {
                uint8_t flags = x[0];
                // CORRECTED bit mapping per Pylontech CAN V1.2 spec:
                // Bit 7 (0x80): Charge enable (RCE)
                // Bit 6 (0x40): Discharge enable (RDE)
                // Bit 5 (0x20): Force charge level 1
                // Bit 4 (0x10): Force charge level 2
                // Bit 3 (0x08): Request full charge
                bool charge_en = (flags & 0x80) != 0;       // FIXED: bit 7
                bool discharge_en = (flags & 0x40) != 0;    // correct
                bool force_chg = (flags & 0x20) != 0;       // NEW: detect force charge

                bool changed = (charge_en != id(can_charge_enabled)) ||
                               (discharge_en != id(can_discharge_enabled)) ||
                               (force_chg != id(can_force_charge_request));

                if (changed) {
                  id(can_charge_enabled) = charge_en;
                  id(can_discharge_enabled) = discharge_en;
                  id(can_force_charge_request) = force_chg;
                  if (id(inverter_priority_debug_level) >= 1) {
                    ESP_LOGI("can", "0x35C: Charge=%s Discharge=%s ForceChg=%s (0x%02X)",
                             charge_en ? "EN" : "DIS", discharge_en ? "EN" : "DIS",
                             force_chg ? "YES" : "NO", flags);
                  }
                }
              }

      # NOTE: 0x35F in V1.3 is "battery information" (type, version, capacity)
      # not charge/discharge control. Keeping this handler for backwards compat
      # but it may produce incorrect readings on V1.3 batteries.
      - can_id: 0x35F
        then:
          - lambda: |-
              id(can_frame_count)++;
              id(last_can_rx) = millis();
              if (id(can_stale)) { id(can_stale) = false; }

              if (x.size() < 1) {
                id(can_error_count)++;
                return;
              }
              // WARNING: This frame is battery info in V1.3, not control flags!
              // Only process if your battery is V1.2 or older
              ESP_LOGW("can", "0x35F received (V1.3 battery info, not control flags) - ignoring");

# Global variables
globals:
  # CAN mode tracking - always true now (NORMAL mode from start)
  - id: can_normal_mode
    type: bool
    initial_value: 'true'

  # CAN stale detection
  - id: last_can_rx
    type: uint32_t
    initial_value: '0'
  - id: can_stale
    type: bool
    initial_value: 'true'

  # Flags hysteresis
  - id: last_flags_value
    type: uint64_t
    initial_value: '0'
  - id: last_flags_publish
    type: uint32_t
    initial_value: '0'

  # CAN charge/discharge enable flags (from 0x35C)
  - id: can_charge_enabled
    type: bool
    initial_value: 'true'  # Default to enabled
  - id: can_discharge_enabled
    type: bool
    initial_value: 'true'  # Default to enabled
  - id: can_force_charge_request
    type: bool
    initial_value: 'false'  # BMS requesting force charge

  # CAN 0x359 decoded protection flags (byte 0-1)
  - id: can_prot_overvolt
    type: bool
    initial_value: 'false'
  - id: can_prot_undervolt
    type: bool
    initial_value: 'false'
  - id: can_prot_overtemp
    type: bool
    initial_value: 'false'
  - id: can_prot_undertemp
    type: bool
    initial_value: 'false'
  - id: can_prot_discharge_overcurrent
    type: bool
    initial_value: 'false'
  - id: can_prot_charge_overcurrent
    type: bool
    initial_value: 'false'
  - id: can_prot_system_error
    type: bool
    initial_value: 'false'

  # CAN 0x359 decoded warning flags (byte 2-3)
  - id: can_warn_high_voltage
    type: bool
    initial_value: 'false'
  - id: can_warn_low_voltage
    type: bool
    initial_value: 'false'
  - id: can_warn_high_temp
    type: bool
    initial_value: 'false'
  - id: can_warn_low_temp
    type: bool
    initial_value: 'false'
  - id: can_warn_high_discharge_current
    type: bool
    initial_value: 'false'
  - id: can_warn_high_charge_current
    type: bool
    initial_value: 'false'
  - id: can_warn_comms_fail
    type: bool
    initial_value: 'false'

  # CAN 0x359 module count and status
  - id: can_module_count
    type: int
    initial_value: '0'
  - id: can_status_byte7
    type: int
    initial_value: '0'

  # CAN alarm summary string for web UI
  - id: can_alarm_summary
    type: std::string

  # Manual control modes: 0=Auto(CAN), 1=Force Off, 2=Force On
  - id: manual_mode_d13_force_charge
    type: int
    initial_value: '0'  # Auto
  - id: manual_mode_d14_stop_discharge
    type: int
    initial_value: '0'  # Auto
  - id: manual_mode_d15_stop_charge
    type: int
    initial_value: '0'  # Auto

  # Last transmitted Modbus 0x3127 value for display
  - id: last_modbus_0x3127
    type: uint16_t
    initial_value: '0'

  # SOC-based hysteresis control
  - id: soc_control_enabled
    type: bool
    initial_value: 'false'  # Disabled by default

  # Discharge control thresholds
  - id: soc_discharge_block_threshold
    type: int
    initial_value: '50'  # Block discharge below this
  - id: soc_discharge_allow_threshold
    type: int
    initial_value: '55'  # Allow discharge above this

  # Force charge control thresholds
  - id: soc_force_charge_on_threshold
    type: int
    initial_value: '45'  # Activate force charge below this
  - id: soc_force_charge_off_threshold
    type: int
    initial_value: '50'  # Clear force charge above this

  # Hysteresis state tracking
  - id: soc_discharge_blocked
    type: bool
    initial_value: 'false'
  - id: soc_force_charge_active
    type: bool
    initial_value: 'false'

  # Inverter output priority control (register 0x9608)
  # 0 = Inverter priority (battery/PV preferred)
  # 1 = Utility priority (grid/bypass preferred)
  # Uses soc_discharge_blocked flag for Auto mode (no separate thresholds needed)
  - id: inverter_priority_mode
    type: int
    initial_value: '0'  # Current mode from inverter
  - id: inverter_priority_control_mode
    type: int
    initial_value: '0'  # 0=Auto(SOC-based), 1=Force Inverter, 2=Force Utility

  # Statistics counters for inverter priority changes
  - id: inverter_priority_attempts
    type: int
    restore_value: true
    initial_value: '0'
  - id: inverter_priority_successes
    type: int
    restore_value: true
    initial_value: '0'
  - id: inverter_priority_failures
    type: int
    restore_value: true
    initial_value: '0'

  # Debug logging level: 0=Minimal(Modbus only), 1=Normal, 2=Verbose
  - id: inverter_priority_debug_level
    type: int
    restore_value: true
    initial_value: '0'

  # Flags to trigger inverter priority update
  - id: inverter_priority_update_requested
    type: bool
    initial_value: 'false'  # Set by control changes (SOC threshold crossing, manual control change)

  - id: inverter_priority_manual_refresh_requested
    type: bool
    initial_value: 'false'  # Set by manual refresh button

  - id: inverter_priority_auto_check_requested
    type: bool
    initial_value: 'false'  # Set by 3-hour auto check timer

  - id: last_mismatch_log_time
    type: uint32_t
    initial_value: '0'  # Timestamp of last mismatch log (for rate limiting)

  # BMS data for RS485 responses
  - id: bms_soc
    type: int
    initial_value: '50'
  - id: bms_soh
    type: int
    initial_value: '100'
  - id: bms_v_charge_max
    type: float
    initial_value: '54.0'
  - id: bms_v_low_limit
    type: float
    initial_value: '48.0'
  - id: bms_i_charge_limit
    type: float
    initial_value: '100.0'
  - id: bms_i_discharge_limit
    type: float
    initial_value: '100.0'
  - id: bms_cell_v_min
    type: float
    initial_value: '3.30'
  - id: bms_cell_v_max
    type: float
    initial_value: '3.35'
  - id: bms_temp_min
    type: float
    initial_value: '25.0'
  - id: bms_temp_max
    type: float
    initial_value: '25.0'

  # RS485 responder state
  - id: rs485_buffer
    type: std::string
    restore_value: no
  - id: rs485_request_count
    type: int
    initial_value: '0'
  - id: rs485_error_count
    type: int
    initial_value: '0'

  # CAN bus statistics
  - id: can_frame_count
    type: int
    initial_value: '0'
  - id: can_error_count
    type: int
    initial_value: '0'

  # Address 3 (BMS-Link) configuration storage - stores values written by inverter
  # This is separate from Address 4 (Battery) which has real-time data
  - id: addr3_config_0x9000
    type: std::vector<uint16_t>
    restore_value: no

  # Modbus interaction log buffer (RAM-backed circular buffer, ~8KB)
  # Captures inverter priority state machine and Modbus RTU over TCP operations
  - id: modbus_log_buffer
    type: std::vector<std::string>
    restore_value: no
  - id: modbus_log_index
    type: int
    initial_value: '0'
    restore_value: no
  - id: modbus_log_max_entries
    type: int
    initial_value: '50'
    restore_value: no

# Intervals
interval:
  # CAN heartbeat - keep batteries awake by sending inverter-like frame
  # Only send when in NORMAL mode (after boot delay)
  - interval: 1s
    then:
      - if:
          condition:
            lambda: 'return id(can_normal_mode);'
          then:
            - canbus.send:
                canbus_id: can_bus
                can_id: 0x305
                data: [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

  # CAN stale detection
  - interval: 5s
    then:
      - lambda: |-
          uint32_t now = millis();
          uint32_t elapsed = now - id(last_can_rx);
          if (elapsed > 30000 && !id(can_stale) && id(last_can_rx) > 0) {
            id(can_stale) = true;
            ESP_LOGW("can", "No CAN data for 30s, marking stale");
          }

  # Periodic CAN health summary (replaces per-frame logging)
  - interval: 10s
    then:
      - lambda: |-
          static uint32_t last_rx_check = 0;
          uint32_t now = millis();
          uint32_t elapsed = now - id(last_can_rx);
          if (last_rx_check == 0) last_rx_check = now;

          // Only log if we've received CAN data recently (healthy)
          if (elapsed < 30000 && (now - last_rx_check) >= 10000) {
            if (id(inverter_priority_debug_level) >= 1) {
              ESP_LOGI("can", "CAN OK (SOC=%d%%, V=%.1fV, last_rx=%dms ago)",
                       id(bms_soc), id(bms_v_charge_max), elapsed);
            }
            last_rx_check = now;
          }

  # Auto check timer - triggers READ-verify-WRITE every 3 hours
  # This just sets a flag; the actual work is done by the triggered interval below
  - interval: ${inverter_priority_update_interval}s
    then:
      - lambda: |-
          // Skip for first 60 seconds after boot to allow CAN data to populate
          if (millis() < 60000) {
            if (id(inverter_priority_debug_level) >= 1) {
              ESP_LOGI("inverter_priority", "Skipping auto check (boot delay: %d/60s)", millis() / 1000);
            }
            return;
          }

          // Set flag to trigger READ-verify-WRITE in the 1s triggered interval
          id(inverter_priority_auto_check_requested) = true;

          if (id(inverter_priority_debug_level) >= 1) {
            ESP_LOGI("inverter_priority", "Auto check timer fired, will verify mode");
          }

  # Inverter priority control - READ-verify-WRITE logic (single code path)
  # Responds to: auto check timer (3h), manual refresh button, control changes
  - interval: 1s
    then:
      - lambda: |-
          // Check if any update was requested
          bool auto_check = id(inverter_priority_auto_check_requested);
          bool manual_refresh = id(inverter_priority_manual_refresh_requested);
          bool control_change = id(inverter_priority_update_requested);

          if (!auto_check && !manual_refresh && !control_change) {
            return;  // Nothing to do
          }

          // Clear all flags immediately to avoid repeated triggers
          id(inverter_priority_auto_check_requested) = false;
          id(inverter_priority_manual_refresh_requested) = false;
          id(inverter_priority_update_requested) = false;

          // Skip for first 60 seconds after boot (except manual refresh)
          if (millis() < 60000 && !manual_refresh) {
            if (id(inverter_priority_debug_level) >= 1) {
              ESP_LOGI("inverter_priority", "Skipping check (boot delay: %d/60s)", millis() / 1000);
            }
            return;
          }

          // Helper: Append to Modbus log buffer
          auto append_modbus_log = [](const std::string& message) {
            uint32_t uptime_sec = millis() / 1000;
            char timestamp[12];
            snprintf(timestamp, sizeof(timestamp), "[%06u] ", uptime_sec);
            std::string entry = std::string(timestamp) + message;
            if (id(modbus_log_buffer).size() < id(modbus_log_max_entries)) {
              id(modbus_log_buffer).push_back(entry);
            } else {
              id(modbus_log_buffer)[id(modbus_log_index)] = entry;
              id(modbus_log_index) = (id(modbus_log_index) + 1) % id(modbus_log_max_entries);
            }
          };

          // Helper: Calculate Modbus RTU CRC16
          auto calc_modbus_crc = [](const uint8_t* data, int len) -> uint16_t {
            uint16_t crc = 0xFFFF;
            for (int i = 0; i < len; i++) {
              crc ^= data[i];
              for (int j = 0; j < 8; j++) {
                if (crc & 0x0001) {
                  crc = (crc >> 1) ^ 0xA001;
                } else {
                  crc = crc >> 1;
                }
              }
            }
            return crc;
          };

          // Log what triggered this check
          if (manual_refresh) {
            append_modbus_log("=== MANUAL REFRESH ===");
            ESP_LOGI("inverter_priority", "Manual refresh requested");
          } else if (auto_check) {
            ESP_LOGI("inverter_priority", "Auto check (3-hour timer)");
          } else {
            append_modbus_log("Triggered update check");
            ESP_LOGI("inverter_priority", "Control change triggered update");
          }

          // Determine desired mode based on control setting
          int soc = id(bms_soc);
          int desired_mode = id(inverter_priority_mode);  // Start with current

          if (id(inverter_priority_control_mode) == 0) {
            // Auto mode: Use SOC discharge blocking flag
            if (id(soc_control_enabled)) {
              if (id(soc_discharge_blocked)) {
                desired_mode = 1;  // Utility priority
              } else {
                desired_mode = 0;  // Inverter priority
              }
            }
          } else if (id(inverter_priority_control_mode) == 1) {
            desired_mode = 0;  // Force Inverter priority
          } else if (id(inverter_priority_control_mode) == 2) {
            desired_mode = 1;  // Force Utility priority
          }

          // Log desired mode
          char log_msg[100];
          snprintf(log_msg, sizeof(log_msg), "Desired mode: %d (SOC=%d%%), reading inverter...",
                   desired_mode, soc);
          append_modbus_log(std::string(log_msg));

          // === READ FROM INVERTER TO GET ACTUAL CURRENT MODE ===
          const uint8_t slave_id = ${inverter_slave};
          const char* inv_host = "${inverter_host}";
          const int inv_port = ${inverter_port};

          // Build Modbus READ command (function 0x03)
          uint8_t read_cmd[8];
          read_cmd[0] = slave_id;
          read_cmd[1] = 0x03;  // Function: Read Holding Registers
          read_cmd[2] = 0x96;  // Register high (0x9608)
          read_cmd[3] = 0x08;  // Register low
          read_cmd[4] = 0x00;  // Quantity high
          read_cmd[5] = 0x01;  // Quantity low (1 register)

          // Calculate CRC
          uint16_t crc = calc_modbus_crc(read_cmd, 6);
          read_cmd[6] = crc & 0xFF;
          read_cmd[7] = (crc >> 8) & 0xFF;

          // Connect and read with retry logic
          struct sockaddr_in dest_addr;
          dest_addr.sin_addr.s_addr = ::inet_addr(inv_host);
          dest_addr.sin_family = AF_INET;
          dest_addr.sin_port = ::htons(inv_port);

          // Declare variables outside loop for proper scope
          char cmd_hex[80];
          char resp_hex[80];
          struct timeval timeout;
          timeout.tv_sec = 2;
          timeout.tv_usec = 0;

          const int max_retries = 3;
          int current_mode = -1;
          bool read_success = false;

          for (int retry = 0; retry < max_retries && !read_success; retry++) {
            if (retry > 0) {
              char retry_msg[80];
              snprintf(retry_msg, sizeof(retry_msg), "Retry attempt %d/%d...", retry + 1, max_retries);
              append_modbus_log(std::string(retry_msg));
              delay(200);  // Extra delay between retries
            }

            // Log TX READ
            snprintf(cmd_hex, sizeof(cmd_hex), "TX READ: %02X %02X %02X %02X %02X %02X %02X %02X",
                     read_cmd[0], read_cmd[1], read_cmd[2], read_cmd[3],
                     read_cmd[4], read_cmd[5], read_cmd[6], read_cmd[7]);
            append_modbus_log(std::string(cmd_hex));

            int sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
            if (sock < 0) {
              append_modbus_log("✗ Socket creation failed");
              continue;
            }

            ::setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

            if (::connect(sock, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) != 0) {
              append_modbus_log("✗ Connection failed");
              ::close(sock);
              continue;
            }

            // Send READ command
            if (::send(sock, read_cmd, 8, 0) != 8) {
              append_modbus_log("✗ Failed to send READ");
              ::close(sock);
              continue;
            }

            delay(100);  // Modbus timing

            // Read response
            uint8_t response[7];
            int len = ::recv(sock, response, 7, 0);

            if (len <= 0) {
              append_modbus_log("✗ No response from inverter");
              ::close(sock);
              continue;
            }

            if (len < 7) {
              char err_msg[80];
              snprintf(err_msg, sizeof(err_msg), "✗ Incomplete response: %d bytes (expected 7)", len);
              append_modbus_log(std::string(err_msg));
              ::close(sock);
              continue;
            }

            // Log RX READ
            snprintf(resp_hex, sizeof(resp_hex), "RX READ: %02X %02X %02X %02X %02X %02X %02X",
                     response[0], response[1], response[2], response[3],
                     response[4], response[5], response[6]);
            append_modbus_log(std::string(resp_hex));

            // Validate function code
            if (response[1] != 0x03) {
              char err_msg[120];
              snprintf(err_msg, sizeof(err_msg), "✗ Wrong function code: 0x%02X (expected 0x03)", response[1]);
              append_modbus_log(std::string(err_msg));
              ::close(sock);
              continue;
            }

            // Validate CRC
            uint16_t calc_crc = calc_modbus_crc(response, 5);
            uint16_t recv_crc = response[5] | (response[6] << 8);
            if (calc_crc != recv_crc) {
              char err_msg[120];
              snprintf(err_msg, sizeof(err_msg), "✗ CRC mismatch: got 0x%04X, expected 0x%04X", recv_crc, calc_crc);
              append_modbus_log(std::string(err_msg));
              ::close(sock);
              continue;
            }

            // Validate byte count
            int byte_count = response[2];
            if (byte_count != 2) {
              char err_msg[120];
              snprintf(err_msg, sizeof(err_msg), "✗ Wrong byte count: %d (expected 2)", byte_count);
              append_modbus_log(std::string(err_msg));
              ::close(sock);
              continue;
            }

            // Extract current mode
            current_mode = (response[3] << 8) | response[4];

            // Validate mode value
            if (current_mode != 0 && current_mode != 1) {
              char err_msg[120];
              snprintf(err_msg, sizeof(err_msg), "✗ Invalid mode: %d (0x%04X)", current_mode, current_mode);
              append_modbus_log(std::string(err_msg));
              ::close(sock);
              continue;
            }

            // Success!
            read_success = true;
            ::close(sock);
          }

          // Check if we succeeded after all retries
          if (!read_success) {
            append_modbus_log("✗ Failed to read mode after all retries");
            id(inverter_priority_failures)++;
            return;
          }

          // Update stored value
          id(inverter_priority_mode) = current_mode;

          // Compare with desired
          const char* current_str = (current_mode == 0) ? "Inverter Priority" : "Utility Priority";
          const char* desired_str = (desired_mode == 0) ? "Inverter Priority" : "Utility Priority";

          if (current_mode == desired_mode) {
            char match_msg[100];
            snprintf(match_msg, sizeof(match_msg), "✓ Mode correct: %s (%d)", current_str, current_mode);
            append_modbus_log(std::string(match_msg));
            return;  // All good, nothing to do
          }

          // MODE MISMATCH - need to write
          char mismatch_msg[120];
          snprintf(mismatch_msg, sizeof(mismatch_msg), "Mode mismatch: current=%s (%d), desired=%s (%d)",
                   current_str, current_mode, desired_str, desired_mode);
          append_modbus_log(std::string(mismatch_msg));

          // === WRITE TO INVERTER TO FIX MISMATCH ===
          // Build Modbus WRITE command (function 0x10)
          uint8_t write_cmd[11];
          write_cmd[0] = slave_id;
          write_cmd[1] = 0x10;  // Function: Write Multiple Registers
          write_cmd[2] = 0x96;  // Register high (0x9608)
          write_cmd[3] = 0x08;  // Register low
          write_cmd[4] = 0x00;  // Quantity high
          write_cmd[5] = 0x01;  // Quantity low (1 register)
          write_cmd[6] = 0x02;  // Byte count
          write_cmd[7] = 0x00;  // Value high
          write_cmd[8] = desired_mode;  // Value low (0 or 1)

          // Calculate CRC
          crc = calc_modbus_crc(write_cmd, 9);
          write_cmd[9] = crc & 0xFF;
          write_cmd[10] = (crc >> 8) & 0xFF;

          // Log TX WRITE
          snprintf(cmd_hex, sizeof(cmd_hex), "TX WRITE: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
                   write_cmd[0], write_cmd[1], write_cmd[2], write_cmd[3], write_cmd[4],
                   write_cmd[5], write_cmd[6], write_cmd[7], write_cmd[8], write_cmd[9], write_cmd[10]);
          append_modbus_log(std::string(cmd_hex));

          // Connect and write
          int sock = ::socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
          if (sock < 0) {
            append_modbus_log("✗ Socket creation failed");
            id(inverter_priority_failures)++;
            return;
          }

          timeout.tv_sec = 1;
          ::setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

          if (::connect(sock, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) != 0) {
            append_modbus_log("✗ Connection failed");
            ::close(sock);
            id(inverter_priority_failures)++;
            return;
          }

          id(inverter_priority_attempts)++;

          // Send WRITE command
          if (::send(sock, write_cmd, 11, 0) != 11) {
            append_modbus_log("✗ Failed to send WRITE");
            ::close(sock);
            id(inverter_priority_failures)++;
            return;
          }

          // Read response
          uint8_t write_response[8];
          int len = ::recv(sock, write_response, 8, 0);

          if (len <= 0) {
            append_modbus_log("✗ No response to WRITE");
            ::close(sock);
            id(inverter_priority_failures)++;
            return;
          }

          // Log RX WRITE
          snprintf(resp_hex, sizeof(resp_hex), "RX WRITE: %02X %02X %02X %02X %02X %02X %02X %02X",
                   write_response[0], write_response[1], write_response[2], write_response[3],
                   write_response[4], write_response[5], write_response[6], write_response[7]);
          append_modbus_log(std::string(resp_hex));

          // Check for exception response (function code has bit 7 set)
          if (len >= 5 && write_response[0] == slave_id && (write_response[1] & 0x80)) {
            uint8_t exception_code = write_response[2];
            const char* exception_msg = "Unknown";
            if (exception_code == 1) exception_msg = "Illegal Function";
            else if (exception_code == 2) exception_msg = "Illegal Data Address";
            else if (exception_code == 3) exception_msg = "Illegal Data Value";
            else if (exception_code == 4) exception_msg = "Slave Device Failure";

            char err_msg[80];
            snprintf(err_msg, sizeof(err_msg), "✗ Exception 0x%02X: %s", exception_code, exception_msg);
            append_modbus_log(std::string(err_msg));
            ::close(sock);
            id(inverter_priority_failures)++;
            return;
          }

          // Validate response length
          if (len != 8) {
            char err_msg[80];
            snprintf(err_msg, sizeof(err_msg), "✗ Wrong WRITE response length: %d (expected 8)", len);
            append_modbus_log(std::string(err_msg));
            ::close(sock);
            id(inverter_priority_failures)++;
            return;
          }

          // Validate function code
          if (write_response[1] != 0x10) {
            char err_msg[120];
            snprintf(err_msg, sizeof(err_msg), "✗ Wrong WRITE function code: 0x%02X (expected 0x10)", write_response[1]);
            append_modbus_log(std::string(err_msg));
            ::close(sock);
            id(inverter_priority_failures)++;
            return;
          }

          // Validate CRC
          uint16_t write_calc_crc = calc_modbus_crc(write_response, 6);
          uint16_t write_recv_crc = write_response[6] | (write_response[7] << 8);
          if (write_calc_crc != write_recv_crc) {
            char err_msg[120];
            snprintf(err_msg, sizeof(err_msg), "✗ WRITE CRC mismatch: got 0x%04X, expected 0x%04X", write_recv_crc, write_calc_crc);
            append_modbus_log(std::string(err_msg));
            ::close(sock);
            id(inverter_priority_failures)++;
            return;
          }

          // Success!
          id(inverter_priority_mode) = desired_mode;
          id(inverter_priority_successes)++;

          char success_msg[80];
          snprintf(success_msg, sizeof(success_msg), "✓ Mode changed to %s (%d)",
                   desired_str, desired_mode);
          append_modbus_log(std::string(success_msg));

          ::close(sock);
  # Modbus RTU responder - responds to inverter read requests
  # Protocol: Modbus RTU, slave address 1, 9600 baud, 8N1
  # Function codes supported: 03 (read holding registers), 04 (read input registers)
  - interval: 5ms
    then:
      - lambda: |-
          static std::vector<uint8_t> rx_buffer;
          static uint32_t last_rx_time = 0;
          static uint32_t last_debug_time = 0;

          // Read all available bytes
          while (id(rs485_uart).available()) {
            uint8_t c;
            id(rs485_uart).read_byte(&c);
            rx_buffer.push_back(c);
            last_rx_time = millis();
          }

          // Periodic debug: show buffer state
          if (millis() - last_debug_time > 2000) {
            last_debug_time = millis();
            if (!rx_buffer.empty()) {
              // Buffer status logging disabled to reduce memory pressure
            }
          }

          // Process frame after 5ms silence (Modbus inter-frame gap at 9600 = ~4ms)
          if (rx_buffer.empty() || (millis() - last_rx_time < 5)) return;

          // Minimum Modbus request: addr(1) + func(1) + start(2) + count(2) + crc(2) = 8 bytes
          if (rx_buffer.size() < 8) {
            id(rs485_error_count)++;
            ESP_LOGW("modbus", "Frame too short: %d bytes", rx_buffer.size());
            rx_buffer.clear();
            return;
          }

          // Debug: Log RX frames (only when logger level is DEBUG)
          #if ESPHOME_LOG_LEVEL >= ESPHOME_LOG_LEVEL_DEBUG
          {
            std::string hex_str;
            char hex[4];
            for (size_t i = 0; i < rx_buffer.size() && i < 20; i++) {
              snprintf(hex, sizeof(hex), "%02X ", rx_buffer[i]);
              hex_str += hex;
            }
            if (rx_buffer.size() > 20) hex_str += "...";
            ESP_LOGD("modbus_raw", "RX %d bytes: %s", rx_buffer.size(), hex_str.c_str());
          }
          #endif

          // Parse Modbus RTU request
          uint8_t slave_addr = rx_buffer[0];
          uint8_t func_code = rx_buffer[1];
          uint16_t start_reg = (rx_buffer[2] << 8) | rx_buffer[3];
          uint16_t reg_count = (rx_buffer[4] << 8) | rx_buffer[5];
          uint16_t rx_crc = rx_buffer[rx_buffer.size()-1] << 8 | rx_buffer[rx_buffer.size()-2];

          ESP_LOGD("modbus", "RX: addr=%d func=%02X start=%d count=%d",
                   slave_addr, func_code, start_reg, reg_count);

          // Calculate CRC16 to verify request
          auto calc_crc16 = [](const uint8_t* data, size_t len) -> uint16_t {
            uint16_t crc = 0xFFFF;
            for (size_t i = 0; i < len; i++) {
              crc ^= data[i];
              for (int j = 0; j < 8; j++) {
                if (crc & 0x0001) {
                  crc = (crc >> 1) ^ 0xA001;
                } else {
                  crc >>= 1;
                }
              }
            }
            return crc;
          };

          uint16_t calc_crc = calc_crc16(rx_buffer.data(), rx_buffer.size() - 2);
          if (calc_crc != rx_crc) {
            id(rs485_error_count)++;
            // Log with hex dump to debug RS485 issues
            std::string hex_str;
            char hex[4];
            for (size_t i = 0; i < rx_buffer.size() && i < 16; i++) {
              snprintf(hex, sizeof(hex), "%02X ", rx_buffer[i]);
              hex_str += hex;
            }
            ESP_LOGW("modbus", "CRC mismatch: calc=%04X rx=%04X, data: %s", calc_crc, rx_crc, hex_str.c_str());
            rx_buffer.clear();
            return;
          }

          // Check if this is our Modbus address
          // Address 1: BMS-Link battery side (9600 baud)
          // Address 3/4: Direct to inverter (115200 baud)
          const uint8_t our_addr = ${modbus_addr};
          if (slave_addr != our_addr) {
            ESP_LOGD("modbus", "Not our address (want %d, got %d)", our_addr, slave_addr);
            rx_buffer.clear();
            return;
          }

          id(rs485_request_count)++;

          // Build response based on function code
          std::vector<uint8_t> response;
          response.push_back(slave_addr);
          response.push_back(func_code);

          if (func_code == 0x01) {
            // Read coils - return all OFF (0)
            // Response: addr + func + byte_count + coil_data
            uint8_t byte_count = (reg_count + 7) / 8;  // Round up to bytes
            response.push_back(byte_count);
            for (int i = 0; i < byte_count; i++) {
              response.push_back(0x00);  // All coils off
            }
            ESP_LOGD("modbus", "Read coils: start=%d count=%d -> %d bytes", start_reg, reg_count, byte_count);
          } else if (func_code == 0x02) {
            // Read discrete inputs - return status bits
            // 0x2000 range might be alarm/status bits
            uint8_t byte_count = (reg_count + 7) / 8;
            response.push_back(byte_count);
            for (int i = 0; i < byte_count; i++) {
              response.push_back(0x00);  // All inputs normal (no alarms)
            }
            ESP_LOGD("modbus", "Read inputs: start=0x%04X count=%d -> %d bytes", start_reg, reg_count, byte_count);
          } else if (func_code == 0x03 || func_code == 0x04) {
            // Read holding registers (03) or input registers (04)
            // Response: addr + func + byte_count + data + crc
            uint8_t byte_count = reg_count * 2;
            response.push_back(byte_count);

            // ============================================================
            // EPever BMS-Link Communication Address V1.6 Register Map
            // ============================================================
            // 0x3100-0x3130 = Input registers (real-time data, read with FC 0x04)
            // 0x9000-0x9019 = Holding registers (configuration, read with FC 0x03)
            //
            // All values per PDF specification with correct scaling factors
            // ============================================================
            for (uint16_t r = start_reg; r < start_reg + reg_count; r++) {
              uint16_t value = 0;
              float avg_cell = (id(bms_cell_v_min) + id(bms_cell_v_max)) / 2.0f;
              float pack_v = avg_cell * 16.0f;
              float avg_temp = (id(bms_temp_min) + id(bms_temp_max)) / 2.0f;

              // Address 3 (BMS-Link): Echo stored configuration for 0x9000 range
              if (slave_addr == 3 && r >= 0x9000 && r < 0x9020) {
                uint16_t offset = r - 0x9000;
                if (offset < id(addr3_config_0x9000).size()) {
                  value = id(addr3_config_0x9000)[offset];
                }
                // Add to response and continue to next register
                response.push_back((value >> 8) & 0xFF);
                response.push_back(value & 0xFF);
                continue;
              }

              switch (r) {
                // ============================================================
                // 0x3100 Range: Real-time Parameters (Read-only, FC 0x04)
                // Per BMS-Link Communication Address V1.6 PDF
                // ============================================================

                case 0x30FF: // BMS communication status (polled to check if BMS alive)
                  value = 0x0001;  // Non-zero = BMS online
                  break;

                case 0x3100: // A0: Cell number - number of cells in battery
                  value = 16;  // 16S LiFePO4
                  break;

                case 0x3101: // A1: Battery voltage (V * 100)
                  value = (uint16_t)(pack_v * 100.0f);
                  ESP_LOGD("modbus", "0x3101 Batt V = %d (%.2fV)", value, pack_v);
                  break;

                case 0x3102: // A2: Battery current (A * 100, int16, +charge/-discharge)
                  value = 0;  // No current data from CAN
                  break;

                case 0x3103: // A3: Battery power L (W * 100, low word of 32-bit)
                  value = 0;  // No power data
                  break;

                case 0x3104: // A4: Battery power H (W * 100, high word of 32-bit)
                  value = 0;
                  break;

                case 0x3105: // A5: Battery full capacity (Ah)
                  value = 560;  // 2x 280Ah batteries in parallel
                  break;

                case 0x3106: // A6: SOC - Percentage of surplus battery capacity (%)
                  value = id(bms_soc);
                  ESP_LOGD("modbus", "0x3106 SOC = %d%%", value);
                  break;

                case 0x3107: // A7: Battery surplus working time (minutes)
                  value = 0;  // Unknown
                  break;

                case 0x3108: // A8: Maximum cell temperature (°C * 100, int16)
                  {
                    int16_t t = (int16_t)(id(bms_temp_max) * 100.0f);
                    value = (uint16_t)t;
                  }
                  break;

                case 0x3109: // A9: Minimum cell temperature (°C * 100, int16)
                  {
                    int16_t t = (int16_t)(id(bms_temp_min) * 100.0f);
                    value = (uint16_t)t;
                  }
                  break;

                case 0x310A: // A10: Equilibrium (balancing) temperature (°C * 100, int16)
                  {
                    int16_t t = (int16_t)(avg_temp * 100.0f);
                    value = (uint16_t)t;
                  }
                  break;

                case 0x310B: // A11: Environment temperature (°C * 100, int16)
                  {
                    int16_t t = (int16_t)(avg_temp * 100.0f);
                    value = (uint16_t)t;
                  }
                  break;

                case 0x310C: // A12: MOS temperature (°C * 100, int16)
                  {
                    int16_t t = (int16_t)(avg_temp * 100.0f);
                    value = (uint16_t)t;
                  }
                  break;

                case 0x310D: // A13: Cycle index (charge/discharge cycles)
                  value = 0;  // Unknown from CAN
                  break;

                case 0x310E: // A14: Equilibrium flag (0=disabled, 1=enabled/balancing)
                  value = 0;  // Not balancing (or unknown)
                  break;

                case 0x310F: // A15: Voltage status
                  // 0=Normal, 1=UV Warning, 2=OV Warning, 0xF1=UV Protection, 0xF2=OV Protection
                  value = 0;  // Normal
                  break;

                case 0x3110: // A16: Current status
                  // 0=Normal, 1=Over Discharge Warning, 2=Over Charge Warning
                  // 0xF1=Over Discharge Protection, 0xF2=Over Charge Protection
                  value = 0;  // Normal
                  break;

                case 0x3111: // A17: MOS status (D0=charging MOS on, D1=discharging MOS on)
                  // Map from CAN charge/discharge enable flags (0x35C/0x35F)
                  value = 0;
                  if (id(can_discharge_enabled)) value |= 0x01;  // D0: Discharge MOS
                  if (id(can_charge_enabled)) value |= 0x02;     // D1: Charge MOS
                  break;

                case 0x3112: // A18: Cell temperature status
                  // 0=Normal, 1=Low Temp Warning, 2=Over Temp Warning
                  // 0xF0=NTC error, 0xF1=Low Temp Protection, 0xF2=Over Temp Protection
                  value = 0;  // Normal
                  break;

                case 0x3113: // A19: Equilibrium temperature status
                  value = 0;  // Normal
                  break;

                case 0x3114: // A20: Environment temperature status
                  value = 0;  // Normal
                  break;

                case 0x3115: // A21: MOS temperature status
                  value = 0;  // Normal
                  break;

                // A22-A37 (0x3116-0x3125): Cell 1-16 status
                // 0x00=Normal, 0x01=UV Warning, 0x02=OV Warning
                // 0xF0=Cell detection, 0xF1=UV Protection, 0xF2=OV Protection
                case 0x3116: case 0x3117: case 0x3118: case 0x3119:
                case 0x311A: case 0x311B: case 0x311C: case 0x311D:
                case 0x311E: case 0x311F: case 0x3120: case 0x3121:
                case 0x3122: case 0x3123: case 0x3124: case 0x3125:
                  value = 0;  // All cells normal
                  break;

                case 0x3126: // A38: Lithium battery protocol type
                  value = 10;  // Protocol 10 = EPever BMS RS485 Modbus
                  break;

                case 0x3127: // A39: Lithium battery BMS status (bitfield)
                  // D0: Charging protection, D1: Discharging protection
                  // D2: Communication fault, D3: Other protection
                  // D4: Charging over temp, D5: Discharging over temp
                  // D12: Full charge mark, D13: Force charge mark
                  // D14: 0=Enable discharge (1=stop), D15: 0=Enable charge (1=stop)
                  {
                    value = 0x0000;  // Start with all OK

                    // Determine D13 (Force Charge) - layered priority
                    bool d13_force_charge = false;
                    if (id(manual_mode_d13_force_charge) == 0) {
                      // Auto mode: Layer SOC control over CAN
                      if (id(soc_control_enabled) && id(soc_force_charge_active)) {
                        d13_force_charge = true;  // SOC control activates force charge
                      } else {
                        d13_force_charge = id(can_force_charge_request);  // Use CAN value
                      }
                    } else if (id(manual_mode_d13_force_charge) == 2) {
                      d13_force_charge = true;  // Manual override: Force On
                    }
                    // else: Manual override: Force Off (false)

                    // Determine D14 (Stop Discharge) - BMS protection only
                    bool d14_stop_discharge = false;
                    if (id(manual_mode_d14_stop_discharge) == 0) {
                      // Auto mode: Use BMS protection only (SOC control now uses inverter priority)
                      d14_stop_discharge = !id(can_discharge_enabled);  // BMS blocks discharge
                    } else if (id(manual_mode_d14_stop_discharge) == 2) {
                      d14_stop_discharge = true;  // Manual override: Force On (stop discharge)
                    }
                    // else: Manual override: Force Off (allow discharge)

                    // Determine D15 (Stop Charge) - BMS only (SOC doesn't block charge)
                    bool d15_stop_charge = false;
                    if (id(manual_mode_d15_stop_charge) == 0) {
                      // Auto mode: use inverted CAN charge enable
                      d15_stop_charge = !id(can_charge_enabled);
                    } else if (id(manual_mode_d15_stop_charge) == 2) {
                      d15_stop_charge = true;  // Manual override: Force On (stop charge)
                    }
                    // else: Manual override: Force Off (allow charge)

                    // Set Modbus flags
                    if (d13_force_charge) value |= 0x2000;   // D13: Force charge mark
                    if (d14_stop_discharge) value |= 0x4000; // D14: Stop discharge
                    if (d15_stop_charge) value |= 0x8000;    // D15: Stop charge

                    // Store for display on web UI
                    id(last_modbus_0x3127) = value;

                    ESP_LOGD("modbus", "0x3127 = 0x%04X (D13:%s D14:%s D15:%s)",
                             value,
                             d13_force_charge ? "ForceChg" : "-",
                             d14_stop_discharge ? "StopDis" : "-",
                             d15_stop_charge ? "StopChg" : "-");
                  }
                  break;

                case 0x3128: // A40: Added function tags
                  // 0 = battery pack paralleling not supported
                  // 0xACF1 = paralleling supported
                  value = 0;  // No parallel support
                  break;

                case 0x3129: // A41: Real-time battery pack voltage (V * 10)
                  value = (uint16_t)(pack_v * 10.0f);
                  break;

                case 0x312A: // A42: Real-time battery pack current (A * 10, int16)
                  value = 0;  // No current data
                  break;

                // A43-A48 (0x312B-0x3130): Reserved
                case 0x312B: case 0x312C: case 0x312D:
                case 0x312E: case 0x312F: case 0x3130:
                  value = 0;
                  break;

                // ============================================================
                // 0x9000 Range: Setting Parameters (Read/Write, FC 0x03/0x10)
                // Per BMS-Link Communication Address V1.6 PDF
                // ============================================================

                case 0x9000: // C0: Under Voltage Warning (V * 100)
                  value = (uint16_t)(id(bms_v_low_limit) * 100.0f);
                  break;

                case 0x9001: // C1: Low Voltage Protection (V * 100)
                  // Set slightly below warning voltage
                  value = (uint16_t)((id(bms_v_low_limit) - 1.0f) * 100.0f);
                  break;

                case 0x9002: // C2: Over Voltage Warning (V * 100)
                  // Set slightly below protection voltage
                  value = (uint16_t)((id(bms_v_charge_max) - 0.5f) * 100.0f);
                  break;

                case 0x9003: // C3: Over Voltage Protection (V * 100)
                  value = (uint16_t)(id(bms_v_charge_max) * 100.0f);
                  break;

                case 0x9004: // C4: Charging Current Rated (A * 100) - battery max capacity
                  value = 10000;  // 100A rated max
                  break;

                case 0x9005: // C5: Charging Current Limit (A * 100) - dynamic BMS limit
                  {
                    float lim = id(bms_i_charge_limit);
                    if (lim < 1.0f) lim = 1.0f;  // Min 1A to avoid inverter issues
                    value = (uint16_t)(lim * 100.0f);
                  }
                  break;

                case 0x9006: // C6: Discharging Current Rated (A * 100) - battery max capacity
                  value = 20000;  // 200A rated max
                  break;

                case 0x9007: // C7: Discharging Current Limit (A * 100) - dynamic BMS limit
                  {
                    float lim = id(bms_i_discharge_limit);
                    if (lim < 1.0f) lim = 1.0f;
                    value = (uint16_t)(lim * 100.0f);
                  }
                  break;

                case 0x9008: // C8: Charging High Temperature Protection (°C * 100, int16)
                  value = 4500;  // 45°C
                  break;

                case 0x9009: // C9: Charging Low Temperature Protection (°C * 100, int16)
                  // Note: For Address 3 (BMS-Link), this is AC Frequency - handled above by stored config
                  // For Address 1/4 (Battery), this is charging low temp protection per spec
                  {
                    int16_t t = -1000;  // -10°C typical LiFePO4 charging limit
                    value = (uint16_t)t;
                  }
                  break;

                case 0x900A: // C10: Discharging High Temperature Protection (°C * 100, int16)
                  value = 5500;  // 55°C
                  break;

                case 0x900B: // C11: Discharging Low Temperature Protection (°C * 100, int16)
                  {
                    int16_t t = -2000;  // -20°C (0xF830) - intentional low-temp cutoff
                    value = (uint16_t)t;
                  }
                  break;

                case 0x900C: // C12: Cell High Temperature Protection (°C * 100, int16)
                  value = 5500;  // 55°C
                  break;

                case 0x900D: // C13: Cell Low Temperature Protection (°C * 100, int16)
                  {
                    int16_t t = -2000;  // -20°C (0xF830) - intentional low-temp cutoff
                    value = (uint16_t)t;
                  }
                  break;

                case 0x900E: // C14: Equilibrium High Temperature Protection (°C * 100)
                  value = 5500;  // 55°C
                  break;

                case 0x900F: // C15: Equilibrium Low Temperature Protection (°C * 100, int16)
                  {
                    int16_t t = -2000;  // -20°C (0xF830) - intentional low-temp cutoff
                    value = (uint16_t)t;
                  }
                  break;

                case 0x9010: // C16: Environment High Temperature Protection (°C * 100)
                  value = 5500;  // 55°C
                  break;

                case 0x9011: // C17: Environment Low Temperature Protection (°C * 100, int16)
                  {
                    int16_t t = -2000;  // -20°C (0xF830) - intentional low-temp cutoff
                    value = (uint16_t)t;
                  }
                  break;

                case 0x9012: // C18: MOS High Temperature Protection (°C * 100)
                  value = 8000;  // 80°C
                  break;

                case 0x9013: // C19: MOS Low Temperature Protection (°C * 100, int16)
                  {
                    int16_t t = -2000;  // -20°C (0xF830) - intentional low-temp cutoff
                    value = (uint16_t)t;
                  }
                  break;

                case 0x9014: // C20: Protocol Type (default 10)
                  value = 10;  // EPever BMS RS485 Modbus protocol
                  break;

                case 0x9015: // C21: Reserved
                  value = 0;
                  break;

                case 0x9016: // C22: Low Voltage Protection (V * 10) - alternate scale
                  value = (uint16_t)((id(bms_v_low_limit) - 1.0f) * 10.0f);
                  break;

                case 0x9017: // C23: Over Voltage Warning (V * 10) - alternate scale
                  value = (uint16_t)((id(bms_v_charge_max) - 0.5f) * 10.0f);
                  break;

                case 0x9018: // C24: Charging Current Protection (A * 10)
                  value = (uint16_t)(id(bms_i_charge_limit) * 10.0f);
                  break;

                case 0x9019: // C25: Discharging Current Protection (A * 10)
                  value = (uint16_t)(id(bms_i_discharge_limit) * 10.0f);
                  break;

                default:
                  // Unknown register - return 0
                  value = 0;
                  break;
              }

              // Add register value (big-endian)
              response.push_back((value >> 8) & 0xFF);
              response.push_back(value & 0xFF);
            }
          } else if (func_code == 0x05) {
            // Write single coil - just echo back the request (acknowledge)
            // Format: addr + func + coil_addr(2) + value(2)
            ESP_LOGD("modbus", "Write coil: addr=0x%04X value=0x%04X", start_reg, reg_count);
            response.push_back((start_reg >> 8) & 0xFF);
            response.push_back(start_reg & 0xFF);
            response.push_back((reg_count >> 8) & 0xFF);
            response.push_back(reg_count & 0xFF);
          } else if (func_code == 0x06) {
            // Write single register - just echo back the request (acknowledge)
            ESP_LOGD("modbus", "Write register: addr=0x%04X value=0x%04X", start_reg, reg_count);
            response.push_back((start_reg >> 8) & 0xFF);
            response.push_back(start_reg & 0xFF);
            response.push_back((reg_count >> 8) & 0xFF);
            response.push_back(reg_count & 0xFF);
          } else if (func_code == 0x10) {
            // Write multiple registers - acknowledge with start addr and count
            // Request format: addr + func + start(2) + count(2) + bytes(1) + data...
            ESP_LOGD("modbus", "Write multiple regs: slave=%d addr=0x%04X count=%d", slave_addr, start_reg, reg_count);

            // Address 3 (BMS-Link): Store configuration writes
            if (slave_addr == 3 && start_reg == 0x9000 && rx_buffer.size() >= 7) {
              uint8_t byte_count = rx_buffer[6];
              if (byte_count == reg_count * 2 && rx_buffer.size() >= (7 + byte_count)) {
                // Parse and store written values
                for (uint16_t i = 0; i < reg_count && i < 32; i++) {
                  uint8_t hi = rx_buffer[7 + i*2];
                  uint8_t lo = rx_buffer[7 + i*2 + 1];
                  uint16_t value = (hi << 8) | lo;
                  id(addr3_config_0x9000)[i] = value;
                }
                ESP_LOGI("modbus", "Addr3: Stored %d config regs to 0x9000", reg_count);

                // Log key values
                if (id(addr3_config_0x9000)[9] > 0) {
                  ESP_LOGI("modbus", "Addr3: AC Freq = %.1fHz (reg 0x9009 = %d)",
                           id(addr3_config_0x9000)[9] / 100.0f, id(addr3_config_0x9000)[9]);
                }
              }
            }

            // Send acknowledgment
            response.push_back((start_reg >> 8) & 0xFF);
            response.push_back(start_reg & 0xFF);
            response.push_back((reg_count >> 8) & 0xFF);
            response.push_back(reg_count & 0xFF);
          } else {
            // Unsupported function code - return exception
            // Unsupported function code - silently ignore
            response[1] = func_code | 0x80;  // Exception response
            response.push_back(0x01);  // Illegal function
          }

          // Calculate and append CRC
          uint16_t resp_crc = calc_crc16(response.data(), response.size());
          response.push_back(resp_crc & 0xFF);        // CRC low byte first
          response.push_back((resp_crc >> 8) & 0xFF); // CRC high byte

          // Debug: Log TX frames (only when logger level is DEBUG)
          ESP_LOGD("modbus", "TX %d bytes", response.size());

          #if ESPHOME_LOG_LEVEL >= ESPHOME_LOG_LEVEL_DEBUG
          static uint32_t last_tx_dump = 0;
          if (millis() - last_tx_dump > 5000) {
            last_tx_dump = millis();
            std::string hex_str;
            char hex[4];
            for (size_t i = 0; i < response.size() && i < 40; i++) {
              snprintf(hex, sizeof(hex), "%02X ", response[i]);
              hex_str += hex;
            }
            if (response.size() > 40) hex_str += "...";
            ESP_LOGD("modbus_tx", "TX sample: %s", hex_str.c_str());
          }
          #endif
          id(rs485_uart).write_array(response.data(), response.size());
          id(rs485_uart).flush();

          // Clear RX buffer
          rx_buffer.clear();

          // Small delay then clear any echo
          delay(5);
          while (id(rs485_uart).available()) {
            uint8_t dummy;
            id(rs485_uart).read_byte(&dummy);
          }

# CAN sensors with filtering (from working deye-bms-can.yaml)
sensor:
  - platform: template
    id: sensor_soc
    name: "BMS SOC"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery"
    filters:
      - or:
        - heartbeat: 60s
        - delta: 1.0

  - platform: template
    id: sensor_soh
    name: "BMS SOH"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery-heart"
    filters:
      - or:
        - heartbeat: 60s
        - delta: 1.0

  - platform: template
    id: sensor_v_charge_max
    name: "Charge Voltage Limit"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.1

  - platform: template
    id: sensor_v_low
    name: "Discharge Voltage Limit"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 1
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.1

  - platform: template
    id: sensor_i_charge
    name: "Charge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    filters:
      - or:
        - heartbeat: 60s
        - delta: 1.0

  - platform: template
    id: sensor_i_discharge
    name: "Discharge Current Limit"
    unit_of_measurement: "A"
    device_class: current
    accuracy_decimals: 1
    filters:
      - or:
        - heartbeat: 60s
        - delta: 1.0

  - platform: template
    id: sensor_cell_v_min
    name: "Cell V Min"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.005

  - platform: template
    id: sensor_cell_v_max
    name: "Cell V Max"
    unit_of_measurement: "V"
    device_class: voltage
    accuracy_decimals: 3
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.005

  - platform: template
    id: sensor_cell_v_delta
    name: "Cell V Delta"
    unit_of_measurement: "V"
    accuracy_decimals: 3
    icon: "mdi:chart-bell-curve-cumulative"
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.002

  - platform: template
    id: sensor_temp_min
    name: "Temperature Min"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.5

  - platform: template
    id: sensor_temp_max
    name: "Temperature Max"
    unit_of_measurement: "°C"
    device_class: temperature
    accuracy_decimals: 1
    filters:
      - or:
        - heartbeat: 60s
        - delta: 0.5

  - platform: template
    name: "Pack Voltage"
    unit_of_measurement: "V"
    accuracy_decimals: 1
    icon: "mdi:lightning-bolt"
    lambda: 'return (id(bms_cell_v_min) + id(bms_cell_v_max)) / 2.0f * 16.0f;'
    update_interval: 5s

  - platform: template
    name: "RS485 Requests"
    accuracy_decimals: 0
    icon: "mdi:counter"
    lambda: 'return id(rs485_request_count);'
    update_interval: 10s

  - platform: template
    name: "RS485 Errors"
    accuracy_decimals: 0
    icon: "mdi:alert-circle"
    lambda: 'return id(rs485_error_count);'
    update_interval: 10s

  - platform: template
    name: "CAN Frames"
    accuracy_decimals: 0
    icon: "mdi:counter"
    lambda: 'return id(can_frame_count);'
    update_interval: 10s

  - platform: template
    name: "CAN Errors"
    accuracy_decimals: 0
    icon: "mdi:alert-circle"
    lambda: 'return id(can_error_count);'
    update_interval: 10s

  - platform: template
    name: "CAN Module Count"
    accuracy_decimals: 0
    icon: "mdi:battery-multiple"
    lambda: 'return id(can_module_count);'

  - platform: template
    name: "CAN Status Byte 7"
    accuracy_decimals: 0
    icon: "mdi:information-outline"
    entity_category: diagnostic
    lambda: 'return id(can_status_byte7);'

  - platform: template
    name: "Inverter Priority Change Attempts"
    accuracy_decimals: 0
    icon: "mdi:counter"
    lambda: 'return id(inverter_priority_attempts);'
    update_interval: 10s

  - platform: template
    name: "Inverter Priority Change Successes"
    accuracy_decimals: 0
    icon: "mdi:check-circle"
    lambda: 'return id(inverter_priority_successes);'
    update_interval: 10s

  - platform: template
    name: "Inverter Priority Change Failures"
    accuracy_decimals: 0
    icon: "mdi:alert-circle"
    lambda: 'return id(inverter_priority_failures);'
    update_interval: 10s

  - platform: template
    name: "Inverter Priority Change Success Rate"
    accuracy_decimals: 1
    unit_of_measurement: "%"
    icon: "mdi:percent"
    lambda: |-
      int attempts = id(inverter_priority_attempts);
      if (attempts == 0) return 0.0;
      int successes = id(inverter_priority_successes);
      return (float)successes / (float)attempts * 100.0;
    update_interval: 10s

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: uptime
    name: "Uptime"

binary_sensor:
  - platform: template
    name: "CAN Data Stale"
    lambda: 'return id(can_stale);'
    device_class: problem

  - platform: template
    name: "CAN Charge Enabled"
    icon: "mdi:battery-charging"
    lambda: 'return id(can_charge_enabled);'

  - platform: template
    name: "CAN Discharge Enabled"
    icon: "mdi:battery-minus"
    lambda: 'return id(can_discharge_enabled);'

  - platform: template
    name: "CAN Force Charge Request"
    icon: "mdi:battery-alert"
    lambda: 'return id(can_force_charge_request);'

  - platform: template
    name: "SOC Discharge Blocked"
    icon: "mdi:battery-lock"
    lambda: 'return id(soc_control_enabled) && id(soc_discharge_blocked);'

  - platform: template
    name: "SOC Force Charge Active"
    icon: "mdi:battery-charging-100"
    lambda: 'return id(soc_control_enabled) && id(soc_force_charge_active);'

  # CAN 0x359 Protection flags (decoded)
  - platform: template
    name: "CAN Protection Overvolt"
    device_class: problem
    lambda: 'return id(can_prot_overvolt);'

  - platform: template
    name: "CAN Protection Undervolt"
    device_class: problem
    lambda: 'return id(can_prot_undervolt);'

  - platform: template
    name: "CAN Protection Overtemp"
    device_class: problem
    lambda: 'return id(can_prot_overtemp);'

  - platform: template
    name: "CAN Protection Undertemp"
    device_class: problem
    lambda: 'return id(can_prot_undertemp);'

  - platform: template
    name: "CAN Protection Discharge Overcurrent"
    device_class: problem
    lambda: 'return id(can_prot_discharge_overcurrent);'

  - platform: template
    name: "CAN Protection Charge Overcurrent"
    device_class: problem
    lambda: 'return id(can_prot_charge_overcurrent);'

  - platform: template
    name: "CAN Protection System Error"
    device_class: problem
    lambda: 'return id(can_prot_system_error);'

  # CAN 0x359 Warning flags (decoded)
  - platform: template
    name: "CAN Warning High Voltage"
    icon: "mdi:flash"
    lambda: 'return id(can_warn_high_voltage);'

  - platform: template
    name: "CAN Warning Low Voltage"
    icon: "mdi:flash-outline"
    lambda: 'return id(can_warn_low_voltage);'

  - platform: template
    name: "CAN Warning High Temp"
    icon: "mdi:thermometer-high"
    lambda: 'return id(can_warn_high_temp);'

  - platform: template
    name: "CAN Warning Low Temp"
    icon: "mdi:thermometer-low"
    lambda: 'return id(can_warn_low_temp);'

  - platform: template
    name: "CAN Warning High Discharge Current"
    icon: "mdi:current-dc"
    lambda: 'return id(can_warn_high_discharge_current);'

  - platform: template
    name: "CAN Warning High Charge Current"
    icon: "mdi:current-dc"
    lambda: 'return id(can_warn_high_charge_current);'

  - platform: template
    name: "CAN Warning Comms Fail"
    device_class: problem
    lambda: 'return id(can_warn_comms_fail);'

select:
  - platform: template
    name: "D13 Force Charge Control"
    icon: "mdi:battery-charging-100"
    optimistic: true
    restore_value: true
    options:
      - "Auto (CAN)"
      - "Force Off"
      - "Force On"
    initial_option: "Auto (CAN)"
    on_value:
      - lambda: |-
          if (x == "Auto (CAN)") {
            id(manual_mode_d13_force_charge) = 0;
            ESP_LOGI("manual", "D13 Force Charge: Auto (using CAN)");
          } else if (x == "Force Off") {
            id(manual_mode_d13_force_charge) = 1;
            ESP_LOGI("manual", "D13 Force Charge: Force Off");
          } else if (x == "Force On") {
            id(manual_mode_d13_force_charge) = 2;
            ESP_LOGI("manual", "D13 Force Charge: Force On");
          }

  - platform: template
    name: "D14 Stop Discharge Control"
    icon: "mdi:battery-lock"
    optimistic: true
    restore_value: true
    options:
      - "Auto (CAN)"
      - "Force Off (Allow Discharge)"
      - "Force On (Block Discharge)"
    initial_option: "Auto (CAN)"
    on_value:
      - lambda: |-
          if (x == "Auto (CAN)") {
            id(manual_mode_d14_stop_discharge) = 0;
            ESP_LOGI("manual", "D14 Stop Discharge: Auto (using CAN)");
          } else if (x == "Force Off (Allow Discharge)") {
            id(manual_mode_d14_stop_discharge) = 1;
            ESP_LOGI("manual", "D14 Stop Discharge: Force Off (Allow Discharge)");
          } else if (x == "Force On (Block Discharge)") {
            id(manual_mode_d14_stop_discharge) = 2;
            ESP_LOGI("manual", "D14 Stop Discharge: Force On (Block Discharge)");
          }

  - platform: template
    name: "D15 Stop Charge Control"
    icon: "mdi:battery-off"
    optimistic: true
    restore_value: true
    options:
      - "Auto (CAN)"
      - "Force Off (Allow Charge)"
      - "Force On (Block Charge)"
    initial_option: "Auto (CAN)"
    on_value:
      - lambda: |-
          if (x == "Auto (CAN)") {
            id(manual_mode_d15_stop_charge) = 0;
            ESP_LOGI("manual", "D15 Stop Charge: Auto (using CAN)");
          } else if (x == "Force Off (Allow Charge)") {
            id(manual_mode_d15_stop_charge) = 1;
            ESP_LOGI("manual", "D15 Stop Charge: Force Off (Allow Charge)");
          } else if (x == "Force On (Block Charge)") {
            id(manual_mode_d15_stop_charge) = 2;
            ESP_LOGI("manual", "D15 Stop Charge: Force On (Block Charge)");
          }

  - platform: template
    name: "SOC Discharge Control"
    icon: "mdi:battery-arrow-down"
    optimistic: true
    restore_value: true
    options:
      - "40% / 45%"
      - "45% / 50%"
      - "50% / 55%"
      - "55% / 60%"
      - "60% / 65%"
    initial_option: "50% / 55%"
    on_value:
      - lambda: |-
          if (x == "40% / 45%") {
            id(soc_discharge_block_threshold) = 40;
            id(soc_discharge_allow_threshold) = 45;
            ESP_LOGI("soc_config", "Discharge: Block at 40%%, Allow at 45%%");
          } else if (x == "45% / 50%") {
            id(soc_discharge_block_threshold) = 45;
            id(soc_discharge_allow_threshold) = 50;
            ESP_LOGI("soc_config", "Discharge: Block at 45%%, Allow at 50%%");
          } else if (x == "50% / 55%") {
            id(soc_discharge_block_threshold) = 50;
            id(soc_discharge_allow_threshold) = 55;
            ESP_LOGI("soc_config", "Discharge: Block at 50%%, Allow at 55%%");
          } else if (x == "55% / 60%") {
            id(soc_discharge_block_threshold) = 55;
            id(soc_discharge_allow_threshold) = 60;
            ESP_LOGI("soc_config", "Discharge: Block at 55%%, Allow at 60%%");
          } else if (x == "60% / 65%") {
            id(soc_discharge_block_threshold) = 60;
            id(soc_discharge_allow_threshold) = 65;
            ESP_LOGI("soc_config", "Discharge: Block at 60%%, Allow at 65%%");
          }
      - delay: 5s
      - lambda: |-
          ESP_LOGI("soc_config", "Triggering inverter priority update after control change");
          id(inverter_priority_update_requested) = true;

  - platform: template
    name: "SOC Force Charge Control"
    icon: "mdi:battery-arrow-up"
    optimistic: true
    restore_value: true
    options:
      - "35% / 40%"
      - "40% / 45%"
      - "45% / 50%"
      - "50% / 55%"
      - "55% / 60%"
    initial_option: "45% / 50%"
    on_value:
      - lambda: |-
          if (x == "35% / 40%") {
            id(soc_force_charge_on_threshold) = 35;
            id(soc_force_charge_off_threshold) = 40;
            ESP_LOGI("soc_config", "Force Charge: ON at 35%%, OFF at 40%%");
          } else if (x == "40% / 45%") {
            id(soc_force_charge_on_threshold) = 40;
            id(soc_force_charge_off_threshold) = 45;
            ESP_LOGI("soc_config", "Force Charge: ON at 40%%, OFF at 45%%");
          } else if (x == "45% / 50%") {
            id(soc_force_charge_on_threshold) = 45;
            id(soc_force_charge_off_threshold) = 50;
            ESP_LOGI("soc_config", "Force Charge: ON at 45%%, OFF at 50%%");
          } else if (x == "50% / 55%") {
            id(soc_force_charge_on_threshold) = 50;
            id(soc_force_charge_off_threshold) = 55;
            ESP_LOGI("soc_config", "Force Charge: ON at 50%%, OFF at 55%%");
          } else if (x == "55% / 60%") {
            id(soc_force_charge_on_threshold) = 55;
            id(soc_force_charge_off_threshold) = 60;
            ESP_LOGI("soc_config", "Force Charge: ON at 55%%, OFF at 60%%");
          }
      - delay: 5s
      - lambda: |-
          ESP_LOGI("soc_config", "Triggering inverter priority update after control change");
          id(inverter_priority_update_requested) = true;

  - platform: template
    name: "Inverter Output Priority Control"
    icon: "mdi:swap-horizontal"
    optimistic: true
    restore_value: true
    options:
      - "Auto (SOC-based)"
      - "Force Inverter Priority"
      - "Force Utility Priority"
    initial_option: "Auto (SOC-based)"
    on_value:
      - lambda: |-
          if (x == "Auto (SOC-based)") {
            id(inverter_priority_control_mode) = 0;
            ESP_LOGI("inverter_priority", "Control: Auto (SOC-based switching)");
          } else if (x == "Force Inverter Priority") {
            id(inverter_priority_control_mode) = 1;
            ESP_LOGI("inverter_priority", "Control: Force Inverter Priority (battery/PV preferred)");
          } else if (x == "Force Utility Priority") {
            id(inverter_priority_control_mode) = 2;
            ESP_LOGI("inverter_priority", "Control: Force Utility Priority (grid preferred)");
          }
      - delay: 5s
      - lambda: |-
          ESP_LOGI("inverter_priority", "Triggering inverter priority update after control change");
          id(inverter_priority_update_requested) = true;

  - platform: template
    name: "Inverter Priority Debug Level"
    icon: "mdi:bug"
    optimistic: true
    restore_value: true
    options:
      - "Minimal (Modbus only)"
      - "Normal"
      - "Verbose"
    initial_option: "Minimal (Modbus only)"
    on_value:
      - lambda: |-
          if (x == "Minimal (Modbus only)") {
            id(inverter_priority_debug_level) = 0;
            ESP_LOGI("inverter_priority", "Debug: Minimal (Modbus RTU transactions only)");
          } else if (x == "Normal") {
            id(inverter_priority_debug_level) = 1;
            ESP_LOGI("inverter_priority", "Debug: Normal (Modbus + results)");
          } else if (x == "Verbose") {
            id(inverter_priority_debug_level) = 2;
            ESP_LOGI("inverter_priority", "Debug: Verbose (all details)");
          }

switch:
  - platform: template
    name: "Enable SOC Reserve Control"
    icon: "mdi:battery-heart"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          id(soc_control_enabled) = true;
          ESP_LOGI("soc_control", "SOC Reserve Control ENABLED");
          ESP_LOGI("soc_control", "  Discharge: Block <%d%%, Allow >%d%%",
                   id(soc_discharge_block_threshold), id(soc_discharge_allow_threshold));
          ESP_LOGI("soc_control", "  Force Charge: ON <%d%%, OFF >=%d%%",
                   id(soc_force_charge_on_threshold), id(soc_force_charge_off_threshold));
      - delay: 5s
      - lambda: |-
          ESP_LOGI("soc_control", "Triggering inverter priority update after control change");
          id(inverter_priority_update_requested) = true;
    turn_off_action:
      - lambda: |-
          id(soc_control_enabled) = false;
          id(soc_discharge_blocked) = false;
          id(soc_force_charge_active) = false;
          ESP_LOGI("soc_control", "SOC Reserve Control DISABLED");
      - delay: 5s
      - lambda: |-
          ESP_LOGI("soc_control", "Triggering inverter priority update after control change");
          id(inverter_priority_update_requested) = true;

button:
  - platform: restart
    name: "Restart"

  - platform: template
    name: "Test Button"
    icon: "mdi:test-tube"
    on_press:
      - lambda: |-
          ESP_LOGI("test_button", "TEST BUTTON PRESSED - If you see this, buttons work!");
          ESP_LOGI("test_button", "SOC=%d%%, inverter_priority_mode=%d", id(bms_soc), id(inverter_priority_mode));

  - platform: template
    name: "Refresh Inverter Priority"
    icon: "mdi:refresh"
    on_press:
      - lambda: |-
          // Set flag to trigger unified READ-verify-WRITE interval
          id(inverter_priority_manual_refresh_requested) = true;
          ESP_LOGI("inverter_priority", "Manual refresh requested");

# Text sensors - moved to end for better web UI organization
text_sensor:
  - platform: template
    id: sensor_flags
    name: "BMS Flags"
    icon: "mdi:flag"

  - platform: template
    name: "CAN Alarm Summary"
    icon: "mdi:alert"
    update_interval: 5s
    lambda: |-
      std::string alarms;

      // Protection flags
      if (id(can_prot_overvolt)) { if (!alarms.empty()) alarms += ","; alarms += "P:OV"; }
      if (id(can_prot_undervolt)) { if (!alarms.empty()) alarms += ","; alarms += "P:UV"; }
      if (id(can_prot_overtemp)) { if (!alarms.empty()) alarms += ","; alarms += "P:OT"; }
      if (id(can_prot_undertemp)) { if (!alarms.empty()) alarms += ","; alarms += "P:UT"; }
      if (id(can_prot_discharge_overcurrent)) { if (!alarms.empty()) alarms += ","; alarms += "P:DOC"; }
      if (id(can_prot_charge_overcurrent)) { if (!alarms.empty()) alarms += ","; alarms += "P:COC"; }
      if (id(can_prot_system_error)) { if (!alarms.empty()) alarms += ","; alarms += "P:SYS"; }

      // Warning flags
      if (id(can_warn_high_voltage)) { if (!alarms.empty()) alarms += ","; alarms += "W:HV"; }
      if (id(can_warn_low_voltage)) { if (!alarms.empty()) alarms += ","; alarms += "W:LV"; }
      if (id(can_warn_high_temp)) { if (!alarms.empty()) alarms += ","; alarms += "W:HT"; }
      if (id(can_warn_low_temp)) { if (!alarms.empty()) alarms += ","; alarms += "W:LT"; }
      if (id(can_warn_high_discharge_current)) { if (!alarms.empty()) alarms += ","; alarms += "W:HDI"; }
      if (id(can_warn_high_charge_current)) { if (!alarms.empty()) alarms += ","; alarms += "W:HCI"; }
      if (id(can_warn_comms_fail)) { if (!alarms.empty()) alarms += ","; alarms += "W:COMM"; }

      // Add module count indicator if not all modules online
      if (id(can_module_count) > 0 && id(can_module_count) < 3) {
        char buf[16];
        snprintf(buf, sizeof(buf), " [%d/3 mods]", id(can_module_count));
        alarms += buf;
      }

      id(can_alarm_summary) = alarms.empty() ? "OK" : alarms;
      return id(can_alarm_summary);

  - platform: template
    name: "Modbus Status (0x3127)"
    icon: "mdi:swap-horizontal"
    update_interval: 5s
    lambda: |-
      uint16_t val = id(last_modbus_0x3127);
      char buf[80];
      snprintf(buf, sizeof(buf), "0x%04X (D13:%s D14:%s D15:%s)",
               val,
               (val & 0x2000) ? "ForceChg" : "-",
               (val & 0x4000) ? "StopDis" : "-",
               (val & 0x8000) ? "StopChg" : "-");
      return std::string(buf);

  - platform: version
    name: "ESPHome Version"

  - platform: template
    name: "Inverter Output Priority Mode"
    icon: "mdi:swap-horizontal"
    update_interval: 10s
    lambda: |-
      if (id(inverter_priority_mode) == 0) {
        return std::string("Inverter Priority (Battery/PV)");
      } else {
        return std::string("Utility Priority (Grid)");
      }

  - platform: template
    name: "zzz Modbus Interaction Log"
    id: modbus_log_text
    icon: "mdi:script-text-outline"
    # Prefixed with "zzz" to sort to bottom of alphabetically-sorted web UI
    entity_category: diagnostic
    update_interval: 5s
    lambda: |-
      if (id(modbus_log_buffer).empty()) {
        return std::string("No Modbus interactions logged yet");
      }

      // Build display string from circular buffer (oldest to newest)
      std::string result;
      int total = id(modbus_log_buffer).size();

      if (total < id(modbus_log_max_entries)) {
        // Buffer not full - display in order
        for (int i = 0; i < total; i++) {
          result += id(modbus_log_buffer)[i] + "\n";
        }
      } else {
        // Buffer full - display from oldest to newest
        for (int i = 0; i < total; i++) {
          int idx = (id(modbus_log_index) + i) % id(modbus_log_max_entries);
          result += id(modbus_log_buffer)[idx] + "\n";
        }
      }

      return result;

