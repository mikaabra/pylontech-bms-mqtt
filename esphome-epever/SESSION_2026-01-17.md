# Development Session - 2026-01-17

## Session Summary

Implemented a RAM-backed circular buffer for Modbus interaction logging with dedicated terminal-based viewer for SSH access.

## Objective

Create a persistent log buffer (~8KB) that captures Modbus RTU over TCP interactions with the EPever inverter, allowing visibility into state machine events and protocol exchanges even when disconnected from the web UI.

## Problem Statement

Modbus priority control updates occur infrequently (every 3 hours or on threshold crossing), making it difficult to troubleshoot issues:
- Web browser disconnects lose log history
- ESPHome's main log is too noisy (includes RS485 errors, CAN frames, etc.)
- Need dedicated view of just inverter priority Modbus operations

## Requirements

1. **Circular buffer**: ~8KB RAM-backed storage (50 log entries)
2. **Persistence**: Survives browser disconnects but OK to clear on power loss
3. **Filtering**: Only EPever Modbus RTU over TCP operations (no RS485 noise)
4. **Access method**: Terminal-based viewer via SSH (primary), web viewer (optional)
5. **UI placement**: Bottom of web interface to avoid clutter

## Implementation

### 1. Circular Buffer (Lines 551-563)

Added global variables for RAM-backed circular log storage:

```yaml
globals:
  # Modbus interaction log buffer (RAM-backed circular buffer, ~8KB)
  - id: modbus_log_buffer
    type: std::vector<std::string>
    restore_value: no                    # RAM only, not NVRAM

  - id: modbus_log_index
    type: int
    initial_value: '0'
    restore_value: no

  - id: modbus_log_max_entries
    type: int
    initial_value: '50'                  # ~8KB = 50 entries × 160 bytes
    restore_value: no
```

### 2. Helper Lambda Functions

Added `append_modbus_log()` helper in three intervals:
- **Auto check interval** (lines 614-628): Background 3-hour update
- **Triggered interval** (lines 844-858): SOC threshold crossing updates
- **Manual refresh button** (lines 2186-2200): User-triggered refresh

Helper implementation:
```cpp
auto append_modbus_log = [](const std::string& message) {
  // Add uptime timestamp
  uint32_t uptime_sec = millis() / 1000;
  char timestamp[12];
  snprintf(timestamp, sizeof(timestamp), "[%06u] ", uptime_sec);

  std::string entry = std::string(timestamp) + message;

  // Circular buffer logic
  if (id(modbus_log_buffer).size() < id(modbus_log_max_entries)) {
    id(modbus_log_buffer).push_back(entry);
  } else {
    // Overwrite oldest entry
    id(modbus_log_buffer)[id(modbus_log_index)] = entry;
    id(modbus_log_index) = (id(modbus_log_index) + 1) % id(modbus_log_max_entries);
  }
};
```

### 3. Logging Points

Added 12+ strategic logging locations:
- State machine: "Auto check", "Mode change needed", "Triggered update"
- Modbus TX: Hex dump of write commands
- Modbus RX: Hex dump of responses
- Success: "✓ Mode changed successfully"
- Errors: "✗ Connection failed", "✗ Exception 0x01"

### 4. Text Sensor for API Access (Lines 2566-2596)

```yaml
text_sensor:
  - platform: template
    name: "zzz Modbus Interaction Log"
    id: modbus_log_text
    icon: "mdi:script-text-outline"
    entity_category: diagnostic
    update_interval: 5s
    lambda: |-
      if (id(modbus_log_buffer).empty()) {
        return std::string("No Modbus interactions logged yet");
      }

      // Build display string (oldest to newest)
      std::string result;
      int total = id(modbus_log_buffer).size();

      if (total < id(modbus_log_max_entries)) {
        // Buffer not full - display in order
        for (int i = 0; i < total; i++) {
          result += id(modbus_log_buffer)[i] + "\n";
        }
      } else {
        // Buffer full - display from oldest to newest
        for (int i = 0; i < total; i++) {
          int idx = (id(modbus_log_index) + i) % id(modbus_log_max_entries);
          result += id(modbus_log_buffer)[idx] + "\n";
        }
      }

      return result;
```

**Note**: Prefixed with "zzz" to force alphabetical sorting to bottom of web UI.

### 5. Terminal Viewer (modbus_log_tail.sh)

Created bash script with ANSI color syntax highlighting:

**Features:**
- One-shot display: `./modbus_log_tail.sh`
- Follow mode (5s refresh): `./modbus_log_tail.sh -f`
- Watch mode (2s refresh): `./modbus_log_tail.sh -w`
- Color-coded:
  - Timestamps: Green
  - TX commands: Blue
  - RX responses: Cyan
  - Success (✓): Green
  - Errors (✗): Red
  - Keywords: Yellow

**API Endpoint:** `http://10.10.0.45/text_sensor/zzz_modbus_interaction_log`

### 6. Optional Web Viewers

Created for browser access (less commonly used):

- **modbus_log_viewer.html**: Standalone HTML with auto-refresh, syntax highlighting
- **modbus_log_server.py**: Python proxy server for SOCKS/SSH tunnel scenarios

## Design Decisions

### Why RAM-backed, not NVRAM?

- **Fast writes**: No wear on flash memory
- **Frequent updates**: Log entries written every few seconds during mode changes
- **Acceptable loss**: Fine to lose history on power cycle
- **NVRAM usage**: Already used for settings (SOC thresholds, control modes)

### Why Circular Buffer?

- **Fixed memory**: Exactly 50 entries × ~160 bytes = ~8KB
- **No growth**: Won't cause memory issues on long uptime
- **Oldest first**: Always see recent history, automatically discards old entries

### Why Terminal Viewer?

- **SSH access**: User already has SSH access to the server
- **No browser needed**: Works over terminal session
- **Simple**: Pure bash script, no dependencies
- **Fast**: Immediate access without opening browser

### Why "zzz" Prefix?

ESPHome's web UI sorts entities **alphabetically by name**, not by YAML order. The "zzz" prefix ensures the log appears at the bottom of the text sensor list.

Attempted solutions that didn't work:
- Moving YAML section to end of file (doesn't affect web UI order)
- Using `entity_category: diagnostic` (doesn't hide it, just categorizes)
- Using `internal: true` (breaks API endpoint, terminal viewer fails with 404)

## Memory Impact

**Before:**
- RAM: 37,224 bytes (11.4%)
- Flash: 959,499 bytes (52.3%)

**After:**
- RAM: 37,224 bytes (11.4%) - no change until buffer fills
- Flash: 959,491 bytes (52.3%) - virtually identical
- Additional ~8KB RAM when buffer is full (50 entries)

## Testing Results

### Initial Test (5 minutes after deployment)

```
$ ./modbus_log_tail.sh

═══════════════════════════════════════════════════════════
  Modbus Interaction Log - EPever CAN Bridge
  ESP32: 10.10.0.45
═══════════════════════════════════════════════════════════

[000001] Triggered update check
[000001] TX: 0A 10 96 08 00 01 02 00 01 E3 E1
[000001] ✗ Connection failed
[000002] Triggered update check
[000002] TX: 0A 10 96 08 00 01 02 00 01 E3 E1
[000002] ✗ Connection failed
[000003] Triggered update check
[000003] TX: 0A 10 96 08 00 01 02 00 01 E3 E1
[000003] RX: 0A 10 96 08 00 01 AC F8
[000005] Triggered update check

─────────────────────────────────────────────────────────
10 log entries (buffer limit: 50)
Last updated: 2026-01-17 19:45:58
```

**Observations:**
- ✅ Buffer capturing TX/RX commands
- ✅ Error logging working (connection failures)
- ✅ Timestamp prefix accurate (uptime in seconds)
- ✅ Color coding functional in terminal
- ⚠️ Initial connection failures likely due to Modbus gateway being accessed by Home Assistant simultaneously (single-client limitation)

### Web UI Verification

- ✅ "zzz Modbus Interaction Log" appears at bottom of text sensor list
- ✅ Limited vertical growth (~8KB max)
- ✅ Still accessible for users who prefer web interface
- ✅ Auto-updates every 5 seconds on web page

## Files Modified

### Core Configuration
- **epever-can-bridge.yaml**: Added globals, logging calls, text sensor

### Viewer Tools
- **modbus_log_tail.sh**: Terminal viewer (primary access method)
- **modbus_log_viewer.html**: Browser viewer (alternative)
- **modbus_log_server.py**: Proxy server for SSH tunnel scenarios

## Git Commits

```
ee315b0 - Add Modbus interaction log buffer with dedicated viewer
758262e - Add terminal-based Modbus log viewer for SSH access
577ab71 - Move text_sensor section to bottom of web UI
59807de - Rename Modbus log to sort alphabetically to bottom
```

## Lessons Learned

### ESPHome Web UI Sorting

ESPHome's web interface sorts entities **alphabetically by name**, completely ignoring YAML file order. This is different from Home Assistant, which respects entity ordering.

**Solutions for UI placement:**
1. Prefix with "zzz" to sort last (chosen approach)
2. Mark as `internal: true` (breaks API access)
3. Use custom web server (not supported by ESPHome)

### SOCKS Proxy and Browser Security

The HTML viewer doesn't work directly when accessing ESP32 through SSH tunnel/SOCKS proxy due to:
- CORS restrictions
- File:// protocol limitations
- Proxy connection not available to local HTML file's JavaScript

**Solutions:**
1. Terminal viewer via SSH (chosen - simplest)
2. Python proxy server (available if needed)
3. Serve HTML through web server on same machine as SSH tunnel

### Circular Buffer vs. Ring Buffer

Implemented as **circular buffer** (vector with index), not ring buffer (linked list):
- Simpler implementation
- Predictable memory usage
- Faster random access for display

## Future Enhancements

Potential improvements not currently implemented:

1. **Configurable buffer size**: Allow user to adjust max_entries via web UI
2. **Log level filtering**: Separate verbose/normal/minimal modes
3. **Export to file**: Download log as .txt file via web interface
4. **Persistent storage**: Optional SD card logging for long-term analysis
5. **Statistics**: Count of successful writes, failures, retries per session
6. **Search/filter**: Grep-like functionality in terminal viewer
7. **Real-time streaming**: WebSocket or SSE for live updates without polling

## Known Issues

### None currently identified

The implementation is working as designed. No bugs or limitations discovered during testing.

## Success Criteria - All Met ✅

- ✅ Circular buffer captures Modbus interactions
- ✅ ~8KB RAM usage (50 entries)
- ✅ Survives browser disconnects
- ✅ Clears on power loss (RAM-backed)
- ✅ Only captures EPever Modbus operations (no RS485 noise)
- ✅ Terminal viewer working with color-coded output
- ✅ Positioned at bottom of web UI
- ✅ API endpoint accessible for terminal viewer

## References

- **ESPHome Documentation**: https://esphome.io/components/text_sensor/template.html
- **C++ std::vector**: https://en.cppreference.com/w/cpp/container/vector
- **ANSI Color Codes**: https://en.wikipedia.org/wiki/ANSI_escape_code
- **Related Work**: SUCCESS_SUMMARY.md (inverter priority control implementation)

---

## Bug Fixes (Evening Session)

### Issue 1: Invalid Mode Value Corruption

**Discovery Time**: 2026-01-17 19:52:36

**Symptoms**:
```
Inverter mode mismatch detected: current=5460, desired=1 (SOC=42%, blocked=1)
```

**Root Cause**: The manual refresh button (line 2324) was storing **any value** returned from Modbus register 0x9608 into `inverter_priority_mode`, without validation. When the Modbus gateway returned battery voltage (54.60V = 5460) instead of mode (0 or 1), the corrupted value caused:
- Infinite mismatch detection loops
- Incorrect mode comparison logic
- Confusing log messages

**Fix Applied** (Commit 8a80f29):
- Added validation to only accept 0 or 1 as valid mode values
- Reject any other value with detailed error logging
- Prevent corrupted data from being stored
- Log both decimal and hex values for debugging

**Code Change** (lines 2325-2338):
```cpp
// Validate: mode must be 0 or 1, anything else is invalid data
if (current_mode != 0 && current_mode != 1) {
  ESP_LOGE("inverter_priority", "✗ Invalid mode value from register 0x9608: %d (0x%04X) - expected 0 or 1",
           current_mode, current_mode);
  ESP_LOGE("inverter_priority", "This may indicate wrong register being read or Modbus gateway error");

  char err_msg[120];
  snprintf(err_msg, sizeof(err_msg), "✗ Invalid mode: %d (0x%04X) - wrong register?", current_mode, current_mode);
  append_modbus_log(std::string(err_msg));

  // Don't update inverter_priority_mode with garbage data
  ::close(sock);
  return;
}
```

### Issue 2: Malformed Modbus Responses

**Discovery Time**: 2026-01-17 20:24:00

**Symptoms**:
```
[008206] RX READ: 0A 04 04 00 00 00 00
                      ^  ^  ^^^^^^^^^^^
                      |  |  4 bytes of zeros (wrong!)
                      |  Byte count = 4 (should be 2)
                      Function 0x04 (should be 0x03)
```

**Root Cause**: The Modbus RTU over TCP gateway occasionally returns data from the **wrong register** when reading 0x9608:
- **Normal response**: `0A 03 02 00 01` (func 0x03, 2 bytes, value=1)
- **Abnormal response**: `0A 04 04 00 00 00 00` (func 0x04, 4 bytes, value=0)

The 4-byte response suggests the gateway is returning battery voltage/current data instead of inverter mode.

**Fix Applied** (Commit ce5fb3d):
- Added byte count validation (must be exactly 2 bytes for 1 register)
- Reject malformed responses before processing
- Log gateway errors with clear diagnostic message

**Code Change** (lines 2318-2331):
```cpp
// Validate byte count: should be exactly 2 for reading 1 register
int byte_count = response[2];
if (byte_count != 2) {
  ESP_LOGE("inverter_priority", "✗ Wrong byte count in response: %d (expected 2 for 1 register)",
           byte_count);
  ESP_LOGE("inverter_priority", "Gateway may be returning wrong register data");

  char err_msg[120];
  snprintf(err_msg, sizeof(err_msg), "✗ Wrong byte count: %d (expected 2) - gateway error?", byte_count);
  append_modbus_log(std::string(err_msg));

  ::close(sock);
  return;
}
```

### Testing Results After Fixes

**Initial boot sequence** (expected behavior):
```
[000001] TX: 0A 10 96 08 00 01 02 00 01 E3 E1
[000001] ✗ Connection failed  (normal - gateway initializing)
[000002] ✗ Connection failed  (retry)
[000003] RX: 0A 10 96 08 00 01 AC F8  (success!)
```

**Manual refresh tests** (3/3 successful):
```
[000072] TX READ: 0A 03 96 08 00 01 29 3B
[000072] RX READ: 0A 03 02 00 01 DC 45
[000072] ✓ Mode correct: Utility Priority (1)

[000079] TX READ: 0A 03 96 08 00 01 29 3B
[000080] RX READ: 0A 03 02 00 01 DC 45
[000080] ✓ Mode correct: Utility Priority (1)

[000087] TX READ: 0A 03 96 08 00 01 29 3B
[000087] RX READ: 0A 03 02 00 01 DC 45
[000087] ✓ Mode correct: Utility Priority (1)
```

**Validation checks passing**:
- ✅ Byte count = 2 (correct for 1 register)
- ✅ Function = 0x03 (Read Holding)
- ✅ Value = 0 or 1 (valid mode)
- ✅ No corrupted data stored
- ✅ No infinite mismatch loops

### Lessons Learned

**Always validate external data**:
- Modbus responses can be malformed due to gateway bugs
- Never trust that a response contains the expected register data
- Validate byte count, function code, and value ranges

**Defensive programming**:
- Reject invalid data before it corrupts system state
- Early return prevents cascading failures
- Detailed error messages aid debugging

**Modbus RTU over TCP gateway issues**:
- Gateways can have cache/routing bugs
- May return data from wrong register under load
- Need validation at every layer

### Hypothesis on Gateway Behavior

The Modbus RTU over TCP gateway (10.10.0.117:9999) appears to have a **cache or routing bug** where it occasionally returns:
1. Data from a different register (4-byte battery voltage instead of 2-byte mode)
2. Wrong function code (0x04 instead of 0x03)
3. Wrong byte count (4 instead of 2)

**Possible causes**:
- Concurrent access from Home Assistant and ESP32
- Gateway caching responses from previous queries
- Gateway firmware bug in register address routing
- Single-client limitation causing data mixing

**Mitigation**:
- Validation now prevents corrupted data from being used
- Clear error messages in log for diagnosis
- System continues operating with last known good value

---

**Session completed successfully: 2026-01-17 23:05:00**
