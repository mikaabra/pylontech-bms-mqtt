# Session Summary: 2026-01-13

## Major Achievements

### 1. Development Environment Setup ✅
- Set up complete ESPHome development environment on new Ubuntu server
- Installed python3-venv, Git, required libraries (libffi-dev, libssl-dev, etc.)
- Created virtual environment at `~/GitHub/esphome/venv`
- Installed ESPHome 2026.1.0-dev successfully
- Configured Git with SSH authentication to GitHub

### 2. Critical Discovery: Address 3 vs Address 4 ✅

**The Epever inverter treats two Modbus addresses as separate devices:**

| Address | Device Type | Behavior | Purpose |
|---------|------------|----------|---------|
| **Address 3** | BMS-Link Configuration | Read + **WRITE** | Configuration device receiving inverter settings |
| **Address 4** | Battery Real-Time Data | Read-only | Real-time battery measurements from CAN bus |

**Polling Pattern Evidence:**
```
Address 3:
- Function 0x03 (Read Holding): 0x9000 (32 registers)
- Function 0x04 (Read Input): 0x3100 (41 registers)
- Function 0x10 (Write Multiple): 0x9000 (32 registers) ← KEY DIFFERENCE!
- Function 0x05 (Write Coil): Various coils

Address 4:
- Function 0x03 (Read Holding): 0x9000 (21 registers)
- Function 0x04 (Read Input): 0x3100 (40 registers)
- NO WRITES ← Read-only
```

### 3. Register 0x9009 Discovery ✅

**Address 3, Register 0x9009 = AC Grid Frequency (NOT Temperature!)**

Systematic testing proved the BMS-Link documentation is WRONG:

| Test | Configuration | Epever Display Result |
|------|--------------|----------------------|
| Initial | 0x9009 = 0 | Load Frequency: 0Hz |
| Test 1 | 0x9009 = 500 | Load Frequency: 5Hz |
| Test 2 | 0x9009 = 1240 | Load Frequency: 12Hz |
| **Phase 1** | **Inverter writes 5000, we echo back** | **Load Frequency: 50Hz ✅** |

**Captured Inverter Write Data:**
```
Function 0x10, Address 3, Start 0x9000, Count 32 registers:
0x9000 = 5460  (54.60V UV Warning)
0x9001 = 8000  (80.00V LV Protection)
...
0x9009 = 5000  (50.0Hz AC Frequency) ← THE KEY FINDING!
...
```

**Scaling:** Frequency in Hz * 100 (5000 = 50.0Hz)

### 4. Phase 1 Implementation: Write Storage and Echo ✅

**What We Built:**

1. **Storage Vector**
   - `addr3_config_0x9000` - 32 register vector
   - Initialized with sensible defaults on boot
   - Stores configuration written by inverter

2. **Write Handler (Function 0x10)**
   - Detects writes to Address 3, register 0x9000
   - Parses 32 registers from write data
   - Stores in `addr3_config_0x9000` vector
   - Logs key values (like AC frequency)

3. **Read Handler (Function 0x03)**
   - Checks if Address 3 and 0x9000 range
   - Echoes stored values back to inverter
   - Bypasses normal register switch for Address 3

4. **Address 4 Handling**
   - Continues using battery data from CAN bus
   - Tested theory: 0x9009 = battery temp (FAILED)
   - Battery data still works correctly

**Code Changes:**
- `esphome-epever/epever-can-bridge.yaml`:
  - Added global storage vector
  - Added initialization in `on_boot`
  - Modified Function 0x10 handler to store writes
  - Added Address 3 check in register loop
  - Tested Address 4's 0x9009 as temperature

## Current Epever Display Status

| Parameter | Status | Value | Notes |
|-----------|--------|-------|-------|
| BMS Icon | ✅ Working | Lit | BMS detected |
| Battery Voltage | ✅ Working | Correct | From 0x3101 |
| Battery SOC% | ✅ Working | Correct | From 0x3106 |
| Battery Capacity | ✅ Working | 560Ah | From 0x3105 |
| **Load Frequency** | ✅ **FIXED** | **50Hz** | **From Address 3, 0x9009** |
| Battery Temperature | ❌ Not Working | 0.0°C | Correct values sent in 0x3108/0x3109 |
| Load Voltage | ❌ Not Working | 0V | Unknown register |
| Battery State | ❓ Unknown | 0 | Meaning unclear |
| Battery Current | ❌ Expected | 0A | Not available from CAN |

## Files Modified

1. **esphome-epever/epever-can-bridge.yaml**
   - Main ESPHome configuration
   - Added Address 3/4 separation logic
   - Added storage and write handling

2. **esphome-epever/EPEVER_MODBUS_FINDINGS.md**
   - Updated with Address 3/4 discovery
   - Documented register 0x9009 testing
   - Added current status

3. **esphome-epever/IMPLEMENTATION_PLAN_ID3_ID4.md**
   - Detailed implementation plan
   - Testing strategy
   - Phase breakdown

4. **esphome-epever/SESSION_2026-01-13.md** (this file)
   - Complete session summary

## Git Commits

1. `5c82453` - Add ESPHome Epever CAN bridge configuration
2. `6db9aad` - Discover and document register 0x9009 mapping error
3. `1431aac` - Add implementation plan for Address 3/4 separation
4. `4a1b77e` - Implement Phase 1: Address 3/4 separation working
5. `5425d0c` - Update findings: Phase 1 success, Address 3/4 confirmed

All commits pushed to: `github.com:mikaabra/pylontech-bms-mqtt.git`

## Outstanding Issues

### 1. Battery Temperature Display (0°C)

**What We Know:**
- Correct temperatures sent in registers 0x3108 (max temp ~13.8°C) and 0x3109 (min temp ~12.4°C)
- Epever displays 0.0°C
- Not reading from 0x3108/0x3109 despite documentation
- Tested Address 4's 0x9009 = 1250 (12.5°C) - NO EFFECT

**Theories to Test:**
1. **Different 0x9000-range register** (Address 3 or 4)
   - Maybe 0x900A, 0x900B, 0x900C, 0x900D?
2. **Different 0x3100-range register**
   - Maybe 0x310A (Equilibrium temp)?
   - Maybe 0x310B (Environment temp)?
   - Maybe 0x310C (MOS temp)?
3. **Address 3 configuration register**
   - Inverter might write expected temp and compare to battery
4. **Calculated value**
   - Might need to be derived from multiple sources

### 2. Load Voltage Display (0V)

**Status:** Unknown which register Epever reads
**Candidates:**
- Could be in 0x3100 range
- Could be in 0x9000 range
- Could be calculated

### 3. Battery Current (0A)

**Status:** Expected - not available from Pylontech CAN protocol
**Note:** Could potentially be read from Deye inverter Modbus if needed

## Next Session Tasks

### High Priority
1. **Find Battery Temperature Register**
   - Systematically test 0x900A-0x900D on both Address 3 and 4
   - Test 0x310A, 0x310B, 0x310C on Address 4
   - Log all responses and correlate with display

### Medium Priority
2. **Find Load Voltage Register**
   - Review all 0x3100 registers
   - Check if it's a calculated value

3. **Understand Battery State = 0**
   - Check register 0x3127 (BMS status bitfield)
   - May need specific bit patterns

### Low Priority
4. **Optimize Address 3 Handling**
   - Consider storing all Address 3 writes, not just 0x9000
   - May need to handle 0x3100 range differently for Address 3

5. **Battery Current**
   - Decide if needed
   - If yes, integrate Deye inverter Modbus reading

## Lessons Learned

1. **Documentation is Often Wrong**
   - BMS-Link PDF claimed 0x9009 = "Charging Low Temperature Protection"
   - Actual: 0x9009 = AC Grid Frequency
   - Always verify through testing

2. **Multiple Modbus Addresses Can Be Different Devices**
   - Address 3 = Configuration device (writable)
   - Address 4 = Real-time data (read-only)
   - Treating them the same was causing confusion

3. **Systematic Testing Works**
   - Test 1: value=500 → 5Hz
   - Test 2: value=1240 → 12Hz
   - Conclusion: Hz * 100 scaling confirmed
   - This methodology found the issue quickly

4. **Store and Echo Strategy**
   - Inverter writes configuration
   - We store it
   - We echo it back on reads
   - Simple and effective for configuration devices

## Hardware Configuration

**ESP32-S3-RS485-CAN (Waveshare)**
- CAN: GPIO15 TX, GPIO16 RX, 500kbps
- RS485: GPIO17 TX, GPIO18 RX, GPIO21 flow control
- Modbus addresses: 3 (BMS-Link) and 4 (Battery)
- Baud rate: 115200
- Direct connection to Epever UP5000 inverter

**Battery:**
- 2× Pylontech US3000C (280Ah each) in parallel
- Total capacity: 560Ah
- Communication: CAN bus (Pylontech protocol)
- CAN IDs: 0x351, 0x355, 0x359, 0x370

**Inverter:**
- Epever UP5000
- Protocol: "EPever BMS RS485 Modbus v1.6" (Protocol 10)
- Polls both Address 3 and Address 4 every ~3 seconds

## Firmware Details

**Current Version:**
- Compiled: 2026-01-13 19:33:34 +0100
- ESPHome: 2026.1.0-dev
- Custom component: `esp32_can_listen` (LISTEN_ONLY mode support)
- Firmware size: 930KB

**Build Environment:**
- Python 3.12.3
- Platform: ESP-IDF 5.5.2
- Framework: pioarduino/esp-idf
- Tools: All dependencies installed successfully

## References

- **BMS-Link Communication Address V1.6.pdf** - Official (but partially incorrect) documentation
- **esphome-epever/EPEVER_MODBUS_FINDINGS.md** - Detailed register findings
- **esphome-epever/IMPLEMENTATION_PLAN_ID3_ID4.md** - Implementation plan
- **GitHub:** https://github.com/mikaabra/pylontech-bms-mqtt

## End of Session

**Time Spent:** ~3 hours
**Lines of Code Added:** ~100
**Major Bugs Fixed:** 1 (Load Frequency display)
**New Discoveries:** 2 (Address 3/4 separation, Register 0x9009 = Frequency)
**Remaining Issues:** 2 (Battery Temp, Load Voltage)

**Overall Status:** ✅ Excellent progress! Core functionality working, inverter accepting our BMS data.
